var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports2.Fragment = 60107;
        exports2.StrictMode = 60108;
        exports2.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports2.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports2.Fragment = symbolFor("react.fragment");
          exports2.StrictMode = symbolFor("react.strict_mode");
          exports2.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports2.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports2.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports2.Profiler:
              return "Profiler";
            case exports2.StrictMode:
              return "StrictMode";
            case exports2.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentName(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape2("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render.displayName == null) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports2.Fragment || type === exports2.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports2.StrictMode || type === exports2.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type.displayName == null) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState6(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef6(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect7(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports2.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports2.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            /* @__PURE__ */ new Map([[frozenObject, null]]);
            /* @__PURE__ */ new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports2.Children = Children;
        exports2.Component = Component;
        exports2.PureComponent = PureComponent;
        exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports2.cloneElement = cloneElement$1;
        exports2.createContext = createContext;
        exports2.createElement = createElement$1;
        exports2.createFactory = createFactory;
        exports2.createRef = createRef;
        exports2.forwardRef = forwardRef;
        exports2.isValidElement = isValidElement;
        exports2.lazy = lazy;
        exports2.memo = memo;
        exports2.useCallback = useCallback;
        exports2.useContext = useContext;
        exports2.useDebugValue = useDebugValue;
        exports2.useEffect = useEffect7;
        exports2.useImperativeHandle = useImperativeHandle;
        exports2.useLayoutEffect = useLayoutEffect;
        exports2.useMemo = useMemo;
        exports2.useReducer = useReducer;
        exports2.useRef = useRef6;
        exports2.useState = useState6;
        exports2.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_development();
    }
  }
});

// (disabled):canvas
var require_canvas = __commonJS({
  "(disabled):canvas"() {
  }
});

// (disabled):fs
var require_fs = __commonJS({
  "(disabled):fs"() {
  }
});

// (disabled):zlib
var require_zlib = __commonJS({
  "(disabled):zlib"() {
  }
});

// (disabled):http
var require_http = __commonJS({
  "(disabled):http"() {
  }
});

// (disabled):https
var require_https = __commonJS({
  "(disabled):https"() {
  }
});

// (disabled):url
var require_url = __commonJS({
  "(disabled):url"() {
  }
});

// node_modules/pdfjs-dist/build/pdf.js
var require_pdf = __commonJS({
  "node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(exports, function() {
      return (() => {
        "use strict";
        var __webpack_modules__ = [
          ,
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.addLinkAttributes = addLinkAttributes;
            exports2.deprecated = deprecated;
            exports2.getFilenameFromUrl = getFilenameFromUrl;
            exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
            exports2.isDataScheme = isDataScheme;
            exports2.isFetchSupported = isFetchSupported;
            exports2.isPdfFile = isPdfFile;
            exports2.isValidFetchUrl = isValidFetchUrl;
            exports2.loadScript = loadScript;
            exports2.StatTimer = exports2.RenderingCancelledException = exports2.PDFDateString = exports2.PageViewport = exports2.LinkTarget = exports2.DOMSVGFactory = exports2.DOMCMapReaderFactory = exports2.DOMCanvasFactory = exports2.DEFAULT_LINK_REL = exports2.BaseCMapReaderFactory = exports2.BaseCanvasFactory = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
            exports2.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
            const SVG_NS = "http://www.w3.org/2000/svg";
            class BaseCanvasFactory {
              constructor() {
                if (this.constructor === BaseCanvasFactory) {
                  (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                }
              }
              create(width, height) {
                (0, _util2.unreachable)("Abstract method `create` called.");
              }
              reset(canvasAndContext, width, height) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                canvasAndContext.canvas.width = width;
                canvasAndContext.canvas.height = height;
              }
              destroy(canvasAndContext) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                canvasAndContext.canvas.width = 0;
                canvasAndContext.canvas.height = 0;
                canvasAndContext.canvas = null;
                canvasAndContext.context = null;
              }
            }
            exports2.BaseCanvasFactory = BaseCanvasFactory;
            class DOMCanvasFactory extends BaseCanvasFactory {
              constructor({
                ownerDocument = globalThis.document
              } = {}) {
                super();
                this._document = ownerDocument;
              }
              create(width, height) {
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                const canvas = this._document.createElement("canvas");
                const context = canvas.getContext("2d");
                canvas.width = width;
                canvas.height = height;
                return {
                  canvas,
                  context
                };
              }
            }
            exports2.DOMCanvasFactory = DOMCanvasFactory;
            class BaseCMapReaderFactory {
              constructor({
                baseUrl = null,
                isCompressed = false
              }) {
                if (this.constructor === BaseCMapReaderFactory) {
                  (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                }
                this.baseUrl = baseUrl;
                this.isCompressed = isCompressed;
              }
              fetch(_0) {
                return __async(this, arguments, function* ({
                  name
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  }
                  if (!name) {
                    throw new Error("CMap name must be specified.");
                  }
                  const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                  const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                  return this._fetchData(url, compressionType).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                  });
                });
              }
              _fetchData(url, compressionType) {
                (0, _util2.unreachable)("Abstract method `_fetchData` called.");
              }
            }
            exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
            class DOMCMapReaderFactory extends BaseCMapReaderFactory {
              _fetchData(url, compressionType) {
                if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {
                  return fetch(url).then((response) => __async(this, null, function* () {
                    if (!response.ok) {
                      throw new Error(response.statusText);
                    }
                    let cMapData;
                    if (this.isCompressed) {
                      cMapData = new Uint8Array(yield response.arrayBuffer());
                    } else {
                      cMapData = (0, _util2.stringToBytes)(yield response.text());
                    }
                    return {
                      cMapData,
                      compressionType
                    };
                  }));
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  if (this.isCompressed) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let cMapData;
                      if (this.isCompressed && request.response) {
                        cMapData = new Uint8Array(request.response);
                      } else if (!this.isCompressed && request.responseText) {
                        cMapData = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (cMapData) {
                        resolve({
                          cMapData,
                          compressionType
                        });
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                });
              }
            }
            exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
            class DOMSVGFactory {
              create(width, height) {
                (0, _util2.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
                const svg = document.createElementNS(SVG_NS, "svg:svg");
                svg.setAttribute("version", "1.1");
                svg.setAttribute("width", width + "px");
                svg.setAttribute("height", height + "px");
                svg.setAttribute("preserveAspectRatio", "none");
                svg.setAttribute("viewBox", "0 0 " + width + " " + height);
                return svg;
              }
              createElement(type) {
                (0, _util2.assert)(typeof type === "string", "Invalid SVG element type");
                return document.createElementNS(SVG_NS, type);
              }
            }
            exports2.DOMSVGFactory = DOMSVGFactory;
            class PageViewport {
              constructor({
                viewBox,
                scale,
                rotation,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              }) {
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                const centerX = (viewBox[2] + viewBox[0]) / 2;
                const centerY = (viewBox[3] + viewBox[1]) / 2;
                let rotateA, rotateB, rotateC, rotateD;
                rotation %= 360;
                if (rotation < 0) {
                  rotation += 360;
                }
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  case 0:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                  default:
                    throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                let offsetCanvasX, offsetCanvasY;
                let width, height;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
              }
              clone({
                scale = this.scale,
                rotation = this.rotation,
                offsetX = this.offsetX,
                offsetY = this.offsetY,
                dontFlip = false
              } = {}) {
                return new PageViewport({
                  viewBox: this.viewBox.slice(),
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              convertToViewportPoint(x, y) {
                return _util2.Util.applyTransform([x, y], this.transform);
              }
              convertToViewportRectangle(rect) {
                const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
              }
              convertToPdfPoint(x, y) {
                return _util2.Util.applyInverseTransform([x, y], this.transform);
              }
            }
            exports2.PageViewport = PageViewport;
            class RenderingCancelledException extends _util2.BaseException {
              constructor(msg, type) {
                super(msg);
                this.type = type;
              }
            }
            exports2.RenderingCancelledException = RenderingCancelledException;
            const LinkTarget = {
              NONE: 0,
              SELF: 1,
              BLANK: 2,
              PARENT: 3,
              TOP: 4
            };
            exports2.LinkTarget = LinkTarget;
            function addLinkAttributes(link, {
              url,
              target,
              rel,
              enabled = true
            } = {}) {
              (0, _util2.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
              const urlNullRemoved = (0, _util2.removeNullCharacters)(url);
              if (enabled) {
                link.href = link.title = urlNullRemoved;
              } else {
                link.href = "";
                link.title = `Disabled: ${urlNullRemoved}`;
                link.onclick = () => {
                  return false;
                };
              }
              let targetStr = "";
              switch (target) {
                case LinkTarget.NONE:
                  break;
                case LinkTarget.SELF:
                  targetStr = "_self";
                  break;
                case LinkTarget.BLANK:
                  targetStr = "_blank";
                  break;
                case LinkTarget.PARENT:
                  targetStr = "_parent";
                  break;
                case LinkTarget.TOP:
                  targetStr = "_top";
                  break;
              }
              link.target = targetStr;
              link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
            }
            function isDataScheme(url) {
              const ii = url.length;
              let i = 0;
              while (i < ii && url[i].trim() === "") {
                i++;
              }
              return url.substring(i, i + 5).toLowerCase() === "data:";
            }
            function isPdfFile(filename) {
              return typeof filename === "string" && /\.pdf$/i.test(filename);
            }
            function getFilenameFromUrl(url) {
              const anchor = url.indexOf("#");
              const query = url.indexOf("?");
              const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
              return url.substring(url.lastIndexOf("/", end) + 1, end);
            }
            function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
              if (typeof url !== "string") {
                return defaultFilename;
              }
              if (isDataScheme(url)) {
                (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                return defaultFilename;
              }
              const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
              const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
              const splitURI = reURI.exec(url);
              let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
              if (suggestedFilename) {
                suggestedFilename = suggestedFilename[0];
                if (suggestedFilename.includes("%")) {
                  try {
                    suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                  } catch (ex) {
                  }
                }
              }
              return suggestedFilename || defaultFilename;
            }
            class StatTimer {
              constructor() {
                this.started = /* @__PURE__ */ Object.create(null);
                this.times = [];
              }
              time(name) {
                if (name in this.started) {
                  (0, _util2.warn)(`Timer is already running for ${name}`);
                }
                this.started[name] = Date.now();
              }
              timeEnd(name) {
                if (!(name in this.started)) {
                  (0, _util2.warn)(`Timer has not been started for ${name}`);
                }
                this.times.push({
                  name,
                  start: this.started[name],
                  end: Date.now()
                });
                delete this.started[name];
              }
              toString() {
                const outBuf = [];
                let longest = 0;
                for (const time of this.times) {
                  const name = time.name;
                  if (name.length > longest) {
                    longest = name.length;
                  }
                }
                for (const time of this.times) {
                  const duration = time.end - time.start;
                  outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                }
                return outBuf.join("");
              }
            }
            exports2.StatTimer = StatTimer;
            function isFetchSupported() {
              return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
            }
            function isValidFetchUrl(url, baseUrl) {
              try {
                const {
                  protocol
                } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                return protocol === "http:" || protocol === "https:";
              } catch (ex) {
                return false;
              }
            }
            function loadScript(src, removeScriptElement = false) {
              return new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.src = src;
                script.onload = function(evt) {
                  if (removeScriptElement) {
                    script.remove();
                  }
                  resolve(evt);
                };
                script.onerror = function() {
                  reject(new Error(`Cannot load script at: ${script.src}`));
                };
                (document.head || document.documentElement).appendChild(script);
              });
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            let pdfDateStringRegex;
            class PDFDateString {
              static toDateObject(input) {
                if (!input || !(0, _util2.isString)(input)) {
                  return null;
                }
                if (!pdfDateStringRegex) {
                  pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                }
                const matches = pdfDateStringRegex.exec(input);
                if (!matches) {
                  return null;
                }
                const year = parseInt(matches[1], 10);
                let month = parseInt(matches[2], 10);
                month = month >= 1 && month <= 12 ? month - 1 : 0;
                let day = parseInt(matches[3], 10);
                day = day >= 1 && day <= 31 ? day : 1;
                let hour = parseInt(matches[4], 10);
                hour = hour >= 0 && hour <= 23 ? hour : 0;
                let minute = parseInt(matches[5], 10);
                minute = minute >= 0 && minute <= 59 ? minute : 0;
                let second = parseInt(matches[6], 10);
                second = second >= 0 && second <= 59 ? second : 0;
                const universalTimeRelation = matches[7] || "Z";
                let offsetHour = parseInt(matches[8], 10);
                offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                let offsetMinute = parseInt(matches[9], 10) || 0;
                offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                if (universalTimeRelation === "-") {
                  hour += offsetHour;
                  minute += offsetMinute;
                } else if (universalTimeRelation === "+") {
                  hour -= offsetHour;
                  minute -= offsetMinute;
                }
                return new Date(Date.UTC(year, month, day, hour, minute, second));
              }
            }
            exports2.PDFDateString = PDFDateString;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.arrayByteLength = arrayByteLength;
            exports2.arraysToBytes = arraysToBytes;
            exports2.assert = assert;
            exports2.bytesToString = bytesToString;
            exports2.createObjectURL = createObjectURL;
            exports2.createPromiseCapability = createPromiseCapability;
            exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports2.escapeString = escapeString;
            exports2.getModificationDate = getModificationDate;
            exports2.getVerbosityLevel = getVerbosityLevel;
            exports2.info = info;
            exports2.isArrayBuffer = isArrayBuffer;
            exports2.isArrayEqual = isArrayEqual;
            exports2.isAscii = isAscii;
            exports2.isBool = isBool;
            exports2.isNum = isNum;
            exports2.isSameOrigin = isSameOrigin;
            exports2.isString = isString;
            exports2.objectFromMap = objectFromMap;
            exports2.objectSize = objectSize;
            exports2.removeNullCharacters = removeNullCharacters;
            exports2.setVerbosityLevel = setVerbosityLevel;
            exports2.shadow = shadow;
            exports2.string32 = string32;
            exports2.stringToBytes = stringToBytes;
            exports2.stringToPDFString = stringToPDFString;
            exports2.stringToUTF16BEString = stringToUTF16BEString;
            exports2.stringToUTF8String = stringToUTF8String;
            exports2.unreachable = unreachable;
            exports2.utf8StringToString = utf8StringToString;
            exports2.warn = warn;
            exports2.VerbosityLevel = exports2.Util = exports2.UNSUPPORTED_FEATURES = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.IsLittleEndianCached = exports2.IsEvalSupportedCached = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
            __w_pdfjs_require__2(3);
            const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
            const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            const PermissionFlag = {
              PRINT: 4,
              MODIFY_CONTENTS: 8,
              COPY: 16,
              MODIFY_ANNOTATIONS: 32,
              FILL_INTERACTIVE_FORMS: 256,
              COPY_FOR_ACCESSIBILITY: 512,
              ASSEMBLE: 1024,
              PRINT_HIGH_QUALITY: 2048
            };
            exports2.PermissionFlag = PermissionFlag;
            const TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            exports2.TextRenderingMode = TextRenderingMode;
            const ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            exports2.ImageKind = ImageKind;
            const AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            exports2.AnnotationType = AnnotationType;
            const AnnotationStateModelType = {
              MARKED: "Marked",
              REVIEW: "Review"
            };
            exports2.AnnotationStateModelType = AnnotationStateModelType;
            const AnnotationMarkedState = {
              MARKED: "Marked",
              UNMARKED: "Unmarked"
            };
            exports2.AnnotationMarkedState = AnnotationMarkedState;
            const AnnotationReviewState = {
              ACCEPTED: "Accepted",
              REJECTED: "Rejected",
              CANCELLED: "Cancelled",
              COMPLETED: "Completed",
              NONE: "None"
            };
            exports2.AnnotationReviewState = AnnotationReviewState;
            const AnnotationReplyType = {
              GROUP: "Group",
              REPLY: "R"
            };
            exports2.AnnotationReplyType = AnnotationReplyType;
            const AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            exports2.AnnotationFlag = AnnotationFlag;
            const AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            exports2.AnnotationFieldFlag = AnnotationFieldFlag;
            const AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
            const AnnotationActionEventType = {
              E: "Mouse Enter",
              X: "Mouse Exit",
              D: "Mouse Down",
              U: "Mouse Up",
              Fo: "Focus",
              Bl: "Blur",
              PO: "PageOpen",
              PC: "PageClose",
              PV: "PageVisible",
              PI: "PageInvisible",
              K: "Keystroke",
              F: "Format",
              V: "Validate",
              C: "Calculate"
            };
            exports2.AnnotationActionEventType = AnnotationActionEventType;
            const DocumentActionEventType = {
              WC: "WillClose",
              WS: "WillSave",
              DS: "DidSave",
              WP: "WillPrint",
              DP: "DidPrint"
            };
            exports2.DocumentActionEventType = DocumentActionEventType;
            const PageActionEventType = {
              O: "PageOpen",
              C: "PageClose"
            };
            exports2.PageActionEventType = PageActionEventType;
            const StreamType = {
              UNKNOWN: "UNKNOWN",
              FLATE: "FLATE",
              LZW: "LZW",
              DCT: "DCT",
              JPX: "JPX",
              JBIG: "JBIG",
              A85: "A85",
              AHX: "AHX",
              CCF: "CCF",
              RLX: "RLX"
            };
            exports2.StreamType = StreamType;
            const FontType = {
              UNKNOWN: "UNKNOWN",
              TYPE1: "TYPE1",
              TYPE1C: "TYPE1C",
              CIDFONTTYPE0: "CIDFONTTYPE0",
              CIDFONTTYPE0C: "CIDFONTTYPE0C",
              TRUETYPE: "TRUETYPE",
              CIDFONTTYPE2: "CIDFONTTYPE2",
              TYPE3: "TYPE3",
              OPENTYPE: "OPENTYPE",
              TYPE0: "TYPE0",
              MMTYPE1: "MMTYPE1"
            };
            exports2.FontType = FontType;
            const VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            exports2.VerbosityLevel = VerbosityLevel;
            const CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            exports2.CMapCompressionType = CMapCompressionType;
            const OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            exports2.OPS = OPS;
            const UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font",
              errorTilingPattern: "errorTilingPattern",
              errorExtGState: "errorExtGState",
              errorXObject: "errorXObject",
              errorFontLoadType3: "errorFontLoadType3",
              errorFontState: "errorFontState",
              errorFontMissing: "errorFontMissing",
              errorFontTranslate: "errorFontTranslate",
              errorColorSpace: "errorColorSpace",
              errorOperatorList: "errorOperatorList",
              errorFontToUnicode: "errorFontToUnicode",
              errorFontLoadNative: "errorFontLoadNative",
              errorFontGetPath: "errorFontGetPath",
              errorMarkedContent: "errorMarkedContent"
            };
            exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            const PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            exports2.PasswordResponses = PasswordResponses;
            let verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log(`Info: ${msg}`);
              }
            }
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log(`Warning: ${msg}`);
              }
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            function isSameOrigin(baseUrl, otherUrl) {
              let base;
              try {
                base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e) {
                return false;
              }
              const other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function _isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (_isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            const BaseException = function BaseExceptionClosure() {
              function BaseException2(message) {
                if (this.constructor === BaseException2) {
                  unreachable("Cannot initialize BaseException.");
                }
                this.message = message;
                this.name = this.constructor.name;
              }
              BaseException2.prototype = new Error();
              BaseException2.constructor = BaseException2;
              return BaseException2;
            }();
            exports2.BaseException = BaseException;
            class PasswordException extends BaseException {
              constructor(msg, code) {
                super(msg);
                this.code = code;
              }
            }
            exports2.PasswordException = PasswordException;
            class UnknownErrorException extends BaseException {
              constructor(msg, details) {
                super(msg);
                this.details = details;
              }
            }
            exports2.UnknownErrorException = UnknownErrorException;
            class InvalidPDFException extends BaseException {
            }
            exports2.InvalidPDFException = InvalidPDFException;
            class MissingPDFException extends BaseException {
            }
            exports2.MissingPDFException = MissingPDFException;
            class UnexpectedResponseException extends BaseException {
              constructor(msg, status) {
                super(msg);
                this.status = status;
              }
            }
            exports2.UnexpectedResponseException = UnexpectedResponseException;
            class FormatError extends BaseException {
            }
            exports2.FormatError = FormatError;
            class AbortException extends BaseException {
            }
            exports2.AbortException = AbortException;
            const NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && typeof bytes === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              const length = bytes.length;
              const MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              const strBuf = [];
              for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                const chunk = bytes.subarray(i, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              const length = str.length;
              const bytes = new Uint8Array(length);
              for (let i = 0; i < length; ++i) {
                bytes[i] = str.charCodeAt(i) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0, "arrayByteLength - invalid argument.");
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              const length = arr.length;
              if (length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              let resultLength = 0;
              for (let i = 0; i < length; i++) {
                resultLength += arrayByteLength(arr[i]);
              }
              let pos = 0;
              const data = new Uint8Array(resultLength);
              for (let i = 0; i < length; i++) {
                let item = arr[i];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                const itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function objectSize(obj) {
              return Object.keys(obj).length;
            }
            function objectFromMap(map) {
              const obj = /* @__PURE__ */ Object.create(null);
              for (const [key, value] of map) {
                obj[key] = value;
              }
              return obj;
            }
            function isLittleEndian() {
              const buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              const view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            const IsLittleEndianCached = {
              get value() {
                return shadow(this, "value", isLittleEndian());
              }
            };
            exports2.IsLittleEndianCached = IsLittleEndianCached;
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e) {
                return false;
              }
            }
            const IsEvalSupportedCached = {
              get value() {
                return shadow(this, "value", isEvalSupported());
              }
            };
            exports2.IsEvalSupportedCached = IsEvalSupportedCached;
            const hexNumbers = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0"));
            class Util {
              static makeHexColor(r, g, b) {
                return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
              }
              static transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              }
              static applyTransform(p, m) {
                const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              }
              static applyInverseTransform(p, m) {
                const d = m[0] * m[3] - m[1] * m[2];
                const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                return [xt, yt];
              }
              static getAxialAlignedBoundingBox(r, m) {
                const p1 = Util.applyTransform(r, m);
                const p2 = Util.applyTransform(r.slice(2, 4), m);
                const p3 = Util.applyTransform([r[0], r[3]], m);
                const p4 = Util.applyTransform([r[2], r[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              }
              static inverseTransform(m) {
                const d = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
              }
              static apply3dTransform(m, v) {
                return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
              }
              static singularValueDecompose2dScale(m) {
                const transpose = [m[0], m[2], m[1], m[3]];
                const a = m[0] * transpose[0] + m[1] * transpose[2];
                const b = m[0] * transpose[1] + m[1] * transpose[3];
                const c = m[2] * transpose[0] + m[3] * transpose[2];
                const d = m[2] * transpose[1] + m[3] * transpose[3];
                const first = (a + d) / 2;
                const second = Math.sqrt(__pow(a + d, 2) - 4 * (a * d - c * b)) / 2;
                const sx = first + second || 1;
                const sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              }
              static normalizeRect(rect) {
                const r = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }
                return r;
              }
              static intersect(rect1, rect2) {
                function compare(a, b) {
                  return a - b;
                }
                const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                const result = [];
                rect1 = Util.normalizeRect(rect1);
                rect2 = Util.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return null;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return null;
                }
                return result;
              }
            }
            exports2.Util = Util;
            const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              const length = str.length, strBuf = [];
              if (str[0] === "\xFE" && str[1] === "\xFF") {
                for (let i = 2; i < length; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                }
              } else if (str[0] === "\xFF" && str[1] === "\xFE") {
                for (let i = 2; i < length; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
                }
              } else {
                for (let i = 0; i < length; ++i) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
              }
              return strBuf.join("");
            }
            function escapeString(str) {
              return str.replace(/([()\\\n\r])/g, (match) => {
                if (match === "\n") {
                  return "\\n";
                } else if (match === "\r") {
                  return "\\r";
                }
                return `\\${match}`;
              });
            }
            function isAscii(str) {
              return /^[\x00-\x7F]*$/.test(str);
            }
            function stringToUTF16BEString(str) {
              const buf = ["\xFE\xFF"];
              for (let i = 0, ii = str.length; i < ii; i++) {
                const char = str.charCodeAt(i);
                buf.push(String.fromCharCode(char >> 8 & 255));
                buf.push(String.fromCharCode(char & 255));
              }
              return buf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isString(v) {
              return typeof v === "string";
            }
            function isArrayBuffer(v) {
              return typeof v === "object" && v !== null && v.byteLength !== void 0;
            }
            function isArrayEqual(arr1, arr2) {
              if (arr1.length !== arr2.length) {
                return false;
              }
              for (let i = 0, ii = arr1.length; i < ii; i++) {
                if (arr1[i] !== arr2[i]) {
                  return false;
                }
              }
              return true;
            }
            function getModificationDate(date = new Date()) {
              const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
              return buffer.join("");
            }
            function createPromiseCapability() {
              const capability = /* @__PURE__ */ Object.create(null);
              let isSettled = false;
              Object.defineProperty(capability, "settled", {
                get() {
                  return isSettled;
                }
              });
              capability.promise = new Promise(function(resolve, reject) {
                capability.resolve = function(data) {
                  isSettled = true;
                  resolve(data);
                };
                capability.reject = function(reason) {
                  isSettled = true;
                  reject(reason);
                };
              });
              return capability;
            }
            function createObjectURL(data, contentType = "", forceDataSchema = false) {
              if (URL.createObjectURL && !forceDataSchema) {
                return URL.createObjectURL(new Blob([data], {
                  type: contentType
                }));
              }
              const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              let buffer = `data:${contentType};base64,`;
              for (let i = 0, ii = data.length; i < ii; i += 3) {
                const b1 = data[i] & 255;
                const b2 = data[i + 1] & 255;
                const b3 = data[i + 2] & 255;
                const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                const d4 = i + 2 < ii ? b3 & 63 : 64;
                buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
              }
              return buffer;
            }
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var _is_node2 = __w_pdfjs_require__2(4);
            ;
          },
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.isNodeJS = void 0;
            const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
            exports2.isNodeJS = isNodeJS;
          },
          (__unused_webpack_module, exports, __w_pdfjs_require__) => {
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.getDocument = getDocument;
            exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
            exports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;
            var _util = __w_pdfjs_require__(2);
            var _display_utils = __w_pdfjs_require__(1);
            var _font_loader = __w_pdfjs_require__(6);
            var _node_utils = __w_pdfjs_require__(7);
            var _annotation_storage = __w_pdfjs_require__(8);
            var _api_compatibility = __w_pdfjs_require__(9);
            var _canvas = __w_pdfjs_require__(10);
            var _worker_options = __w_pdfjs_require__(12);
            var _is_node = __w_pdfjs_require__(4);
            var _message_handler = __w_pdfjs_require__(13);
            var _metadata = __w_pdfjs_require__(14);
            var _optional_content_config = __w_pdfjs_require__(15);
            var _transport_stream = __w_pdfjs_require__(16);
            var _webgl = __w_pdfjs_require__(17);
            const DEFAULT_RANGE_CHUNK_SIZE = 65536;
            const RENDERING_CANCELLED_TIMEOUT = 100;
            const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
            exports.DefaultCanvasFactory = DefaultCanvasFactory;
            const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
            exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
            let createPDFNetworkStream;
            function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
              createPDFNetworkStream = pdfNetworkStreamFactory;
            }
            function getDocument(src) {
              const task = new PDFDocumentLoadingTask();
              let source;
              if (typeof src === "string" || src instanceof URL) {
                source = {
                  url: src
                };
              } else if ((0, _util.isArrayBuffer)(src)) {
                source = {
                  data: src
                };
              } else if (src instanceof PDFDataRangeTransport) {
                source = {
                  range: src
                };
              } else {
                if (typeof src !== "object") {
                  throw new Error("Invalid parameter in getDocument, need either string, URL, Uint8Array, or parameter object.");
                }
                if (!src.url && !src.data && !src.range) {
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                }
                source = src;
              }
              const params = /* @__PURE__ */ Object.create(null);
              let rangeTransport = null, worker2 = null;
              for (const key in source) {
                const value = source[key];
                switch (key) {
                  case "url":
                    if (typeof window !== "undefined") {
                      try {
                        params[key] = new URL(value, window.location).href;
                        continue;
                      } catch (ex) {
                        (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
                      }
                    } else if (typeof value === "string" || value instanceof URL) {
                      params[key] = value.toString();
                      continue;
                    }
                    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                  case "range":
                    rangeTransport = value;
                    continue;
                  case "worker":
                    worker2 = value;
                    continue;
                  case "data":
                    if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                      params[key] = new Uint8Array(value);
                    } else if (value instanceof Uint8Array) {
                      break;
                    } else if (typeof value === "string") {
                      params[key] = (0, _util.stringToBytes)(value);
                    } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
                      params[key] = new Uint8Array(value);
                    } else if ((0, _util.isArrayBuffer)(value)) {
                      params[key] = new Uint8Array(value);
                    } else {
                      throw new Error("Invalid PDF binary data: either typed array, string, or array-like object is expected in the data property.");
                    }
                    continue;
                }
                params[key] = value;
              }
              params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
              params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
              params.ignoreErrors = params.stopAtErrors !== true;
              params.fontExtraProperties = params.fontExtraProperties === true;
              params.pdfBug = params.pdfBug === true;
              params.enableXfa = params.enableXfa === true;
              if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                params.docBaseUrl = null;
              }
              if (!Number.isInteger(params.maxImageSize)) {
                params.maxImageSize = -1;
              }
              if (typeof params.isEvalSupported !== "boolean") {
                params.isEvalSupported = true;
              }
              if (typeof params.disableFontFace !== "boolean") {
                params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
              }
              if (typeof params.ownerDocument === "undefined") {
                params.ownerDocument = globalThis.document;
              }
              if (typeof params.disableRange !== "boolean") {
                params.disableRange = false;
              }
              if (typeof params.disableStream !== "boolean") {
                params.disableStream = false;
              }
              if (typeof params.disableAutoFetch !== "boolean") {
                params.disableAutoFetch = false;
              }
              (0, _util.setVerbosityLevel)(params.verbosity);
              if (!worker2) {
                const workerParams = {
                  verbosity: params.verbosity,
                  port: _worker_options.GlobalWorkerOptions.workerPort
                };
                worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                task._worker = worker2;
              }
              const docId = task.docId;
              worker2.promise.then(function() {
                if (task.destroyed) {
                  throw new Error("Loading aborted");
                }
                const workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                const networkStreamPromise = new Promise(function(resolve) {
                  let networkStream;
                  if (rangeTransport) {
                    networkStream = new _transport_stream.PDFDataTransportStream({
                      length: params.length,
                      initialData: params.initialData,
                      progressiveDone: params.progressiveDone,
                      contentDispositionFilename: params.contentDispositionFilename,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    }, rangeTransport);
                  } else if (!params.data) {
                    networkStream = createPDFNetworkStream({
                      url: params.url,
                      length: params.length,
                      httpHeaders: params.httpHeaders,
                      withCredentials: params.withCredentials,
                      rangeChunkSize: params.rangeChunkSize,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    });
                  }
                  resolve(networkStream);
                });
                return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                  messageHandler.postMessageTransfers = worker2.postMessageTransfers;
                  const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                  task._transport = transport;
                  messageHandler.send("Ready", null);
                });
              }).catch(task._capability.reject);
              return task;
            }
            function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
              if (worker2.destroyed) {
                return Promise.reject(new Error("Worker was destroyed"));
              }
              if (pdfDataRangeTransport) {
                source.length = pdfDataRangeTransport.length;
                source.initialData = pdfDataRangeTransport.initialData;
                source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
              }
              return worker2.messageHandler.sendWithPromise("GetDocRequest", {
                docId,
                apiVersion: "2.8.335",
                source: {
                  data: source.data,
                  url: source.url,
                  password: source.password,
                  disableAutoFetch: source.disableAutoFetch,
                  rangeChunkSize: source.rangeChunkSize,
                  length: source.length
                },
                maxImageSize: source.maxImageSize,
                disableFontFace: source.disableFontFace,
                postMessageTransfers: worker2.postMessageTransfers,
                docBaseUrl: source.docBaseUrl,
                ignoreErrors: source.ignoreErrors,
                isEvalSupported: source.isEvalSupported,
                fontExtraProperties: source.fontExtraProperties,
                enableXfa: source.enableXfa
              }).then(function(workerId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              });
            }
            const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
              let nextDocumentId = 0;
              class PDFDocumentLoadingTask2 {
                constructor() {
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = "d" + nextDocumentId++;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                destroy() {
                  this.destroyed = true;
                  const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                  return transportDestroyed.then(() => {
                    this._transport = null;
                    if (this._worker) {
                      this._worker.destroy();
                      this._worker = null;
                    }
                  });
                }
              }
              return PDFDocumentLoadingTask2;
            }();
            class PDFDataRangeTransport {
              constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
                this.length = length;
                this.initialData = initialData;
                this.progressiveDone = progressiveDone;
                this.contentDispositionFilename = contentDispositionFilename;
                this._rangeListeners = [];
                this._progressListeners = [];
                this._progressiveReadListeners = [];
                this._progressiveDoneListeners = [];
                this._readyCapability = (0, _util.createPromiseCapability)();
              }
              addRangeListener(listener) {
                this._rangeListeners.push(listener);
              }
              addProgressListener(listener) {
                this._progressListeners.push(listener);
              }
              addProgressiveReadListener(listener) {
                this._progressiveReadListeners.push(listener);
              }
              addProgressiveDoneListener(listener) {
                this._progressiveDoneListeners.push(listener);
              }
              onDataRange(begin, chunk) {
                for (const listener of this._rangeListeners) {
                  listener(begin, chunk);
                }
              }
              onDataProgress(loaded, total) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressListeners) {
                    listener(loaded, total);
                  }
                });
              }
              onDataProgressiveRead(chunk) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveReadListeners) {
                    listener(chunk);
                  }
                });
              }
              onDataProgressiveDone() {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveDoneListeners) {
                    listener();
                  }
                });
              }
              transportReady() {
                this._readyCapability.resolve();
              }
              requestDataRange(begin, end) {
                (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
              }
              abort() {
              }
            }
            exports.PDFDataRangeTransport = PDFDataRangeTransport;
            class PDFDocumentProxy {
              constructor(pdfInfo, transport) {
                this._pdfInfo = pdfInfo;
                this._transport = transport;
              }
              get annotationStorage() {
                return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
              }
              get numPages() {
                return this._pdfInfo.numPages;
              }
              get fingerprint() {
                return this._pdfInfo.fingerprint;
              }
              get isPureXfa() {
                return this._pdfInfo.isPureXfa;
              }
              getPage(pageNumber) {
                return this._transport.getPage(pageNumber);
              }
              getPageIndex(ref) {
                return this._transport.getPageIndex(ref);
              }
              getDestinations() {
                return this._transport.getDestinations();
              }
              getDestination(id) {
                return this._transport.getDestination(id);
              }
              getPageLabels() {
                return this._transport.getPageLabels();
              }
              getPageLayout() {
                return this._transport.getPageLayout();
              }
              getPageMode() {
                return this._transport.getPageMode();
              }
              getViewerPreferences() {
                return this._transport.getViewerPreferences();
              }
              getOpenAction() {
                return this._transport.getOpenAction();
              }
              getAttachments() {
                return this._transport.getAttachments();
              }
              getJavaScript() {
                return this._transport.getJavaScript();
              }
              getJSActions() {
                return this._transport.getDocJSActions();
              }
              getOutline() {
                return this._transport.getOutline();
              }
              getOptionalContentConfig() {
                return this._transport.getOptionalContentConfig();
              }
              getPermissions() {
                return this._transport.getPermissions();
              }
              getMetadata() {
                return this._transport.getMetadata();
              }
              getMarkInfo() {
                return this._transport.getMarkInfo();
              }
              getData() {
                return this._transport.getData();
              }
              getDownloadInfo() {
                return this._transport.downloadInfoCapability.promise;
              }
              getStats() {
                return this._transport.getStats();
              }
              cleanup(keepLoadedFonts = false) {
                return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
              }
              destroy() {
                return this.loadingTask.destroy();
              }
              get loadingParams() {
                return this._transport.loadingParams;
              }
              get loadingTask() {
                return this._transport.loadingTask;
              }
              saveDocument(annotationStorage) {
                return this._transport.saveDocument(annotationStorage);
              }
              getFieldObjects() {
                return this._transport.getFieldObjects();
              }
              hasJSActions() {
                return this._transport.hasJSActions();
              }
              getCalculationOrderIds() {
                return this._transport.getCalculationOrderIds();
              }
            }
            exports.PDFDocumentProxy = PDFDocumentProxy;
            class PDFPageProxy {
              constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
                this._pageIndex = pageIndex;
                this._pageInfo = pageInfo;
                this._ownerDocument = ownerDocument;
                this._transport = transport;
                this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                this._pdfBug = pdfBug;
                this.commonObjs = transport.commonObjs;
                this.objs = new PDFObjects();
                this.cleanupAfterRender = false;
                this.pendingCleanup = false;
                this._intentStates = /* @__PURE__ */ new Map();
                this.destroyed = false;
              }
              get pageNumber() {
                return this._pageIndex + 1;
              }
              get rotate() {
                return this._pageInfo.rotate;
              }
              get ref() {
                return this._pageInfo.ref;
              }
              get userUnit() {
                return this._pageInfo.userUnit;
              }
              get view() {
                return this._pageInfo.view;
              }
              getViewport({
                scale,
                rotation = this.rotate,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              } = {}) {
                return new _display_utils.PageViewport({
                  viewBox: this.view,
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              getAnnotations({
                intent = null
              } = {}) {
                if (!this._annotationsPromise || this._annotationsIntent !== intent) {
                  this._annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
                  this._annotationsIntent = intent;
                }
                return this._annotationsPromise;
              }
              getJSActions() {
                return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
              }
              getXfa() {
                return this._xfaPromise || (this._xfaPromise = this._transport.getPageXfa(this._pageIndex));
              }
              render({
                canvasContext,
                viewport,
                intent = "display",
                enableWebGL = false,
                renderInteractiveForms = false,
                transform = null,
                imageLayer = null,
                canvasFactory = null,
                background = null,
                annotationStorage = null,
                optionalContentConfigPromise = null
              }) {
                var _intentState;
                if (this._stats) {
                  this._stats.time("Overall");
                }
                const renderingIntent = intent === "print" ? "print" : "display";
                this.pendingCleanup = false;
                if (!optionalContentConfigPromise) {
                  optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                }
                let intentState = this._intentStates.get(renderingIntent);
                if (!intentState) {
                  intentState = /* @__PURE__ */ Object.create(null);
                  this._intentStates.set(renderingIntent, intentState);
                }
                if (intentState.streamReaderCancelTimeout) {
                  clearTimeout(intentState.streamReaderCancelTimeout);
                  intentState.streamReaderCancelTimeout = null;
                }
                const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                  ownerDocument: this._ownerDocument
                });
                const webGLContext = new _webgl.WebGLContext({
                  enable: enableWebGL
                });
                if (!intentState.displayReadyCapability) {
                  intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };
                  if (this._stats) {
                    this._stats.time("Page Request");
                  }
                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    renderInteractiveForms: renderInteractiveForms === true,
                    annotationStorage: (annotationStorage == null ? void 0 : annotationStorage.serializable) || null
                  });
                }
                const complete = (error) => {
                  intentState.renderTasks.delete(internalRenderTask);
                  if (this.cleanupAfterRender || renderingIntent === "print") {
                    this.pendingCleanup = true;
                  }
                  this._tryCleanup();
                  if (error) {
                    internalRenderTask.capability.reject(error);
                    this._abortOperatorList({
                      intentState,
                      reason: error
                    });
                  } else {
                    internalRenderTask.capability.resolve();
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Rendering");
                    this._stats.timeEnd("Overall");
                  }
                };
                const internalRenderTask = new InternalRenderTask({
                  callback: complete,
                  params: {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  },
                  objs: this.objs,
                  commonObjs: this.commonObjs,
                  operatorList: intentState.operatorList,
                  pageIndex: this._pageIndex,
                  canvasFactory: canvasFactoryInstance,
                  webGLContext,
                  useRequestAnimationFrame: renderingIntent !== "print",
                  pdfBug: this._pdfBug
                });
                ((_intentState = intentState).renderTasks || (_intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
                const renderTask = internalRenderTask.task;
                Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                  if (this.pendingCleanup) {
                    complete();
                    return;
                  }
                  if (this._stats) {
                    this._stats.time("Rendering");
                  }
                  internalRenderTask.initializeGraphics({
                    transparency,
                    optionalContentConfig
                  });
                  internalRenderTask.operatorListChanged();
                }).catch(complete);
                return renderTask;
              }
              getOperatorList() {
                function operatorListChanged() {
                  if (intentState.operatorList.lastChunk) {
                    intentState.opListReadCapability.resolve(intentState.operatorList);
                    intentState.renderTasks.delete(opListTask);
                  }
                }
                const renderingIntent = "oplist";
                let intentState = this._intentStates.get(renderingIntent);
                if (!intentState) {
                  intentState = /* @__PURE__ */ Object.create(null);
                  this._intentStates.set(renderingIntent, intentState);
                }
                let opListTask;
                if (!intentState.opListReadCapability) {
                  var _intentState2;
                  opListTask = /* @__PURE__ */ Object.create(null);
                  opListTask.operatorListChanged = operatorListChanged;
                  intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                  ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };
                  if (this._stats) {
                    this._stats.time("Page Request");
                  }
                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent
                  });
                }
                return intentState.opListReadCapability.promise;
              }
              streamTextContent({
                normalizeWhitespace = false,
                disableCombineTextItems = false
              } = {}) {
                const TEXT_CONTENT_CHUNK_SIZE = 100;
                return this._transport.messageHandler.sendWithStream("GetTextContent", {
                  pageIndex: this._pageIndex,
                  normalizeWhitespace: normalizeWhitespace === true,
                  combineTextItems: disableCombineTextItems !== true
                }, {
                  highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                  size(textContent) {
                    return textContent.items.length;
                  }
                });
              }
              getTextContent(params = {}) {
                const readableStream = this.streamTextContent(params);
                return new Promise(function(resolve, reject) {
                  function pump() {
                    reader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        resolve(textContent);
                        return;
                      }
                      Object.assign(textContent.styles, value.styles);
                      textContent.items.push(...value.items);
                      pump();
                    }, reject);
                  }
                  const reader = readableStream.getReader();
                  const textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  pump();
                });
              }
              _destroy() {
                this.destroyed = true;
                this._transport.pageCache[this._pageIndex] = null;
                const waitOn = [];
                for (const [intent, intentState] of this._intentStates) {
                  this._abortOperatorList({
                    intentState,
                    reason: new Error("Page was destroyed."),
                    force: true
                  });
                  if (intent === "oplist") {
                    continue;
                  }
                  for (const internalRenderTask of intentState.renderTasks) {
                    waitOn.push(internalRenderTask.completed);
                    internalRenderTask.cancel();
                  }
                }
                this.objs.clear();
                this._annotationsPromise = null;
                this._jsActionsPromise = null;
                this._xfaPromise = null;
                this.pendingCleanup = false;
                return Promise.all(waitOn);
              }
              cleanup(resetStats = false) {
                this.pendingCleanup = true;
                return this._tryCleanup(resetStats);
              }
              _tryCleanup(resetStats = false) {
                if (!this.pendingCleanup) {
                  return false;
                }
                for (const {
                  renderTasks,
                  operatorList
                } of this._intentStates.values()) {
                  if (renderTasks.size > 0 || !operatorList.lastChunk) {
                    return false;
                  }
                }
                this._intentStates.clear();
                this.objs.clear();
                this._annotationsPromise = null;
                this._jsActionsPromise = null;
                this._xfaPromise = null;
                if (resetStats && this._stats) {
                  this._stats = new _display_utils.StatTimer();
                }
                this.pendingCleanup = false;
                return true;
              }
              _startRenderPage(transparency, intent) {
                const intentState = this._intentStates.get(intent);
                if (!intentState) {
                  return;
                }
                if (this._stats) {
                  this._stats.timeEnd("Page Request");
                }
                if (intentState.displayReadyCapability) {
                  intentState.displayReadyCapability.resolve(transparency);
                }
              }
              _renderPageChunk(operatorListChunk, intentState) {
                for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                  intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                  intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                }
                intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                for (const internalRenderTask of intentState.renderTasks) {
                  internalRenderTask.operatorListChanged();
                }
                if (operatorListChunk.lastChunk) {
                  this._tryCleanup();
                }
              }
              _pumpOperatorList(args) {
                (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');
                const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);
                const reader = readableStream.getReader();
                const intentState = this._intentStates.get(args.intent);
                intentState.streamReader = reader;
                const pump = () => {
                  reader.read().then(({
                    value,
                    done
                  }) => {
                    if (done) {
                      intentState.streamReader = null;
                      return;
                    }
                    if (this._transport.destroyed) {
                      return;
                    }
                    this._renderPageChunk(value, intentState);
                    pump();
                  }, (reason) => {
                    intentState.streamReader = null;
                    if (this._transport.destroyed) {
                      return;
                    }
                    if (intentState.operatorList) {
                      intentState.operatorList.lastChunk = true;
                      for (const internalRenderTask of intentState.renderTasks) {
                        internalRenderTask.operatorListChanged();
                      }
                      this._tryCleanup();
                    }
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.reject(reason);
                    } else if (intentState.opListReadCapability) {
                      intentState.opListReadCapability.reject(reason);
                    } else {
                      throw reason;
                    }
                  });
                };
                pump();
              }
              _abortOperatorList({
                intentState,
                reason,
                force = false
              }) {
                (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');
                if (!intentState.streamReader) {
                  return;
                }
                if (!force) {
                  if (intentState.renderTasks.size > 0) {
                    return;
                  }
                  if (reason instanceof _display_utils.RenderingCancelledException) {
                    intentState.streamReaderCancelTimeout = setTimeout(() => {
                      this._abortOperatorList({
                        intentState,
                        reason,
                        force: true
                      });
                      intentState.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }
                intentState.streamReader.cancel(new _util.AbortException(reason == null ? void 0 : reason.message));
                intentState.streamReader = null;
                if (this._transport.destroyed) {
                  return;
                }
                for (const [intent, curIntentState] of this._intentStates) {
                  if (curIntentState === intentState) {
                    this._intentStates.delete(intent);
                    break;
                  }
                }
                this.cleanup();
              }
              get stats() {
                return this._stats;
              }
            }
            exports.PDFPageProxy = PDFPageProxy;
            class LoopbackPort {
              constructor() {
                this._listeners = [];
                this._deferred = Promise.resolve(void 0);
              }
              postMessage(obj, transfers) {
                function cloneValue(value) {
                  var _a;
                  if (typeof value !== "object" || value === null) {
                    return value;
                  }
                  if (cloned.has(value)) {
                    return cloned.get(value);
                  }
                  let buffer, result;
                  if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                    if (transfers == null ? void 0 : transfers.includes(buffer)) {
                      result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                    } else {
                      result = new value.constructor(value);
                    }
                    cloned.set(value, result);
                    return result;
                  }
                  if (value instanceof Map) {
                    result = /* @__PURE__ */ new Map();
                    cloned.set(value, result);
                    for (const [key, val] of value) {
                      result.set(key, cloneValue(val));
                    }
                    return result;
                  }
                  if (value instanceof Set) {
                    result = /* @__PURE__ */ new Set();
                    cloned.set(value, result);
                    for (const val of value) {
                      result.add(cloneValue(val));
                    }
                    return result;
                  }
                  result = Array.isArray(value) ? [] : {};
                  cloned.set(value, result);
                  for (const i in value) {
                    let desc, p = value;
                    while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
                      p = Object.getPrototypeOf(p);
                    }
                    if (typeof desc.value === "undefined") {
                      continue;
                    }
                    if (typeof desc.value === "function") {
                      if ((_a = value.hasOwnProperty) == null ? void 0 : _a.call(value, i)) {
                        throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);
                      }
                      continue;
                    }
                    result[i] = cloneValue(desc.value);
                  }
                  return result;
                }
                const cloned = /* @__PURE__ */ new WeakMap();
                const event = {
                  data: cloneValue(obj)
                };
                this._deferred.then(() => {
                  for (const listener of this._listeners) {
                    listener.call(this, event);
                  }
                });
              }
              addEventListener(name, listener) {
                this._listeners.push(listener);
              }
              removeEventListener(name, listener) {
                const i = this._listeners.indexOf(listener);
                this._listeners.splice(i, 1);
              }
              terminate() {
                this._listeners.length = 0;
              }
            }
            exports.LoopbackPort = LoopbackPort;
            const PDFWorker = function PDFWorkerClosure() {
              var _a;
              const pdfWorkerPorts = /* @__PURE__ */ new WeakMap();
              let isWorkerDisabled = false;
              let fallbackWorkerSrc;
              let nextFakeWorkerId = 0;
              let fakeWorkerCapability;
              if (_is_node.isNodeJS && typeof __require === "function") {
                isWorkerDisabled = true;
                fallbackWorkerSrc = "./pdf.worker.js";
              } else if (typeof document === "object" && "currentScript" in document) {
                const pdfjsFilePath2 = (_a = document.currentScript) == null ? void 0 : _a.src;
                if (pdfjsFilePath2) {
                  fallbackWorkerSrc = pdfjsFilePath2.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                }
              }
              function getWorkerSrc() {
                if (_worker_options.GlobalWorkerOptions.workerSrc) {
                  return _worker_options.GlobalWorkerOptions.workerSrc;
                }
                if (typeof fallbackWorkerSrc !== "undefined") {
                  if (!_is_node.isNodeJS) {
                    (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                  return fallbackWorkerSrc;
                }
                throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              function getMainThreadWorkerMessageHandler() {
                var _a2;
                let mainWorkerMessageHandler2;
                try {
                  mainWorkerMessageHandler2 = (_a2 = globalThis.pdfjsWorker) == null ? void 0 : _a2.WorkerMessageHandler;
                } catch (ex) {
                }
                return mainWorkerMessageHandler2 || null;
              }
              function setupFakeWorkerGlobal() {
                if (fakeWorkerCapability) {
                  return fakeWorkerCapability.promise;
                }
                fakeWorkerCapability = (0, _util.createPromiseCapability)();
                const loader = function() {
                  return __async(this, null, function* () {
                    const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                    if (mainWorkerMessageHandler) {
                      return mainWorkerMessageHandler;
                    }
                    if (_is_node.isNodeJS && typeof __require === "function") {
                      const worker = eval("require")(getWorkerSrc());
                      return worker.WorkerMessageHandler;
                    }
                    yield (0, _display_utils.loadScript)(getWorkerSrc());
                    return window.pdfjsWorker.WorkerMessageHandler;
                  });
                };
                loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
                return fakeWorkerCapability.promise;
              }
              function createCDNWrapper(url) {
                const wrapper = "importScripts('" + url + "');";
                return URL.createObjectURL(new Blob([wrapper]));
              }
              class PDFWorker {
                constructor({
                  name = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  if (port && pdfWorkerPorts.has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.postMessageTransfers = true;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    pdfWorkerPorts.set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                }
                _initialize() {
                  if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                    let workerSrc = getWorkerSrc();
                    try {
                      if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
                        workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          if (!data.supportTransfers) {
                            this.postMessageTransfers = false;
                          }
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e) {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);
                        try {
                          messageHandler.send("test", testObj, [testObj.buffer]);
                        } catch (ex) {
                          (0, _util.warn)("Cannot use postMessage transfers.");
                          testObj[0] = 0;
                          messageHandler.send("test", testObj);
                        }
                      };
                      sendTest();
                      return;
                    } catch (e) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    isWorkerDisabled = true;
                  }
                  setupFakeWorkerGlobal().then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id = "fake" + nextFakeWorkerId++;
                    const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  pdfWorkerPorts.delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!params || !params.port) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (pdfWorkerPorts.has(params.port)) {
                    return pdfWorkerPorts.get(params.port);
                  }
                  return new PDFWorker(params);
                }
                static getWorkerSrc() {
                  return getWorkerSrc();
                }
              }
              return PDFWorker;
            }();
            exports.PDFWorker = PDFWorker;
            class WorkerTransport {
              constructor(messageHandler, loadingTask, networkStream, params) {
                this.messageHandler = messageHandler;
                this.loadingTask = loadingTask;
                this.commonObjs = new PDFObjects();
                this.fontLoader = new _font_loader.FontLoader({
                  docId: loadingTask.docId,
                  onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                  ownerDocument: params.ownerDocument
                });
                this._params = params;
                this.CMapReaderFactory = new params.CMapReaderFactory({
                  baseUrl: params.cMapUrl,
                  isCompressed: params.cMapPacked
                });
                this.destroyed = false;
                this.destroyCapability = null;
                this._passwordCapability = null;
                this._networkStream = networkStream;
                this._fullReader = null;
                this._lastProgress = null;
                this.pageCache = [];
                this.pagePromises = [];
                this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                this.setupMessageHandler();
              }
              get loadingTaskSettled() {
                return this.loadingTask._capability.settled;
              }
              destroy() {
                if (this.destroyCapability) {
                  return this.destroyCapability.promise;
                }
                this.destroyed = true;
                this.destroyCapability = (0, _util.createPromiseCapability)();
                if (this._passwordCapability) {
                  this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                }
                const waitOn = [];
                this.pageCache.forEach(function(page) {
                  if (page) {
                    waitOn.push(page._destroy());
                  }
                });
                this.pageCache.length = 0;
                this.pagePromises.length = 0;
                const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                waitOn.push(terminated);
                if (this.loadingTaskSettled) {
                  const annotationStorageResetModified = this.loadingTask.promise.then((pdfDocument) => {
                    if (pdfDocument.hasOwnProperty("annotationStorage")) {
                      pdfDocument.annotationStorage.resetModified();
                    }
                  }).catch(() => {
                  });
                  waitOn.push(annotationStorageResetModified);
                }
                Promise.all(waitOn).then(() => {
                  this.commonObjs.clear();
                  this.fontLoader.clear();
                  this._hasJSActionsPromise = null;
                  if (this._networkStream) {
                    this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                  }
                  if (this.messageHandler) {
                    this.messageHandler.destroy();
                    this.messageHandler = null;
                  }
                  this.destroyCapability.resolve();
                }, this.destroyCapability.reject);
                return this.destroyCapability.promise;
              }
              setupMessageHandler() {
                const {
                  messageHandler,
                  loadingTask
                } = this;
                messageHandler.on("GetReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                  this._fullReader = this._networkStream.getFullReader();
                  this._fullReader.onProgress = (evt) => {
                    this._lastProgress = {
                      loaded: evt.loaded,
                      total: evt.total
                    };
                  };
                  sink.onPull = () => {
                    this._fullReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    this._fullReader.cancel(reason);
                    sink.ready.catch((readyReason) => {
                      if (this.destroyed) {
                        return;
                      }
                      throw readyReason;
                    });
                  };
                });
                messageHandler.on("ReaderHeadersReady", (data) => {
                  const headersCapability = (0, _util.createPromiseCapability)();
                  const fullReader = this._fullReader;
                  fullReader.headersReady.then(() => {
                    if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                      if (this._lastProgress && loadingTask.onProgress) {
                        loadingTask.onProgress(this._lastProgress);
                      }
                      fullReader.onProgress = (evt) => {
                        if (loadingTask.onProgress) {
                          loadingTask.onProgress({
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        }
                      };
                    }
                    headersCapability.resolve({
                      isStreamingSupported: fullReader.isStreamingSupported,
                      isRangeSupported: fullReader.isRangeSupported,
                      contentLength: fullReader.contentLength
                    });
                  }, headersCapability.reject);
                  return headersCapability.promise;
                });
                messageHandler.on("GetRangeReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                  const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                  if (!rangeReader) {
                    sink.close();
                    return;
                  }
                  sink.onPull = () => {
                    rangeReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    rangeReader.cancel(reason);
                    sink.ready.catch((readyReason) => {
                      if (this.destroyed) {
                        return;
                      }
                      throw readyReason;
                    });
                  };
                });
                messageHandler.on("GetDoc", ({
                  pdfInfo
                }) => {
                  this._numPages = pdfInfo.numPages;
                  loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                });
                messageHandler.on("DocException", function(ex) {
                  let reason;
                  switch (ex.name) {
                    case "PasswordException":
                      reason = new _util.PasswordException(ex.message, ex.code);
                      break;
                    case "InvalidPDFException":
                      reason = new _util.InvalidPDFException(ex.message);
                      break;
                    case "MissingPDFException":
                      reason = new _util.MissingPDFException(ex.message);
                      break;
                    case "UnexpectedResponseException":
                      reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                      break;
                    case "UnknownErrorException":
                      reason = new _util.UnknownErrorException(ex.message, ex.details);
                      break;
                  }
                  if (!(reason instanceof Error)) {
                    const msg = "DocException - expected a valid Error.";
                    (0, _util.warn)(msg);
                  }
                  loadingTask._capability.reject(reason);
                });
                messageHandler.on("PasswordRequest", (exception) => {
                  this._passwordCapability = (0, _util.createPromiseCapability)();
                  if (loadingTask.onPassword) {
                    const updatePassword = (password) => {
                      this._passwordCapability.resolve({
                        password
                      });
                    };
                    try {
                      loadingTask.onPassword(updatePassword, exception.code);
                    } catch (ex) {
                      this._passwordCapability.reject(ex);
                    }
                  } else {
                    this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                  }
                  return this._passwordCapability.promise;
                });
                messageHandler.on("DataLoaded", (data) => {
                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.length,
                      total: data.length
                    });
                  }
                  this.downloadInfoCapability.resolve(data);
                });
                messageHandler.on("StartRenderPage", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  const page = this.pageCache[data.pageIndex];
                  page._startRenderPage(data.transparency, data.intent);
                });
                messageHandler.on("commonobj", (data) => {
                  var _a;
                  if (this.destroyed) {
                    return;
                  }
                  const [id, type, exportedData] = data;
                  if (this.commonObjs.has(id)) {
                    return;
                  }
                  switch (type) {
                    case "Font":
                      const params = this._params;
                      if ("error" in exportedData) {
                        const exportedError = exportedData.error;
                        (0, _util.warn)(`Error during font loading: ${exportedError}`);
                        this.commonObjs.resolve(id, exportedError);
                        break;
                      }
                      let fontRegistry = null;
                      if (params.pdfBug && ((_a = globalThis.FontInspector) == null ? void 0 : _a.enabled)) {
                        fontRegistry = {
                          registerFont(font2, url) {
                            globalThis.FontInspector.fontAdded(font2, url);
                          }
                        };
                      }
                      const font = new _font_loader.FontFaceObject(exportedData, {
                        isEvalSupported: params.isEvalSupported,
                        disableFontFace: params.disableFontFace,
                        ignoreErrors: params.ignoreErrors,
                        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                        fontRegistry
                      });
                      this.fontLoader.bind(font).catch((reason) => {
                        return messageHandler.sendWithPromise("FontFallback", {
                          id
                        });
                      }).finally(() => {
                        if (!params.fontExtraProperties && font.data) {
                          font.data = null;
                        }
                        this.commonObjs.resolve(id, font);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                      this.commonObjs.resolve(id, exportedData);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${type}`);
                  }
                });
                messageHandler.on("obj", (data) => {
                  var _a;
                  if (this.destroyed) {
                    return void 0;
                  }
                  const [id, pageIndex, type, imageData] = data;
                  const pageProxy = this.pageCache[pageIndex];
                  if (pageProxy.objs.has(id)) {
                    return void 0;
                  }
                  switch (type) {
                    case "Image":
                      pageProxy.objs.resolve(id, imageData);
                      const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                      if (((_a = imageData == null ? void 0 : imageData.data) == null ? void 0 : _a.length) > MAX_IMAGE_SIZE_TO_STORE) {
                        pageProxy.cleanupAfterRender = true;
                      }
                      break;
                    default:
                      throw new Error(`Got unknown object type ${type}`);
                  }
                  return void 0;
                });
                messageHandler.on("DocProgress", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.loaded,
                      total: data.total
                    });
                  }
                });
                messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                messageHandler.on("FetchBuiltInCMap", (data, sink) => {
                  if (this.destroyed) {
                    sink.error(new Error("Worker was destroyed"));
                    return;
                  }
                  let fetched = false;
                  sink.onPull = () => {
                    if (fetched) {
                      sink.close();
                      return;
                    }
                    fetched = true;
                    this.CMapReaderFactory.fetch(data).then(function(builtInCMap) {
                      sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
                    }).catch(function(reason) {
                      sink.error(reason);
                    });
                  };
                });
              }
              _onUnsupportedFeature({
                featureId
              }) {
                if (this.destroyed) {
                  return;
                }
                if (this.loadingTask.onUnsupportedFeature) {
                  this.loadingTask.onUnsupportedFeature(featureId);
                }
              }
              getData() {
                return this.messageHandler.sendWithPromise("GetData", null);
              }
              getPage(pageNumber) {
                if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                  return Promise.reject(new Error("Invalid page request"));
                }
                const pageIndex = pageNumber - 1;
                if (pageIndex in this.pagePromises) {
                  return this.pagePromises[pageIndex];
                }
                const promise = this.messageHandler.sendWithPromise("GetPage", {
                  pageIndex
                }).then((pageInfo) => {
                  if (this.destroyed) {
                    throw new Error("Transport destroyed");
                  }
                  const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
                  this.pageCache[pageIndex] = page;
                  return page;
                });
                this.pagePromises[pageIndex] = promise;
                return promise;
              }
              getPageIndex(ref) {
                return this.messageHandler.sendWithPromise("GetPageIndex", {
                  ref
                }).catch(function(reason) {
                  return Promise.reject(new Error(reason));
                });
              }
              getAnnotations(pageIndex, intent) {
                return this.messageHandler.sendWithPromise("GetAnnotations", {
                  pageIndex,
                  intent
                });
              }
              saveDocument(annotationStorage) {
                var _a, _b;
                return this.messageHandler.sendWithPromise("SaveDocument", {
                  numPages: this._numPages,
                  annotationStorage: (annotationStorage == null ? void 0 : annotationStorage.serializable) || null,
                  filename: (_b = (_a = this._fullReader) == null ? void 0 : _a.filename) != null ? _b : null
                }).finally(() => {
                  if (annotationStorage) {
                    annotationStorage.resetModified();
                  }
                });
              }
              getFieldObjects() {
                return this.messageHandler.sendWithPromise("GetFieldObjects", null);
              }
              hasJSActions() {
                return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
              }
              getCalculationOrderIds() {
                return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
              }
              getDestinations() {
                return this.messageHandler.sendWithPromise("GetDestinations", null);
              }
              getDestination(id) {
                if (typeof id !== "string") {
                  return Promise.reject(new Error("Invalid destination request."));
                }
                return this.messageHandler.sendWithPromise("GetDestination", {
                  id
                });
              }
              getPageLabels() {
                return this.messageHandler.sendWithPromise("GetPageLabels", null);
              }
              getPageLayout() {
                return this.messageHandler.sendWithPromise("GetPageLayout", null);
              }
              getPageMode() {
                return this.messageHandler.sendWithPromise("GetPageMode", null);
              }
              getViewerPreferences() {
                return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
              }
              getOpenAction() {
                return this.messageHandler.sendWithPromise("GetOpenAction", null);
              }
              getAttachments() {
                return this.messageHandler.sendWithPromise("GetAttachments", null);
              }
              getJavaScript() {
                return this.messageHandler.sendWithPromise("GetJavaScript", null);
              }
              getDocJSActions() {
                return this.messageHandler.sendWithPromise("GetDocJSActions", null);
              }
              getPageJSActions(pageIndex) {
                return this.messageHandler.sendWithPromise("GetPageJSActions", {
                  pageIndex
                });
              }
              getPageXfa(pageIndex) {
                return this.messageHandler.sendWithPromise("GetPageXfa", {
                  pageIndex
                });
              }
              getOutline() {
                return this.messageHandler.sendWithPromise("GetOutline", null);
              }
              getOptionalContentConfig() {
                return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                  return new _optional_content_config.OptionalContentConfig(results);
                });
              }
              getPermissions() {
                return this.messageHandler.sendWithPromise("GetPermissions", null);
              }
              getMetadata() {
                return this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                  var _a, _b, _c, _d;
                  return {
                    info: results[0],
                    metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                    contentDispositionFilename: (_b = (_a = this._fullReader) == null ? void 0 : _a.filename) != null ? _b : null,
                    contentLength: (_d = (_c = this._fullReader) == null ? void 0 : _c.contentLength) != null ? _d : null
                  };
                });
              }
              getMarkInfo() {
                return this.messageHandler.sendWithPromise("GetMarkInfo", null);
              }
              getStats() {
                return this.messageHandler.sendWithPromise("GetStats", null);
              }
              startCleanup(keepLoadedFonts = false) {
                return __async(this, null, function* () {
                  yield this.messageHandler.sendWithPromise("Cleanup", null);
                  if (this.destroyed) {
                    return;
                  }
                  for (let i = 0, ii = this.pageCache.length; i < ii; i++) {
                    const page = this.pageCache[i];
                    if (!page) {
                      continue;
                    }
                    const cleanupSuccessful = page.cleanup();
                    if (!cleanupSuccessful) {
                      throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);
                    }
                  }
                  this.commonObjs.clear();
                  if (!keepLoadedFonts) {
                    this.fontLoader.clear();
                  }
                  this._hasJSActionsPromise = null;
                });
              }
              get loadingParams() {
                const params = this._params;
                return (0, _util.shadow)(this, "loadingParams", {
                  disableAutoFetch: params.disableAutoFetch,
                  disableFontFace: params.disableFontFace
                });
              }
            }
            class PDFObjects {
              constructor() {
                this._objs = /* @__PURE__ */ Object.create(null);
              }
              _ensureObj(objId) {
                if (this._objs[objId]) {
                  return this._objs[objId];
                }
                return this._objs[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null,
                  resolved: false
                };
              }
              get(objId, callback = null) {
                if (callback) {
                  this._ensureObj(objId).capability.promise.then(callback);
                  return null;
                }
                const obj = this._objs[objId];
                if (!obj || !obj.resolved) {
                  throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                }
                return obj.data;
              }
              has(objId) {
                const obj = this._objs[objId];
                return (obj == null ? void 0 : obj.resolved) || false;
              }
              resolve(objId, data) {
                const obj = this._ensureObj(objId);
                obj.resolved = true;
                obj.data = data;
                obj.capability.resolve(data);
              }
              clear() {
                this._objs = /* @__PURE__ */ Object.create(null);
              }
            }
            class RenderTask {
              constructor(internalRenderTask) {
                this._internalRenderTask = internalRenderTask;
                this.onContinue = null;
              }
              get promise() {
                return this._internalRenderTask.capability.promise;
              }
              cancel() {
                this._internalRenderTask.cancel();
              }
            }
            const InternalRenderTask = function InternalRenderTaskClosure() {
              const canvasInRendering = /* @__PURE__ */ new WeakSet();
              class InternalRenderTask2 {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  webGLContext,
                  useRequestAnimationFrame = false,
                  pdfBug = false
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this.webGLContext = webGLContext;
                  this._pdfBug = pdfBug;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                get completed() {
                  return this.capability.promise.catch(function() {
                  });
                }
                initializeGraphics({
                  transparency = false,
                  optionalContentConfig
                }) {
                  var _a;
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (canvasInRendering.has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    canvasInRendering.add(this._canvas);
                  }
                  if (this._pdfBug && ((_a = globalThis.StepperManager) == null ? void 0 : _a.enabled)) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
                cancel(error = null) {
                  this.running = false;
                  this.cancelled = true;
                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }
                  if (this._canvas) {
                    canvasInRendering.delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                }
                operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this._cancelBound);
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                  }
                }
                _next() {
                  return __async(this, null, function* () {
                    if (this.cancelled) {
                      return;
                    }
                    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                    if (this.operatorListIdx === this.operatorList.argsArray.length) {
                      this.running = false;
                      if (this.operatorList.lastChunk) {
                        this.gfx.endDrawing();
                        if (this._canvas) {
                          canvasInRendering.delete(this._canvas);
                        }
                        this.callback();
                      }
                    }
                  });
                }
              }
              return InternalRenderTask2;
            }();
            const version = "2.8.335";
            exports.version = version;
            const build = "228adbf67";
            exports.build = build;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FontLoader = exports2.FontFaceObject = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            class BaseFontLoader {
              constructor({
                docId,
                onUnsupportedFeature,
                ownerDocument = globalThis.document
              }) {
                if (this.constructor === BaseFontLoader) {
                  (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                }
                this.docId = docId;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this._document = ownerDocument;
                this.nativeFontFaces = [];
                this.styleElement = null;
              }
              addNativeFontFace(nativeFontFace) {
                this.nativeFontFaces.push(nativeFontFace);
                this._document.fonts.add(nativeFontFace);
              }
              insertRule(rule) {
                let styleElement = this.styleElement;
                if (!styleElement) {
                  styleElement = this.styleElement = this._document.createElement("style");
                  styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                  this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                }
                const styleSheet = styleElement.sheet;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
              }
              clear() {
                this.nativeFontFaces.forEach((nativeFontFace) => {
                  this._document.fonts.delete(nativeFontFace);
                });
                this.nativeFontFaces.length = 0;
                if (this.styleElement) {
                  this.styleElement.remove();
                  this.styleElement = null;
                }
              }
              bind(font) {
                return __async(this, null, function* () {
                  if (font.attached || font.missingFile) {
                    return;
                  }
                  font.attached = true;
                  if (this.isFontLoadingAPISupported) {
                    const nativeFontFace = font.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      try {
                        yield nativeFontFace.loaded;
                      } catch (ex) {
                        this._onUnsupportedFeature({
                          featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                        });
                        (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                        font.disableFontFace = true;
                        throw ex;
                      }
                    }
                    return;
                  }
                  const rule = font.createFontFaceRule();
                  if (rule) {
                    this.insertRule(rule);
                    if (this.isSyncFontLoadingSupported) {
                      return;
                    }
                    yield new Promise((resolve) => {
                      const request = this._queueLoadingCallback(resolve);
                      this._prepareFontLoadEvent([rule], [font], request);
                    });
                  }
                });
              }
              _queueLoadingCallback(callback) {
                (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
              }
              get isFontLoadingAPISupported() {
                var _a;
                return (0, _util2.shadow)(this, "isFontLoadingAPISupported", !!((_a = this._document) == null ? void 0 : _a.fonts));
              }
              get isSyncFontLoadingSupported() {
                (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
              }
              get _loadTestFont() {
                (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
              }
              _prepareFontLoadEvent(rules, fontsToLoad, request) {
                (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
              }
            }
            let FontLoader;
            exports2.FontLoader = FontLoader;
            {
              exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                constructor(params) {
                  super(params);
                  this.loadingContext = {
                    requests: [],
                    nextRequestId: 0
                  };
                  this.loadTestFontId = 0;
                }
                get isSyncFontLoadingSupported() {
                  let supported = false;
                  if (typeof navigator === "undefined") {
                    supported = true;
                  } else {
                    const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                    if ((m == null ? void 0 : m[1]) >= 14) {
                      supported = true;
                    }
                  }
                  return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                }
                _queueLoadingCallback(callback) {
                  function completeRequest() {
                    (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                    request.done = true;
                    while (context.requests.length > 0 && context.requests[0].done) {
                      const otherRequest = context.requests.shift();
                      setTimeout(otherRequest.callback, 0);
                    }
                  }
                  const context = this.loadingContext;
                  const request = {
                    id: `pdfjs-font-loading-${context.nextRequestId++}`,
                    done: false,
                    complete: completeRequest,
                    callback
                  };
                  context.requests.push(request);
                  return request;
                }
                get _loadTestFont() {
                  const getLoadTestFont = function() {
                    return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                  };
                  return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                }
                _prepareFontLoadEvent(rules, fonts, request) {
                  function int32(data2, offset) {
                    return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                  }
                  function spliceString(s, offset, remove, insert) {
                    const chunk1 = s.substring(0, offset);
                    const chunk2 = s.substring(offset + remove);
                    return chunk1 + insert + chunk2;
                  }
                  let i, ii;
                  const canvas = this._document.createElement("canvas");
                  canvas.width = 1;
                  canvas.height = 1;
                  const ctx = canvas.getContext("2d");
                  let called = 0;
                  function isFontReady(name, callback) {
                    called++;
                    if (called > 30) {
                      (0, _util2.warn)("Load test font never loaded.");
                      callback();
                      return;
                    }
                    ctx.font = "30px " + name;
                    ctx.fillText(".", 0, 20);
                    const imageData = ctx.getImageData(0, 0, 1, 1);
                    if (imageData.data[3] > 0) {
                      callback();
                      return;
                    }
                    setTimeout(isFontReady.bind(null, name, callback));
                  }
                  const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                  let data = this._loadTestFont;
                  const COMMENT_OFFSET = 976;
                  data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                  const CFF_CHECKSUM_OFFSET = 16;
                  const XXXX_VALUE = 1482184792;
                  let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                  for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                  }
                  if (i < loadTestFontId.length) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                  }
                  data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                  const url = `url(data:font/opentype;base64,${btoa(data)});`;
                  const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                  this.insertRule(rule);
                  const names = [];
                  for (i = 0, ii = fonts.length; i < ii; i++) {
                    names.push(fonts[i].loadedName);
                  }
                  names.push(loadTestFontId);
                  const div = this._document.createElement("div");
                  div.style.visibility = "hidden";
                  div.style.width = div.style.height = "10px";
                  div.style.position = "absolute";
                  div.style.top = div.style.left = "0px";
                  for (i = 0, ii = names.length; i < ii; ++i) {
                    const span = this._document.createElement("span");
                    span.textContent = "Hi";
                    span.style.fontFamily = names[i];
                    div.appendChild(span);
                  }
                  this._document.body.appendChild(div);
                  isFontReady(loadTestFontId, () => {
                    this._document.body.removeChild(div);
                    request.complete();
                  });
                }
              };
            }
            class FontFaceObject {
              constructor(translatedData, {
                isEvalSupported = true,
                disableFontFace = false,
                ignoreErrors = false,
                onUnsupportedFeature,
                fontRegistry = null
              }) {
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                for (const i in translatedData) {
                  this[i] = translatedData[i];
                }
                this.isEvalSupported = isEvalSupported !== false;
                this.disableFontFace = disableFontFace === true;
                this.ignoreErrors = ignoreErrors === true;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this.fontRegistry = fontRegistry;
              }
              createNativeFontFace() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                const nativeFontFace = new FontFace(this.loadedName, this.data, {});
                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this);
                }
                return nativeFontFace;
              }
              createFontFaceRule() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                const data = (0, _util2.bytesToString)(new Uint8Array(this.data));
                const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                const rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this, url);
                }
                return rule;
              }
              getPathGenerator(objs, character) {
                if (this.compiledGlyphs[character] !== void 0) {
                  return this.compiledGlyphs[character];
                }
                let cmds, current;
                try {
                  cmds = objs.get(this.loadedName + "_path_" + character);
                } catch (ex) {
                  if (!this.ignoreErrors) {
                    throw ex;
                  }
                  this._onUnsupportedFeature({
                    featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                  });
                  (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                  return this.compiledGlyphs[character] = function(c, size) {
                  };
                }
                if (this.isEvalSupported && _util2.IsEvalSupportedCached.value) {
                  let args, js = "";
                  for (let i = 0, ii = cmds.length; i < ii; i++) {
                    current = cmds[i];
                    if (current.args !== void 0) {
                      args = current.args.join(",");
                    } else {
                      args = "";
                    }
                    js += "c." + current.cmd + "(" + args + ");\n";
                  }
                  return this.compiledGlyphs[character] = new Function("c", "size", js);
                }
                return this.compiledGlyphs[character] = function(c, size) {
                  for (let i = 0, ii = cmds.length; i < ii; i++) {
                    current = cmds[i];
                    if (current.cmd === "scale") {
                      current.args = [size, -size];
                    }
                    c[current.cmd].apply(c, current.args);
                  }
                };
              }
            }
            exports2.FontFaceObject = FontFaceObject;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.NodeCMapReaderFactory = exports2.NodeCanvasFactory = void 0;
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _is_node2 = __w_pdfjs_require__2(4);
            var _util2 = __w_pdfjs_require__2(2);
            let NodeCanvasFactory = class {
              constructor() {
                (0, _util2.unreachable)("Not implemented: NodeCanvasFactory");
              }
            };
            exports2.NodeCanvasFactory = NodeCanvasFactory;
            let NodeCMapReaderFactory = class {
              constructor() {
                (0, _util2.unreachable)("Not implemented: NodeCMapReaderFactory");
              }
            };
            exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
            if (_is_node2.isNodeJS) {
              exports2.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils2.BaseCanvasFactory {
                create(width, height) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  const Canvas = require_canvas();
                  const canvas = Canvas.createCanvas(width, height);
                  return {
                    canvas,
                    context: canvas.getContext("2d")
                  };
                }
              };
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils2.BaseCMapReaderFactory {
                _fetchData(url, compressionType) {
                  return new Promise((resolve, reject) => {
                    const fs = require_fs();
                    fs.readFile(url, (error, data) => {
                      if (error || !data) {
                        reject(new Error(error));
                        return;
                      }
                      resolve({
                        cMapData: new Uint8Array(data),
                        compressionType
                      });
                    });
                  });
                }
              };
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationStorage = void 0;
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _util2 = __w_pdfjs_require__2(2);
            class AnnotationStorage {
              constructor() {
                this._storage = /* @__PURE__ */ new Map();
                this._modified = false;
                this.onSetModified = null;
                this.onResetModified = null;
              }
              getValue(key, defaultValue) {
                const obj = this._storage.get(key);
                return obj !== void 0 ? obj : defaultValue;
              }
              getOrCreateValue(key, defaultValue) {
                (0, _display_utils2.deprecated)("Use getValue instead.");
                if (this._storage.has(key)) {
                  return this._storage.get(key);
                }
                this._storage.set(key, defaultValue);
                return defaultValue;
              }
              setValue(key, value) {
                const obj = this._storage.get(key);
                let modified = false;
                if (obj !== void 0) {
                  for (const [entry, val] of Object.entries(value)) {
                    if (obj[entry] !== val) {
                      modified = true;
                      obj[entry] = val;
                    }
                  }
                } else {
                  this._storage.set(key, value);
                  modified = true;
                }
                if (modified) {
                  this._setModified();
                }
              }
              getAll() {
                return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
              }
              get size() {
                return this._storage.size;
              }
              _setModified() {
                if (!this._modified) {
                  this._modified = true;
                  if (typeof this.onSetModified === "function") {
                    this.onSetModified();
                  }
                }
              }
              resetModified() {
                if (this._modified) {
                  this._modified = false;
                  if (typeof this.onResetModified === "function") {
                    this.onResetModified();
                  }
                }
              }
              get serializable() {
                return this._storage.size > 0 ? this._storage : null;
              }
            }
            exports2.AnnotationStorage = AnnotationStorage;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.apiCompatibilityParams = void 0;
            var _is_node2 = __w_pdfjs_require__2(4);
            const compatibilityParams = /* @__PURE__ */ Object.create(null);
            {
              (function checkFontFace() {
                if (_is_node2.isNodeJS) {
                  compatibilityParams.disableFontFace = true;
                }
              })();
            }
            const apiCompatibilityParams = Object.freeze(compatibilityParams);
            exports2.apiCompatibilityParams = apiCompatibilityParams;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.CanvasGraphics = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _pattern_helper = __w_pdfjs_require__2(11);
            const MIN_FONT_SIZE = 16;
            const MAX_FONT_SIZE = 100;
            const MAX_GROUP_SIZE = 4096;
            const COMPILE_TYPE3_GLYPHS = true;
            const MAX_SIZE_TO_COMPILE = 1e3;
            const FULL_CHUNK_HEIGHT = 16;
            const LINEWIDTH_SCALE_FACTOR = 1.000001;
            function addContextCurrentTransform(ctx) {
              if (!ctx.mozCurrentTransform) {
                ctx._originalSave = ctx.save;
                ctx._originalRestore = ctx.restore;
                ctx._originalRotate = ctx.rotate;
                ctx._originalScale = ctx.scale;
                ctx._originalTranslate = ctx.translate;
                ctx._originalTransform = ctx.transform;
                ctx._originalSetTransform = ctx.setTransform;
                ctx._originalResetTransform = ctx.resetTransform;
                ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                ctx._transformStack = [];
                try {
                  const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
                  ctx._setLineWidth = desc.set;
                  ctx._getLineWidth = desc.get;
                  Object.defineProperty(ctx, "lineWidth", {
                    set: function setLineWidth(width) {
                      this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
                    },
                    get: function getLineWidth() {
                      return this._getLineWidth();
                    }
                  });
                } catch (_) {
                }
                Object.defineProperty(ctx, "mozCurrentTransform", {
                  get: function getCurrentTransform() {
                    return this._transformMatrix;
                  }
                });
                Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                  get: function getCurrentTransformInverse() {
                    const m = this._transformMatrix;
                    const a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
                    const ad_bc = a * d - b * c;
                    const bc_ad = b * c - a * d;
                    return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                  }
                });
                ctx.save = function ctxSave() {
                  const old = this._transformMatrix;
                  this._transformStack.push(old);
                  this._transformMatrix = old.slice(0, 6);
                  this._originalSave();
                };
                ctx.restore = function ctxRestore() {
                  const prev = this._transformStack.pop();
                  if (prev) {
                    this._transformMatrix = prev;
                    this._originalRestore();
                  }
                };
                ctx.translate = function ctxTranslate(x, y) {
                  const m = this._transformMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                  this._originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  const m = this._transformMatrix;
                  m[0] = m[0] * x;
                  m[1] = m[1] * x;
                  m[2] = m[2] * y;
                  m[3] = m[3] * y;
                  this._originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  const m = this._transformMatrix;
                  this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                  ctx._originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  this._transformMatrix = [a, b, c, d, e, f];
                  ctx._originalSetTransform(a, b, c, d, e, f);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  this._transformMatrix = [1, 0, 0, 1, 0, 0];
                  ctx._originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle) {
                  const cosValue = Math.cos(angle);
                  const sinValue = Math.sin(angle);
                  const m = this._transformMatrix;
                  this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                  this._originalRotate(angle);
                };
              }
            }
            const CachedCanvases = function CachedCanvasesClosure() {
              function CachedCanvases2(canvasFactory) {
                this.canvasFactory = canvasFactory;
                this.cache = /* @__PURE__ */ Object.create(null);
              }
              CachedCanvases2.prototype = {
                getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                  let canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                    canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  if (trackTransform) {
                    addContextCurrentTransform(canvasEntry.context);
                  }
                  return canvasEntry;
                },
                clear() {
                  for (const id in this.cache) {
                    const canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              };
              return CachedCanvases2;
            }();
            function compileType3Glyph(imgData) {
              const POINT_TO_PROCESS_LIMIT = 1e3;
              const width = imgData.width, height = imgData.height, width1 = width + 1;
              let i, ii, j, j0;
              const points = new Uint8Array(width1 * (height + 1));
              const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
              const lineSize = width + 7 & ~7, data0 = imgData.data;
              const data = new Uint8Array(lineSize * height);
              let pos = 0;
              for (i = 0, ii = data0.length; i < ii; i++) {
                const elem = data0[i];
                let mask = 128;
                while (mask > 0) {
                  data[pos++] = elem & mask ? 0 : 255;
                  mask >>= 1;
                }
              }
              let count = 0;
              pos = 0;
              if (data[pos] !== 0) {
                points[0] = 1;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j] = data[pos] ? 2 : 1;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j] = 2;
                ++count;
              }
              for (i = 1; i < height; i++) {
                pos = i * lineSize;
                j0 = i * width1;
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0] = data[pos] ? 1 : 8;
                  ++count;
                }
                let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                for (j = 1; j < width; j++) {
                  sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                  if (POINT_TYPES[sum]) {
                    points[j0 + j] = POINT_TYPES[sum];
                    ++count;
                  }
                  pos++;
                }
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0 + j] = data[pos] ? 2 : 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
              }
              pos = lineSize * (height - 1);
              j0 = i * width1;
              if (data[pos] !== 0) {
                points[j0] = 8;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j0 + j] = data[pos] ? 4 : 8;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j0 + j] = 4;
                ++count;
              }
              if (count > POINT_TO_PROCESS_LIMIT) {
                return null;
              }
              const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
              const outlines = [];
              for (i = 0; count && i <= height; i++) {
                let p = i * width1;
                const end = p + width;
                while (p < end && !points[p]) {
                  p++;
                }
                if (p === end) {
                  continue;
                }
                const coords = [p % width1, i];
                const p0 = p;
                let type = points[p];
                do {
                  const step = steps[type];
                  do {
                    p += step;
                  } while (!points[p]);
                  const pp = points[p];
                  if (pp !== 5 && pp !== 10) {
                    type = pp;
                    points[p] = 0;
                  } else {
                    type = pp & 51 * type >> 4;
                    points[p] &= type >> 2 | type << 2;
                  }
                  coords.push(p % width1);
                  coords.push(p / width1 | 0);
                  if (!points[p]) {
                    --count;
                  }
                } while (p0 !== p);
                outlines.push(coords);
                --i;
              }
              const drawOutline = function(c) {
                c.save();
                c.scale(1 / width, -1 / height);
                c.translate(0, -height);
                c.beginPath();
                for (let k = 0, kk = outlines.length; k < kk; k++) {
                  const o = outlines[k];
                  c.moveTo(o[0], o[1]);
                  for (let l = 2, ll = o.length; l < ll; l += 2) {
                    c.lineTo(o[l], o[l + 1]);
                  }
                }
                c.fill();
                c.beginPath();
                c.restore();
              };
              return drawOutline;
            }
            const CanvasExtraState = function CanvasExtraStateClosure() {
              function CanvasExtraState2() {
                this.alphaIsShape = false;
                this.fontSize = 0;
                this.fontSizeScale = 1;
                this.textMatrix = _util2.IDENTITY_MATRIX;
                this.textMatrixScale = 1;
                this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRenderingMode = _util2.TextRenderingMode.FILL;
                this.textRise = 0;
                this.fillColor = "#000000";
                this.strokeColor = "#000000";
                this.patternFill = false;
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.activeSMask = null;
                this.resumeSMaskCtx = null;
                this.transferMaps = null;
              }
              CanvasExtraState2.prototype = {
                clone: function CanvasExtraState_clone() {
                  return Object.create(this);
                },
                setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              };
              return CanvasExtraState2;
            }();
            const CanvasGraphics = function CanvasGraphicsClosure() {
              const EXECUTION_TIME = 15;
              const EXECUTION_STEPS = 10;
              function CanvasGraphics2(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {
                this.ctx = canvasCtx;
                this.current = new CanvasExtraState();
                this.stateStack = [];
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.res = null;
                this.xobjs = null;
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.canvasFactory = canvasFactory;
                this.webGLContext = webGLContext;
                this.imageLayer = imageLayer;
                this.groupStack = [];
                this.processingType3 = null;
                this.baseTransform = null;
                this.baseTransformStack = [];
                this.groupLevel = 0;
                this.smaskStack = [];
                this.smaskCounter = 0;
                this.tempSMask = null;
                this.contentVisible = true;
                this.markedContentStack = [];
                this.optionalContentConfig = optionalContentConfig;
                this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                if (canvasCtx) {
                  addContextCurrentTransform(canvasCtx);
                }
                this._cachedGetSinglePixelWidth = null;
              }
              function putBinaryImageData(ctx, imgData, transferMaps = null) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0, destPos;
                const src = imgData.data;
                const dest = chunkImgData.data;
                let i, j, thisChunkHeight, elemsInThisChunk;
                let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                if (transferMaps) {
                  switch (transferMaps.length) {
                    case 1:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[0];
                      transferMapBlue = transferMaps[0];
                      transferMapGray = transferMaps[0];
                      break;
                    case 4:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[1];
                      transferMapBlue = transferMaps[2];
                      transferMapGray = transferMaps[3];
                      break;
                  }
                }
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  const srcLength = src.byteLength;
                  const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  const dest32DataLength = dest32.length;
                  const fullSrcDiff = width + 7 >> 3;
                  let white = 4294967295;
                  let black = _util2.IsLittleEndianCached.value ? 4278190080 : 255;
                  if (transferMapGray) {
                    if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                      [white, black] = [black, white];
                    }
                  }
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      const srcDiff = srcLength - srcPos;
                      let k = 0;
                      const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      const kEndUnrolled = kEnd & ~7;
                      let mask = 0;
                      let srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    if (hasTransferMaps) {
                      for (let k = 0; k < destPos; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0;
                const src = imgData.data;
                const dest = chunkImgData.data;
                for (let i = 0; i < totalChunks; i++) {
                  const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  let destPos = 3;
                  for (let j = 0; j < thisChunkHeight; j++) {
                    let elem, mask = 0;
                    for (let k = 0; k < width; k++) {
                      if (!mask) {
                        elem = src[srcPos++];
                        mask = 128;
                      }
                      dest[destPos] = elem & mask ? 0 : 255;
                      destPos += 4;
                      mask >>= 1;
                    }
                  }
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (let i = 0, ii = properties.length; i < ii; i++) {
                  const property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx) {
                ctx.strokeStyle = "#000000";
                ctx.fillStyle = "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                const length = bytes.length;
                for (let i = 3; i < length; i += 4) {
                  const alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    const alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                const length = maskData.length;
                const scale = 1 / 255;
                for (let i = 3; i < length; i += 4) {
                  const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                const length = maskData.length;
                for (let i = 3; i < length; i += 4) {
                  const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
                const hasBackdrop = !!backdrop;
                const r0 = hasBackdrop ? backdrop[0] : 0;
                const g0 = hasBackdrop ? backdrop[1] : 0;
                const b0 = hasBackdrop ? backdrop[2] : 0;
                let composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                const PIXELS_TO_PROCESS = 1048576;
                const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (let row = 0; row < height; row += chunkSize) {
                  const chunkHeight = Math.min(chunkSize, height - row);
                  const maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                  const layerData = layerCtx.getImageData(0, row, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  maskCtx.putImageData(layerData, 0, row);
                }
              }
              function composeSMask(ctx, smask, layerCtx, webGLContext) {
                const mask = smask.canvas;
                const maskCtx = smask.context;
                ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
                const backdrop = smask.backdrop || null;
                if (!smask.transferMap && webGLContext.isEnabled) {
                  const composed = webGLContext.composeSMask({
                    layer: layerCtx.canvas,
                    mask,
                    properties: {
                      subtype: smask.subtype,
                      backdrop
                    }
                  });
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                  return;
                }
                genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
                ctx.drawImage(mask, 0, 0);
              }
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const NORMAL_CLIP = {};
              const EO_CLIP = {};
              CanvasGraphics2.prototype = {
                beginDrawing({
                  transform,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  const width = this.ctx.canvas.width;
                  const height = this.ctx.canvas.height;
                  this.ctx.save();
                  this.ctx.fillStyle = background || "rgb(255, 255, 255)";
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.restore();
                  if (transparency) {
                    const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx);
                  if (transform) {
                    this.ctx.transform.apply(this.ctx, transform);
                  }
                  this.ctx.transform.apply(this.ctx, viewport.transform);
                  this.baseTransform = this.ctx.mozCurrentTransform.slice();
                  this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);
                  if (this.imageLayer) {
                    this.imageLayer.beginLayout();
                  }
                },
                executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  let i = executionStartIdx || 0;
                  const argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  let steps = 0;
                  const commonObjs = this.commonObjs;
                  const objs = this.objs;
                  let fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      for (const depObjId of argsArray[i]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                },
                endDrawing: function CanvasGraphics_endDrawing() {
                  while (this.stateStack.length || this.current.activeSMask !== null) {
                    this.restore();
                  }
                  this.ctx.restore();
                  if (this.transparentCanvas) {
                    this.ctx = this.compositeCtx;
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.drawImage(this.transparentCanvas, 0, 0);
                    this.ctx.restore();
                    this.transparentCanvas = null;
                  }
                  this.cachedCanvases.clear();
                  this.webGLContext.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                },
                setLineWidth: function CanvasGraphics_setLineWidth(width) {
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                },
                setLineCap: function CanvasGraphics_setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                },
                setLineJoin: function CanvasGraphics_setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                },
                setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                },
                setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                  const ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                },
                setRenderingIntent(intent) {
                },
                setFlatness(flatness) {
                },
                setGState: function CanvasGraphics_setGState(states) {
                  for (let i = 0, ii = states.length; i < ii; i++) {
                    const state = states[i];
                    const key = state[0];
                    const value = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        if (this.current.activeSMask) {
                          if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                            this.suspendSMaskGroup();
                          } else {
                            this.endSMaskGroup();
                          }
                        }
                        this.current.activeSMask = value ? this.tempSMask : null;
                        if (this.current.activeSMask) {
                          this.beginSMaskGroup();
                        }
                        this.tempSMask = null;
                        break;
                      case "TR":
                        this.current.transferMaps = value;
                    }
                  }
                },
                beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                  const activeSMask = this.current.activeSMask;
                  const drawnWidth = activeSMask.canvas.width;
                  const drawnHeight = activeSMask.canvas.height;
                  const cacheId = "smaskGroupAt" + this.groupLevel;
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  const currentCtx = this.ctx;
                  const currentTransform = currentCtx.mozCurrentTransform;
                  this.ctx.save();
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                  groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  const groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  this.ctx.save();
                  copyCtxState(groupCtx, this.ctx);
                  this.current.resumeSMaskCtx = groupCtx;
                  const deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                  groupCtx.save();
                  groupCtx.setTransform(1, 0, 0, 1, 0, 0);
                  groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
                  groupCtx.restore();
                },
                resumeSMaskGroup: function CanvasGraphics_resumeSMaskGroup() {
                  const groupCtx = this.current.resumeSMaskCtx;
                  const currentCtx = this.ctx;
                  this.ctx = groupCtx;
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  const groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  copyCtxState(groupCtx, this.ctx);
                  const deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                },
                save: function CanvasGraphics_save() {
                  this.ctx.save();
                  const old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                  this.current.resumeSMaskCtx = null;
                },
                restore: function CanvasGraphics_restore() {
                  if (this.current.resumeSMaskCtx) {
                    this.resumeSMaskGroup();
                  }
                  if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                    this.endSMaskGroup();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    this.ctx.restore();
                    this.pendingClip = null;
                    this._cachedGetSinglePixelWidth = null;
                  } else {
                    this.current.activeSMask = null;
                  }
                },
                transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
                  this.ctx.transform(a, b, c, d, e, f);
                  this._cachedGetSinglePixelWidth = null;
                },
                constructPath: function CanvasGraphics_constructPath(ops, args) {
                  const ctx = this.ctx;
                  const current = this.current;
                  let x = current.x, y = current.y;
                  for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width = args[j++];
                        const height = args[j++];
                        const xw = x + width;
                        const yh = y + height;
                        ctx.moveTo(x, y);
                        if (width === 0 || height === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x, yh);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        break;
                      case _util2.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  current.setCurrentPoint(x, y);
                },
                closePath: function CanvasGraphics_closePath() {
                  this.ctx.closePath();
                },
                stroke: function CanvasGraphics_stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (typeof strokeColor === "object" && (strokeColor == null ? void 0 : strokeColor.getPattern)) {
                      ctx.save();
                      const transform = ctx.mozCurrentTransform;
                      const scale = _util2.Util.singularValueDecompose2dScale(transform)[0];
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                      const lineWidth = this.getSinglePixelWidth();
                      const scaledLineWidth = this.current.lineWidth * scale;
                      if (lineWidth < 0 && -lineWidth >= scaledLineWidth) {
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                      } else {
                        ctx.lineWidth = Math.max(lineWidth, scaledLineWidth);
                      }
                      ctx.stroke();
                      ctx.restore();
                    } else {
                      const lineWidth = this.getSinglePixelWidth();
                      if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {
                        ctx.save();
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                        ctx.stroke();
                        ctx.restore();
                      } else {
                        ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
                        ctx.stroke();
                      }
                    }
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                },
                closeStroke: function CanvasGraphics_closeStroke() {
                  this.closePath();
                  this.stroke();
                },
                fill: function CanvasGraphics_fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  let needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    if (this.baseTransform) {
                      ctx.setTransform.apply(ctx, this.baseTransform);
                    }
                    ctx.fillStyle = fillColor.getPattern(ctx, this);
                    needRestore = true;
                  }
                  if (this.contentVisible) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                },
                eoFill: function CanvasGraphics_eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                },
                fillStroke: function CanvasGraphics_fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                },
                eoFillStroke: function CanvasGraphics_eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                },
                closeFillStroke: function CanvasGraphics_closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                },
                closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                },
                endPath: function CanvasGraphics_endPath() {
                  this.consumePath();
                },
                clip: function CanvasGraphics_clip() {
                  this.pendingClip = NORMAL_CLIP;
                },
                eoClip: function CanvasGraphics_eoClip() {
                  this.pendingClip = EO_CLIP;
                },
                beginText: function CanvasGraphics_beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                endText: function CanvasGraphics_endText() {
                  const paths = this.pendingTextPaths;
                  const ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (let i = 0; i < paths.length; i++) {
                    const path = paths[i];
                    ctx.setTransform.apply(ctx, path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                },
                setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                },
                setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                },
                setHScale: function CanvasGraphics_setHScale(scale) {
                  this.current.textHScale = scale / 100;
                },
                setLeading: function CanvasGraphics_setLeading(leading) {
                  this.current.leading = -leading;
                },
                setFont: function CanvasGraphics_setFont(fontRefName, size) {
                  const fontObj = this.commonObjs.get(fontRefName);
                  const current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  const name = fontObj.loadedName || "sans-serif";
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  const typeface = `"${name}", ${fontObj.fallbackName}`;
                  let browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                },
                setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                },
                setTextRise: function CanvasGraphics_setTextRise(rise) {
                  this.current.textRise = rise;
                },
                moveText: function CanvasGraphics_moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                },
                setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                },
                setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
                  this.current.textMatrix = [a, b, c, d, e, f];
                  this.current.textMatrixScale = Math.hypot(a, b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                nextLine: function CanvasGraphics_nextLine() {
                  this.moveText(0, this.current.leading);
                },
                paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const textRenderingMode = current.textRenderingMode;
                  const fontSize = current.fontSize / current.fontSizeScale;
                  const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && !font.missingFile;
                  let addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform.apply(ctx, patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (resetLineWidthToOne) {
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                      }
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (resetLineWidthToOne) {
                        ctx.save();
                        ctx.moveTo(x, y);
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                        ctx.strokeText(character, 0, 0);
                        ctx.restore();
                      } else {
                        ctx.strokeText(character, x, y);
                      }
                    }
                  }
                  if (isAddToPathSet) {
                    const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: ctx.mozCurrentTransform,
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                },
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  const data = ctx.getImageData(0, 0, 10, 10).data;
                  let enabled = false;
                  for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                },
                showText: function CanvasGraphics_showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  const ctx = this.ctx;
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const glyphsLength = glyphs.length;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this);
                    patternTransform = ctx.mozCurrentTransform;
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  let lineWidth = current.lineWidth;
                  let resetLineWidthToOne = false;
                  const scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      this._cachedGetSinglePixelWidth = null;
                      lineWidth = this.getSinglePixelWidth();
                      resetLineWidthToOne = lineWidth < 0;
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  let x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    const glyph = glyphs[i];
                    if ((0, _util2.isNum)(glyph)) {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    let restoreNeeded = false;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    const accent = glyph.accent;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        const characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);
                        if (accent) {
                          const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                          const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
                        }
                      }
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                },
                showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  const fontDirection = current.fontDirection;
                  const spacingDir = font.vertical ? 1 : -1;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const textHScale = current.textHScale * fontDirection;
                  const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  const glyphsLength = glyphs.length;
                  const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  let i, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if ((0, _util2.isNum)(glyph)) {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform.apply(ctx, fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                },
                setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
                },
                setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.clip();
                  this.endPath();
                },
                getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                  let pattern;
                  if (IR[0] === "TilingPattern") {
                    const color = IR[1];
                    const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                    const canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new CanvasGraphics2(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
                  }
                  return pattern;
                },
                setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                },
                setFillColorN: function CanvasGraphics_setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                },
                setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
                  const color = _util2.Util.makeHexColor(r, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                },
                setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
                  const color = _util2.Util.makeHexColor(r, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                },
                shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  this.save();
                  const pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
                  ctx.fillStyle = pattern.getPattern(ctx, this, true);
                  const inv = ctx.mozCurrentTransformInverse;
                  if (inv) {
                    const canvas = ctx.canvas;
                    const width = canvas.width;
                    const height = canvas.height;
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height], inv);
                    const ul = _util2.Util.applyTransform([width, 0], inv);
                    const ur = _util2.Util.applyTransform([width, height], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.restore();
                },
                beginInlineImage: function CanvasGraphics_beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                },
                beginImageData: function CanvasGraphics_beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                },
                paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform.apply(this, matrix);
                  }
                  this.baseTransform = this.ctx.mozCurrentTransform;
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                },
                paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                },
                beginGroup: function CanvasGraphics_beginGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  const currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  const currentTransform = currentCtx.mozCurrentTransform;
                  if (group.matrix) {
                    currentCtx.transform.apply(currentCtx, group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                  const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  const offsetX = Math.floor(bounds[0]);
                  const offsetY = Math.floor(bounds[1]);
                  let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  let scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  let cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                  this.current.activeSMask = null;
                },
                endGroup: function CanvasGraphics_endGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  const groupCtx = this.ctx;
                  this.ctx = this.groupStack.pop();
                  if (this.ctx.imageSmoothingEnabled !== void 0) {
                    this.ctx.imageSmoothingEnabled = false;
                  } else {
                    this.ctx.mozImageSmoothingEnabled = false;
                  }
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                  } else {
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                  }
                  this.restore();
                },
                beginAnnotations: function CanvasGraphics_beginAnnotations() {
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                  }
                },
                endAnnotations: function CanvasGraphics_endAnnotations() {
                  this.restore();
                },
                beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                  this.save();
                  resetCtxToDefault(this.ctx);
                  this.current = new CanvasExtraState();
                  if (Array.isArray(rect) && rect.length === 4) {
                    const width = rect[2] - rect[0];
                    const height = rect[3] - rect[1];
                    this.ctx.rect(rect[0], rect[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                  this.transform.apply(this, transform);
                  this.transform.apply(this, matrix);
                },
                endAnnotation: function CanvasGraphics_endAnnotation() {
                  this.restore();
                },
                paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const width = img.width, height = img.height;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const glyph = this.processingType3;
                  if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === void 0) {
                    if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                      glyph.compiled = compileType3Glyph({
                        data: img.data,
                        width,
                        height
                      });
                    } else {
                      glyph.compiled = null;
                    }
                  }
                  if (glyph == null ? void 0 : glyph.compiled) {
                    glyph.compiled(ctx);
                    return;
                  }
                  const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  const maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, img);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  this.paintInlineImageXObject(maskCanvas.canvas);
                },
                paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  const maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, imgData);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  const ctx = this.ctx;
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    ctx.save();
                    ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  for (let i = 0, ii = images.length; i < ii; i++) {
                    const image = images[i];
                    const width = image.width, height = image.height;
                    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    const maskCtx = maskCanvas.context;
                    maskCtx.save();
                    putBinaryImageMask(maskCtx, image);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform.apply(ctx, image.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                },
                paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const map = [];
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                },
                paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width, -1 / height);
                  const currentTransform = ctx.mozCurrentTransformInverse;
                  let widthScale = Math.max(Math.hypot(currentTransform[0], currentTransform[1]), 1);
                  let heightScale = Math.max(Math.hypot(currentTransform[2], currentTransform[3]), 1);
                  let imgToPaint, tmpCanvas, tmpCtx;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  let paintWidth = width, paintHeight = height;
                  let tmpCanvasId = "prescale1";
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    let newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    imgToPaint = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
                  if (this.imageLayer) {
                    const position = this.getCanvasPosition(0, -height);
                    this.imageLayer.appendImage({
                      imgData,
                      left: position[0],
                      top: position[1],
                      width: width / currentTransform[0],
                      height: height / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const w = imgData.width;
                  const h = imgData.height;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  const tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                  for (let i = 0, ii = map.length; i < ii; i++) {
                    const entry = map[i];
                    ctx.save();
                    ctx.transform.apply(ctx, entry.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      const position = this.getCanvasPosition(entry.x, entry.y);
                      this.imageLayer.appendImage({
                        imgData,
                        left: position[0],
                        top: position[1],
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                },
                paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                },
                markPoint: function CanvasGraphics_markPoint(tag) {
                },
                markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
                },
                beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
                  this.markedContentStack.push({
                    visible: true
                  });
                },
                beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
                  if (tag === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                },
                endMarkedContent: function CanvasGraphics_endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                },
                beginCompat: function CanvasGraphics_beginCompat() {
                },
                endCompat: function CanvasGraphics_endCompat() {
                },
                consumePath: function CanvasGraphics_consumePath() {
                  const ctx = this.ctx;
                  if (this.pendingClip) {
                    if (this.pendingClip === EO_CLIP) {
                      ctx.clip("evenodd");
                    } else {
                      ctx.clip();
                    }
                    this.pendingClip = null;
                  }
                  ctx.beginPath();
                },
                getSinglePixelWidth() {
                  if (this._cachedGetSinglePixelWidth === null) {
                    const m = this.ctx.mozCurrentTransform;
                    const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                    const sqNorm1 = __pow(m[0], 2) + __pow(m[2], 2);
                    const sqNorm2 = __pow(m[1], 2) + __pow(m[3], 2);
                    const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;
                    if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
                      this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
                    } else if (absDet > Number.EPSILON) {
                      this._cachedGetSinglePixelWidth = pixelHeight;
                    } else {
                      this._cachedGetSinglePixelWidth = 1;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                },
                getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
                  const transform = this.ctx.mozCurrentTransform;
                  return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                },
                isContentVisible: function CanvasGraphics_isContentVisible() {
                  for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
                    if (!this.markedContentStack[i].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              for (const op in _util2.OPS) {
                CanvasGraphics2.prototype[_util2.OPS[op]] = CanvasGraphics2.prototype[op];
              }
              return CanvasGraphics2;
            }();
            exports2.CanvasGraphics = CanvasGraphics;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getShadingPatternFromIR = getShadingPatternFromIR;
            exports2.TilingPattern = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            const ShadingIRs = {};
            function applyBoundingBox(ctx, bbox) {
              if (!bbox || typeof Path2D === "undefined") {
                return;
              }
              const width = bbox[2] - bbox[0];
              const height = bbox[3] - bbox[1];
              const region = new Path2D();
              region.rect(bbox[0], bbox[1], width, height);
              ctx.clip(region);
            }
            ShadingIRs.RadialAxial = {
              fromIR: function RadialAxial_fromIR(raw) {
                const type = raw[1];
                const bbox = raw[2];
                const colorStops = raw[3];
                const p0 = raw[4];
                const p1 = raw[5];
                const r0 = raw[6];
                const r1 = raw[7];
                return {
                  getPattern: function RadialAxial_getPattern(ctx) {
                    applyBoundingBox(ctx, bbox);
                    let grad;
                    if (type === "axial") {
                      grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                    } else if (type === "radial") {
                      grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                    }
                    for (let i = 0, ii = colorStops.length; i < ii; ++i) {
                      const c = colorStops[i];
                      grad.addColorStop(c[0], c[1]);
                    }
                    return grad;
                  }
                };
              }
            };
            const createMeshCanvas = function createMeshCanvasClosure() {
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                const coords = context.coords, colors = context.colors;
                const bytes = data.data, rowSize = data.width * 4;
                let tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                const x1 = (coords[p1] + context.offsetX) * context.scaleX;
                const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                const x2 = (coords[p2] + context.offsetX) * context.scaleX;
                const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                const x3 = (coords[p3] + context.offsetX) * context.scaleX;
                const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                const minY = Math.round(y1), maxY = Math.round(y3);
                let xa, car, cag, cab;
                let xb, cbr, cbg, cbb;
                for (let y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    let k2;
                    if (y < y1) {
                      k2 = 0;
                    } else if (y1 === y2) {
                      k2 = 1;
                    } else {
                      k2 = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k2;
                    car = c1r - (c1r - c2r) * k2;
                    cag = c1g - (c1g - c2g) * k2;
                    cab = c1b - (c1b - c2b) * k2;
                  } else {
                    let k2;
                    if (y > y3) {
                      k2 = 1;
                    } else if (y2 === y3) {
                      k2 = 0;
                    } else {
                      k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k2;
                    car = c2r - (c2r - c3r) * k2;
                    cag = c2g - (c2g - c3g) * k2;
                    cab = c2b - (c2b - c3b) * k2;
                  }
                  let k;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  const x1_ = Math.round(Math.min(xa, xb));
                  const x2_ = Math.round(Math.max(xa, xb));
                  let j = rowSize * y + x1_ * 4;
                  for (let x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                const ps = figure.coords;
                const cs = figure.colors;
                let i, ii;
                switch (figure.type) {
                  case "lattice":
                    const verticesPerRow = figure.verticesPerRow;
                    const rows = Math.floor(ps.length / verticesPerRow) - 1;
                    const cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      let q = i * verticesPerRow;
                      for (let j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              function createMeshCanvas2(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
                const EXPECTED_SCALE = 1.1;
                const MAX_PATTERN_SIZE = 3e3;
                const BORDER_SIZE = 2;
                const offsetX = Math.floor(bounds[0]);
                const offsetY = Math.floor(bounds[1]);
                const boundsWidth = Math.ceil(bounds[2]) - offsetX;
                const boundsHeight = Math.ceil(bounds[3]) - offsetY;
                const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                const scaleX = boundsWidth / width;
                const scaleY = boundsHeight / height;
                const context = {
                  coords,
                  colors,
                  offsetX: -offsetX,
                  offsetY: -offsetY,
                  scaleX: 1 / scaleX,
                  scaleY: 1 / scaleY
                };
                const paddedWidth = width + BORDER_SIZE * 2;
                const paddedHeight = height + BORDER_SIZE * 2;
                let canvas, tmpCanvas, i, ii;
                if (webGLContext.isEnabled) {
                  canvas = webGLContext.drawFigures({
                    width,
                    height,
                    backgroundColor,
                    figures,
                    context
                  });
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                } else {
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  const tmpCtx = tmpCanvas.context;
                  const data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    const bytes = data.data;
                    for (i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (i = 0; i < figures.length; i++) {
                    drawFigure(data, figures[i], context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                }
                return {
                  canvas,
                  offsetX: offsetX - BORDER_SIZE * scaleX,
                  offsetY: offsetY - BORDER_SIZE * scaleY,
                  scaleX,
                  scaleY
                };
              }
              return createMeshCanvas2;
            }();
            ShadingIRs.Mesh = {
              fromIR: function Mesh_fromIR(raw) {
                const coords = raw[2];
                const colors = raw[3];
                const figures = raw[4];
                const bounds = raw[5];
                const matrix = raw[6];
                const bbox = raw[7];
                const background = raw[8];
                return {
                  getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                    applyBoundingBox(ctx, bbox);
                    let scale;
                    if (shadingFill) {
                      scale = _util2.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (matrix) {
                        const matrixScale = _util2.Util.singularValueDecompose2dScale(matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    const temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);
                    if (!shadingFill) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (matrix) {
                        ctx.transform.apply(ctx, matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  }
                };
              }
            };
            ShadingIRs.Dummy = {
              fromIR: function Dummy_fromIR() {
                return {
                  getPattern: function Dummy_fromIR_getPattern() {
                    return "hotpink";
                  }
                };
              }
            };
            function getShadingPatternFromIR(raw) {
              const shadingIR = ShadingIRs[raw[0]];
              if (!shadingIR) {
                throw new Error(`Unknown IR type: ${raw[0]}`);
              }
              return shadingIR.fromIR(raw);
            }
            const TilingPattern = function TilingPatternClosure() {
              const PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              const MAX_PATTERN_SIZE = 3e3;
              function TilingPattern2(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                this.operatorList = IR[2];
                this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                this.bbox = IR[4];
                this.xstep = IR[5];
                this.ystep = IR[6];
                this.paintType = IR[7];
                this.tilingType = IR[8];
                this.color = color;
                this.canvasGraphicsFactory = canvasGraphicsFactory;
                this.baseTransform = baseTransform;
                this.ctx = ctx;
              }
              TilingPattern2.prototype = {
                createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                  const operatorList = this.operatorList;
                  const bbox = this.bbox;
                  const xstep = this.xstep;
                  const ystep = this.ystep;
                  const paintType = this.paintType;
                  const tilingType = this.tilingType;
                  const color = this.color;
                  const canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  const tmpCtx = tmpCanvas.context;
                  const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  graphics.transform(1, 0, 0, 1, -x0, -y0);
                  this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                  graphics.executeOperatorList(operatorList);
                  this.ctx.transform(1, 0, 0, 1, x0, y0);
                  this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
                  return tmpCanvas.canvas;
                },
                getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
                  step = Math.abs(step);
                  const maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
                  let size = Math.ceil(step * scale);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale = size / step;
                  }
                  return {
                    scale,
                    size
                  };
                },
                clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    const bboxWidth = x1 - x0;
                    const bboxHeight = y1 - y0;
                    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                    graphics.clip();
                    graphics.endPath();
                  }
                },
                setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      const ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      const cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                },
                getPattern: function TilingPattern_getPattern(ctx, owner) {
                  ctx = this.ctx;
                  ctx.setTransform.apply(ctx, this.baseTransform);
                  ctx.transform.apply(ctx, this.matrix);
                  const temporaryPatternCanvas = this.createPatternCanvas(owner);
                  return ctx.createPattern(temporaryPatternCanvas, "repeat");
                }
              };
              return TilingPattern2;
            }();
            exports2.TilingPattern = TilingPattern;
          },
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.GlobalWorkerOptions = void 0;
            const GlobalWorkerOptions2 = /* @__PURE__ */ Object.create(null);
            exports2.GlobalWorkerOptions = GlobalWorkerOptions2;
            GlobalWorkerOptions2.workerPort = GlobalWorkerOptions2.workerPort === void 0 ? null : GlobalWorkerOptions2.workerPort;
            GlobalWorkerOptions2.workerSrc = GlobalWorkerOptions2.workerSrc === void 0 ? "" : GlobalWorkerOptions2.workerSrc;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.MessageHandler = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            const CallbackKind = {
              UNKNOWN: 0,
              DATA: 1,
              ERROR: 2
            };
            const StreamKind = {
              UNKNOWN: 0,
              CANCEL: 1,
              CANCEL_COMPLETE: 2,
              CLOSE: 3,
              ENQUEUE: 4,
              ERROR: 5,
              PULL: 6,
              PULL_COMPLETE: 7,
              START_COMPLETE: 8
            };
            function wrapReason(reason) {
              if (typeof reason !== "object" || reason === null) {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util2.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util2.MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new _util2.UnexpectedResponseException(reason.message, reason.status);
                case "UnknownErrorException":
                  return new _util2.UnknownErrorException(reason.message, reason.details);
                default:
                  return new _util2.UnknownErrorException(reason.message, reason.toString());
              }
            }
            class MessageHandler {
              constructor(sourceName, targetName, comObj) {
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackId = 1;
                this.streamId = 1;
                this.postMessageTransfers = true;
                this.streamSinks = /* @__PURE__ */ Object.create(null);
                this.streamControllers = /* @__PURE__ */ Object.create(null);
                this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                this.actionHandler = /* @__PURE__ */ Object.create(null);
                this._onComObjOnMessage = (event) => {
                  const data = event.data;
                  if (data.targetName !== this.sourceName) {
                    return;
                  }
                  if (data.stream) {
                    this._processStreamMessage(data);
                    return;
                  }
                  if (data.callback) {
                    const callbackId = data.callbackId;
                    const capability = this.callbackCapabilities[callbackId];
                    if (!capability) {
                      throw new Error(`Cannot resolve callback ${callbackId}`);
                    }
                    delete this.callbackCapabilities[callbackId];
                    if (data.callback === CallbackKind.DATA) {
                      capability.resolve(data.data);
                    } else if (data.callback === CallbackKind.ERROR) {
                      capability.reject(wrapReason(data.reason));
                    } else {
                      throw new Error("Unexpected callback case");
                    }
                    return;
                  }
                  const action = this.actionHandler[data.action];
                  if (!action) {
                    throw new Error(`Unknown action from worker: ${data.action}`);
                  }
                  if (data.callbackId) {
                    const cbSourceName = this.sourceName;
                    const cbTargetName = data.sourceName;
                    new Promise(function(resolve) {
                      resolve(action(data.data));
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: cbSourceName,
                        targetName: cbTargetName,
                        callback: CallbackKind.DATA,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: cbSourceName,
                        targetName: cbTargetName,
                        callback: CallbackKind.ERROR,
                        callbackId: data.callbackId,
                        reason: wrapReason(reason)
                      });
                    });
                    return;
                  }
                  if (data.streamId) {
                    this._createStreamSink(data);
                    return;
                  }
                  action(data.data);
                };
                comObj.addEventListener("message", this._onComObjOnMessage);
              }
              on(actionName, handler) {
                const ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error(`There is already an actionName called "${actionName}"`);
                }
                ah[actionName] = handler;
              }
              send(actionName, data, transfers) {
                this._postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                }, transfers);
              }
              sendWithPromise(actionName, data, transfers) {
                const callbackId = this.callbackId++;
                const capability = (0, _util2.createPromiseCapability)();
                this.callbackCapabilities[callbackId] = capability;
                try {
                  this._postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    callbackId,
                    data
                  }, transfers);
                } catch (ex) {
                  capability.reject(ex);
                }
                return capability.promise;
              }
              sendWithStream(actionName, data, queueingStrategy, transfers) {
                const streamId = this.streamId++;
                const sourceName = this.sourceName;
                const targetName = this.targetName;
                const comObj = this.comObj;
                return new ReadableStream({
                  start: (controller) => {
                    const startCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      pullCall: null,
                      cancelCall: null,
                      isClosed: false
                    };
                    this._postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    }, transfers);
                    return startCapability.promise;
                  },
                  pull: (controller) => {
                    const pullCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].pullCall = pullCapability;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL,
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: (reason) => {
                    (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                    const cancelCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].cancelCall = cancelCapability;
                    this.streamControllers[streamId].isClosed = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CANCEL,
                      streamId,
                      reason: wrapReason(reason)
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              }
              _createStreamSink(data) {
                const self2 = this;
                const action = this.actionHandler[data.action];
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                const streamSink = {
                  enqueue(chunk, size = 1, transfers) {
                    if (this.isCancelled) {
                      return;
                    }
                    const lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = (0, _util2.createPromiseCapability)();
                      this.ready = this.sinkCapability.promise;
                    }
                    self2._postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId,
                      chunk
                    }, transfers);
                  },
                  close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CLOSE,
                      streamId
                    });
                    delete self2.streamSinks[streamId];
                  },
                  error(reason) {
                    (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ERROR,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  },
                  sinkCapability: (0, _util2.createPromiseCapability)(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function(resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function() {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function(reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
              }
              _processStreamMessage(data) {
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].startCall.resolve();
                    } else {
                      this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].pullCall.resolve();
                    } else {
                      this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL:
                    if (!this.streamSinks[streamId]) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[streamId].desiredSize = data.desiredSize;
                    const {
                      onPull
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onPull && onPull());
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    break;
                  case StreamKind.ENQUEUE:
                    (0, _util2.assert)(this.streamControllers[streamId], "enqueue should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].controller.enqueue(data.chunk);
                    break;
                  case StreamKind.CLOSE:
                    (0, _util2.assert)(this.streamControllers[streamId], "close should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].isClosed = true;
                    this.streamControllers[streamId].controller.close();
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.ERROR:
                    (0, _util2.assert)(this.streamControllers[streamId], "error should have stream controller");
                    this.streamControllers[streamId].controller.error(wrapReason(data.reason));
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].cancelCall.resolve();
                    } else {
                      this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                    }
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL:
                    if (!this.streamSinks[streamId]) {
                      break;
                    }
                    const {
                      onCancel
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onCancel && onCancel(wrapReason(data.reason)));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[streamId].isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              }
              _deleteStreamController(streamId) {
                return __async(this, null, function* () {
                  yield Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
                    return capability && capability.promise;
                  }));
                  delete this.streamControllers[streamId];
                });
              }
              _postMessage(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              }
              destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            }
            exports2.MessageHandler = MessageHandler;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Metadata = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            class Metadata {
              constructor({
                parsedData,
                rawData
              }) {
                this._metadataMap = parsedData;
                this._data = rawData;
              }
              getRaw() {
                return this._data;
              }
              get(name) {
                var _a;
                return (_a = this._metadataMap.get(name)) != null ? _a : null;
              }
              getAll() {
                return (0, _util2.objectFromMap)(this._metadataMap);
              }
              has(name) {
                return this._metadataMap.has(name);
              }
            }
            exports2.Metadata = Metadata;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.OptionalContentConfig = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            class OptionalContentGroup {
              constructor(name, intent) {
                this.visible = true;
                this.name = name;
                this.intent = intent;
              }
            }
            class OptionalContentConfig {
              constructor(data) {
                this.name = null;
                this.creator = null;
                this._order = null;
                this._groups = /* @__PURE__ */ new Map();
                if (data === null) {
                  return;
                }
                this.name = data.name;
                this.creator = data.creator;
                this._order = data.order;
                for (const group of data.groups) {
                  this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
                }
                if (data.baseState === "OFF") {
                  for (const group of this._groups) {
                    group.visible = false;
                  }
                }
                for (const on of data.on) {
                  this._groups.get(on).visible = true;
                }
                for (const off of data.off) {
                  this._groups.get(off).visible = false;
                }
              }
              isVisible(group) {
                if (group.type === "OCG") {
                  if (!this._groups.has(group.id)) {
                    (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                    return true;
                  }
                  return this._groups.get(group.id).visible;
                } else if (group.type === "OCMD") {
                  if (group.expression) {
                    (0, _util2.warn)("Visibility expression not supported yet.");
                  }
                  if (!group.policy || group.policy === "AnyOn") {
                    for (const id of group.ids) {
                      if (!this._groups.has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (this._groups.get(id).visible) {
                        return true;
                      }
                    }
                    return false;
                  } else if (group.policy === "AllOn") {
                    for (const id of group.ids) {
                      if (!this._groups.has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (!this._groups.get(id).visible) {
                        return false;
                      }
                    }
                    return true;
                  } else if (group.policy === "AnyOff") {
                    for (const id of group.ids) {
                      if (!this._groups.has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (!this._groups.get(id).visible) {
                        return true;
                      }
                    }
                    return false;
                  } else if (group.policy === "AllOff") {
                    for (const id of group.ids) {
                      if (!this._groups.has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (this._groups.get(id).visible) {
                        return false;
                      }
                    }
                    return true;
                  }
                  (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                  return true;
                }
                (0, _util2.warn)(`Unknown group type ${group.type}.`);
                return true;
              }
              setVisibility(id, visible = true) {
                if (!this._groups.has(id)) {
                  (0, _util2.warn)(`Optional content group not found: ${id}`);
                  return;
                }
                this._groups.get(id).visible = !!visible;
              }
              getOrder() {
                if (!this._groups.size) {
                  return null;
                }
                if (this._order) {
                  return this._order.slice();
                }
                return Array.from(this._groups.keys());
              }
              getGroups() {
                return this._groups.size > 0 ? (0, _util2.objectFromMap)(this._groups) : null;
              }
              getGroup(id) {
                return this._groups.get(id) || null;
              }
            }
            exports2.OptionalContentConfig = OptionalContentConfig;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFDataTransportStream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _display_utils2 = __w_pdfjs_require__2(1);
            class PDFDataTransportStream {
              constructor(params, pdfDataRangeTransport) {
                (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                this._queuedChunks = [];
                this._progressiveDone = params.progressiveDone || false;
                this._contentDispositionFilename = params.contentDispositionFilename || null;
                const initialData = params.initialData;
                if ((initialData == null ? void 0 : initialData.length) > 0) {
                  const buffer = new Uint8Array(initialData).buffer;
                  this._queuedChunks.push(buffer);
                }
                this._pdfDataRangeTransport = pdfDataRangeTransport;
                this._isStreamingSupported = !params.disableStream;
                this._isRangeSupported = !params.disableRange;
                this._contentLength = params.length;
                this._fullRequestReader = null;
                this._rangeReaders = [];
                this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                  this._onReceiveData({
                    begin,
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                  this._onProgress({
                    loaded,
                    total
                  });
                });
                this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                  this._onReceiveData({
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                  this._onProgressiveDone();
                });
                this._pdfDataRangeTransport.transportReady();
              }
              _onReceiveData(args) {
                const buffer = new Uint8Array(args.chunk).buffer;
                if (args.begin === void 0) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader._enqueue(buffer);
                  } else {
                    this._queuedChunks.push(buffer);
                  }
                } else {
                  const found = this._rangeReaders.some(function(rangeReader) {
                    if (rangeReader._begin !== args.begin) {
                      return false;
                    }
                    rangeReader._enqueue(buffer);
                    return true;
                  });
                  (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                }
              }
              get _progressiveDataLength() {
                var _a, _b;
                return (_b = (_a = this._fullRequestReader) == null ? void 0 : _a._loaded) != null ? _b : 0;
              }
              _onProgress(evt) {
                if (evt.total === void 0) {
                  const firstReader = this._rangeReaders[0];
                  if (firstReader == null ? void 0 : firstReader.onProgress) {
                    firstReader.onProgress({
                      loaded: evt.loaded
                    });
                  }
                } else {
                  const fullReader = this._fullRequestReader;
                  if (fullReader == null ? void 0 : fullReader.onProgress) {
                    fullReader.onProgress({
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  }
                }
              }
              _onProgressiveDone() {
                if (this._fullRequestReader) {
                  this._fullRequestReader.progressiveDone();
                }
                this._progressiveDone = true;
              }
              _removeRangeReader(reader) {
                const i = this._rangeReaders.indexOf(reader);
                if (i >= 0) {
                  this._rangeReaders.splice(i, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                const queuedChunks = this._queuedChunks;
                this._queuedChunks = null;
                return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                this._pdfDataRangeTransport.requestDataRange(begin, end);
                this._rangeReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeReaders.slice(0);
                readers.forEach(function(rangeReader) {
                  rangeReader.cancel(reason);
                });
                this._pdfDataRangeTransport.abort();
              }
            }
            exports2.PDFDataTransportStream = PDFDataTransportStream;
            class PDFDataTransportStreamReader {
              constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                this._stream = stream;
                this._done = progressiveDone || false;
                this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                this._queuedChunks = queuedChunks || [];
                this._loaded = 0;
                for (const chunk of this._queuedChunks) {
                  this._loaded += chunk.byteLength;
                }
                this._requests = [];
                this._headersReady = Promise.resolve();
                stream._fullRequestReader = this;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunks.push(chunk);
                }
                this._loaded += chunk.byteLength;
              }
              get headersReady() {
                return this._headersReady;
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._stream._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._stream._isStreamingSupported;
              }
              get contentLength() {
                return this._stream._contentLength;
              }
              read() {
                return __async(this, null, function* () {
                  if (this._queuedChunks.length > 0) {
                    const chunk = this._queuedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                });
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
              }
              progressiveDone() {
                if (this._done) {
                  return;
                }
                this._done = true;
              }
            }
            class PDFDataTransportStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._begin = begin;
                this._end = end;
                this._queuedChunk = null;
                this._requests = [];
                this._done = false;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length === 0) {
                  this._queuedChunk = chunk;
                } else {
                  const requestsCapability = this._requests.shift();
                  requestsCapability.resolve({
                    value: chunk,
                    done: false
                  });
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                }
                this._done = true;
                this._stream._removeRangeReader(this);
              }
              get isStreamingSupported() {
                return false;
              }
              read() {
                return __async(this, null, function* () {
                  if (this._queuedChunk) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                });
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                this._stream._removeRangeReader(this);
              }
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.WebGLContext = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            class WebGLContext {
              constructor({
                enable = false
              }) {
                this._enabled = enable === true;
              }
              get isEnabled() {
                let enabled = this._enabled;
                if (enabled) {
                  enabled = WebGLUtils.tryInitGL();
                }
                return (0, _util2.shadow)(this, "isEnabled", enabled);
              }
              composeSMask({
                layer,
                mask,
                properties
              }) {
                return WebGLUtils.composeSMask(layer, mask, properties);
              }
              drawFigures({
                width,
                height,
                backgroundColor,
                figures,
                context
              }) {
                return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
              }
              clear() {
                WebGLUtils.cleanup();
              }
            }
            exports2.WebGLContext = WebGLContext;
            const WebGLUtils = function WebGLUtilsClosure() {
              function loadShader(gl, code, shaderType) {
                const shader = gl.createShader(shaderType);
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!compiled) {
                  const errorMsg = gl.getShaderInfoLog(shader);
                  throw new Error("Error during shader compilation: " + errorMsg);
                }
                return shader;
              }
              function createVertexShader(gl, code) {
                return loadShader(gl, code, gl.VERTEX_SHADER);
              }
              function createFragmentShader(gl, code) {
                return loadShader(gl, code, gl.FRAGMENT_SHADER);
              }
              function createProgram(gl, shaders) {
                const program = gl.createProgram();
                for (let i = 0, ii = shaders.length; i < ii; ++i) {
                  gl.attachShader(program, shaders[i]);
                }
                gl.linkProgram(program);
                const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                  const errorMsg = gl.getProgramInfoLog(program);
                  throw new Error("Error during program linking: " + errorMsg);
                }
                return program;
              }
              function createTexture(gl, image, textureId) {
                gl.activeTexture(textureId);
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
              }
              let currentGL, currentCanvas;
              function generateGL() {
                if (currentGL) {
                  return;
                }
                currentCanvas = document.createElement("canvas");
                currentGL = currentCanvas.getContext("webgl", {
                  premultipliedalpha: false
                });
              }
              const smaskVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ";
              const smaskFragmentShaderCode = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ";
              let smaskCache = null;
              function initSmaskGL() {
                generateGL();
                const canvas = currentCanvas;
                currentCanvas = null;
                const gl = currentGL;
                currentGL = null;
                const vertexShader = createVertexShader(gl, smaskVertexShaderCode);
                const fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
                const program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                const cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
                cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
                const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                const texLayerLocation = gl.getUniformLocation(program, "u_image");
                const texMaskLocation = gl.getUniformLocation(program, "u_mask");
                const texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(texCoordLocation);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform1i(texLayerLocation, 0);
                gl.uniform1i(texMaskLocation, 1);
                smaskCache = cache;
              }
              function composeSMask(layer, mask, properties) {
                const width = layer.width, height = layer.height;
                if (!smaskCache) {
                  initSmaskGL();
                }
                const cache = smaskCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                if (properties.backdrop) {
                  gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
                } else {
                  gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
                }
                gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
                const texture = createTexture(gl, layer, gl.TEXTURE0);
                const maskTexture = createTexture(gl, mask, gl.TEXTURE1);
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.flush();
                gl.deleteTexture(texture);
                gl.deleteTexture(maskTexture);
                gl.deleteBuffer(buffer);
                return canvas;
              }
              const figuresVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ";
              const figuresFragmentShaderCode = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ";
              let figuresCache = null;
              function initFiguresGL() {
                generateGL();
                const canvas = currentCanvas;
                currentCanvas = null;
                const gl = currentGL;
                currentGL = null;
                const vertexShader = createVertexShader(gl, figuresVertexShaderCode);
                const fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
                const program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                const cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
                cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.colorLocation = gl.getAttribLocation(program, "a_color");
                figuresCache = cache;
              }
              function drawFigures(width, height, backgroundColor, figures, context) {
                if (!figuresCache) {
                  initFiguresGL();
                }
                const cache = figuresCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                let count = 0;
                for (let i = 0, ii = figures.length; i < ii; i++) {
                  switch (figures[i].type) {
                    case "lattice":
                      const rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
                      count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
                      break;
                    case "triangles":
                      count += figures[i].coords.length;
                      break;
                  }
                }
                const coords = new Float32Array(count * 2);
                const colors = new Uint8Array(count * 3);
                const coordsMap = context.coords, colorsMap = context.colors;
                let pIndex = 0, cIndex = 0;
                for (let i = 0, ii = figures.length; i < ii; i++) {
                  const figure = figures[i], ps = figure.coords, cs = figure.colors;
                  switch (figure.type) {
                    case "lattice":
                      const cols = figure.verticesPerRow;
                      const rows = ps.length / cols | 0;
                      for (let row = 1; row < rows; row++) {
                        let offset = row * cols + 1;
                        for (let col = 1; col < cols; col++, offset++) {
                          coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                          coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                          coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                          coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                          coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                          coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                          colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                          colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                          colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                          colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                          colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                          colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                          colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                          colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                          colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                          coords[pIndex + 6] = coords[pIndex + 2];
                          coords[pIndex + 7] = coords[pIndex + 3];
                          coords[pIndex + 8] = coords[pIndex + 4];
                          coords[pIndex + 9] = coords[pIndex + 5];
                          coords[pIndex + 10] = coordsMap[ps[offset]];
                          coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                          colors[cIndex + 9] = colors[cIndex + 3];
                          colors[cIndex + 10] = colors[cIndex + 4];
                          colors[cIndex + 11] = colors[cIndex + 5];
                          colors[cIndex + 12] = colors[cIndex + 6];
                          colors[cIndex + 13] = colors[cIndex + 7];
                          colors[cIndex + 14] = colors[cIndex + 8];
                          colors[cIndex + 15] = colorsMap[cs[offset]];
                          colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                          colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                          pIndex += 12;
                          cIndex += 18;
                        }
                      }
                      break;
                    case "triangles":
                      for (let j = 0, jj = ps.length; j < jj; j++) {
                        coords[pIndex] = coordsMap[ps[j]];
                        coords[pIndex + 1] = coordsMap[ps[j] + 1];
                        colors[cIndex] = colorsMap[cs[j]];
                        colors[cIndex + 1] = colorsMap[cs[j] + 1];
                        colors[cIndex + 2] = colorsMap[cs[j] + 2];
                        pIndex += 2;
                        cIndex += 3;
                      }
                      break;
                  }
                }
                if (backgroundColor) {
                  gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1);
                } else {
                  gl.clearColor(0, 0, 0, 0);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                const coordsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                const colorsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.colorLocation);
                gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
                gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
                gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
                gl.drawArrays(gl.TRIANGLES, 0, count);
                gl.flush();
                gl.deleteBuffer(coordsBuffer);
                gl.deleteBuffer(colorsBuffer);
                return canvas;
              }
              return {
                tryInitGL() {
                  try {
                    generateGL();
                    return !!currentGL;
                  } catch (ex) {
                  }
                  return false;
                },
                composeSMask,
                drawFigures,
                cleanup() {
                  if (smaskCache == null ? void 0 : smaskCache.canvas) {
                    smaskCache.canvas.width = 0;
                    smaskCache.canvas.height = 0;
                  }
                  if (figuresCache == null ? void 0 : figuresCache.canvas) {
                    figuresCache.canvas.width = 0;
                    figuresCache.canvas.height = 0;
                  }
                  smaskCache = null;
                  figuresCache = null;
                }
              };
            }();
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationLayer = void 0;
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _util2 = __w_pdfjs_require__2(2);
            var _annotation_storage2 = __w_pdfjs_require__2(8);
            var _scripting_utils = __w_pdfjs_require__2(19);
            class AnnotationElementFactory {
              static create(parameters) {
                const subtype = parameters.data.annotationType;
                switch (subtype) {
                  case _util2.AnnotationType.LINK:
                    return new LinkAnnotationElement(parameters);
                  case _util2.AnnotationType.TEXT:
                    return new TextAnnotationElement(parameters);
                  case _util2.AnnotationType.WIDGET:
                    const fieldType = parameters.data.fieldType;
                    switch (fieldType) {
                      case "Tx":
                        return new TextWidgetAnnotationElement(parameters);
                      case "Btn":
                        if (parameters.data.radioButton) {
                          return new RadioButtonWidgetAnnotationElement(parameters);
                        } else if (parameters.data.checkBox) {
                          return new CheckboxWidgetAnnotationElement(parameters);
                        }
                        return new PushButtonWidgetAnnotationElement(parameters);
                      case "Ch":
                        return new ChoiceWidgetAnnotationElement(parameters);
                    }
                    return new WidgetAnnotationElement(parameters);
                  case _util2.AnnotationType.POPUP:
                    return new PopupAnnotationElement(parameters);
                  case _util2.AnnotationType.FREETEXT:
                    return new FreeTextAnnotationElement(parameters);
                  case _util2.AnnotationType.LINE:
                    return new LineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUARE:
                    return new SquareAnnotationElement(parameters);
                  case _util2.AnnotationType.CIRCLE:
                    return new CircleAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYLINE:
                    return new PolylineAnnotationElement(parameters);
                  case _util2.AnnotationType.CARET:
                    return new CaretAnnotationElement(parameters);
                  case _util2.AnnotationType.INK:
                    return new InkAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYGON:
                    return new PolygonAnnotationElement(parameters);
                  case _util2.AnnotationType.HIGHLIGHT:
                    return new HighlightAnnotationElement(parameters);
                  case _util2.AnnotationType.UNDERLINE:
                    return new UnderlineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUIGGLY:
                    return new SquigglyAnnotationElement(parameters);
                  case _util2.AnnotationType.STRIKEOUT:
                    return new StrikeOutAnnotationElement(parameters);
                  case _util2.AnnotationType.STAMP:
                    return new StampAnnotationElement(parameters);
                  case _util2.AnnotationType.FILEATTACHMENT:
                    return new FileAttachmentAnnotationElement(parameters);
                  default:
                    return new AnnotationElement(parameters);
                }
              }
            }
            class AnnotationElement {
              constructor(parameters, {
                isRenderable = false,
                ignoreBorder = false,
                createQuadrilaterals = false
              } = {}) {
                this.isRenderable = isRenderable;
                this.data = parameters.data;
                this.layer = parameters.layer;
                this.page = parameters.page;
                this.viewport = parameters.viewport;
                this.linkService = parameters.linkService;
                this.downloadManager = parameters.downloadManager;
                this.imageResourcesPath = parameters.imageResourcesPath;
                this.renderInteractiveForms = parameters.renderInteractiveForms;
                this.svgFactory = parameters.svgFactory;
                this.annotationStorage = parameters.annotationStorage;
                this.enableScripting = parameters.enableScripting;
                this.hasJSActions = parameters.hasJSActions;
                this._mouseState = parameters.mouseState;
                if (isRenderable) {
                  this.container = this._createContainer(ignoreBorder);
                }
                if (createQuadrilaterals) {
                  this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                }
              }
              _createContainer(ignoreBorder = false) {
                const data = this.data, page = this.page, viewport = this.viewport;
                const container = document.createElement("section");
                let width = data.rect[2] - data.rect[0];
                let height = data.rect[3] - data.rect[1];
                container.setAttribute("data-annotation-id", data.id);
                const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                container.style.transform = `matrix(${viewport.transform.join(",")})`;
                container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;
                if (!ignoreBorder && data.borderStyle.width > 0) {
                  container.style.borderWidth = `${data.borderStyle.width}px`;
                  if (data.borderStyle.style !== _util2.AnnotationBorderStyleType.UNDERLINE) {
                    width = width - 2 * data.borderStyle.width;
                    height = height - 2 * data.borderStyle.width;
                  }
                  const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                  const verticalRadius = data.borderStyle.verticalCornerRadius;
                  if (horizontalRadius > 0 || verticalRadius > 0) {
                    const radius = `${horizontalRadius}px / ${verticalRadius}px`;
                    container.style.borderRadius = radius;
                  }
                  switch (data.borderStyle.style) {
                    case _util2.AnnotationBorderStyleType.SOLID:
                      container.style.borderStyle = "solid";
                      break;
                    case _util2.AnnotationBorderStyleType.DASHED:
                      container.style.borderStyle = "dashed";
                      break;
                    case _util2.AnnotationBorderStyleType.BEVELED:
                      (0, _util2.warn)("Unimplemented border style: beveled");
                      break;
                    case _util2.AnnotationBorderStyleType.INSET:
                      (0, _util2.warn)("Unimplemented border style: inset");
                      break;
                    case _util2.AnnotationBorderStyleType.UNDERLINE:
                      container.style.borderBottomStyle = "solid";
                      break;
                    default:
                      break;
                  }
                  if (data.color) {
                    container.style.borderColor = _util2.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                  } else {
                    container.style.borderWidth = 0;
                  }
                }
                container.style.left = `${rect[0]}px`;
                container.style.top = `${rect[1]}px`;
                container.style.width = `${width}px`;
                container.style.height = `${height}px`;
                return container;
              }
              _createQuadrilaterals(ignoreBorder = false) {
                if (!this.data.quadPoints) {
                  return null;
                }
                const quadrilaterals = [];
                const savedRect = this.data.rect;
                for (const quadPoint of this.data.quadPoints) {
                  this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                  quadrilaterals.push(this._createContainer(ignoreBorder));
                }
                this.data.rect = savedRect;
                return quadrilaterals;
              }
              _createPopup(trigger, data) {
                let container = this.container;
                if (this.quadrilaterals) {
                  trigger = trigger || this.quadrilaterals;
                  container = this.quadrilaterals[0];
                }
                if (!trigger) {
                  trigger = document.createElement("div");
                  trigger.style.height = container.style.height;
                  trigger.style.width = container.style.width;
                  container.appendChild(trigger);
                }
                const popupElement = new PopupElement({
                  container,
                  trigger,
                  color: data.color,
                  title: data.title,
                  modificationDate: data.modificationDate,
                  contents: data.contents,
                  hideWrapper: true
                });
                const popup = popupElement.render();
                popup.style.left = container.style.width;
                container.appendChild(popup);
              }
              _renderQuadrilaterals(className) {
                this.quadrilaterals.forEach((quadrilateral) => {
                  quadrilateral.className = className;
                });
                return this.quadrilaterals;
              }
              render() {
                (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
              }
            }
            class LinkAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
                super(parameters, {
                  isRenderable,
                  createQuadrilaterals: true
                });
              }
              render() {
                const {
                  data,
                  linkService
                } = this;
                const link = document.createElement("a");
                if (data.url) {
                  (0, _display_utils2.addLinkAttributes)(link, {
                    url: data.url,
                    target: data.newWindow ? _display_utils2.LinkTarget.BLANK : linkService.externalLinkTarget,
                    rel: linkService.externalLinkRel,
                    enabled: linkService.externalLinkEnabled
                  });
                } else if (data.action) {
                  this._bindNamedAction(link, data.action);
                } else if (data.dest) {
                  this._bindLink(link, data.dest);
                } else if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                  this._bindJSAction(link, data);
                } else {
                  this._bindLink(link, "");
                }
                if (this.quadrilaterals) {
                  return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
                    const linkElement = index === 0 ? link : link.cloneNode();
                    quadrilateral.appendChild(linkElement);
                    return quadrilateral;
                  });
                }
                this.container.className = "linkAnnotation";
                this.container.appendChild(link);
                return this.container;
              }
              _bindLink(link, destination) {
                link.href = this.linkService.getDestinationHash(destination);
                link.onclick = () => {
                  if (destination) {
                    this.linkService.goToDestination(destination);
                  }
                  return false;
                };
                if (destination || destination === "") {
                  link.className = "internalLink";
                }
              }
              _bindNamedAction(link, action) {
                link.href = this.linkService.getAnchorUrl("");
                link.onclick = () => {
                  this.linkService.executeNamedAction(action);
                  return false;
                };
                link.className = "internalLink";
              }
              _bindJSAction(link, data) {
                link.href = this.linkService.getAnchorUrl("");
                const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                for (const name of Object.keys(data.actions)) {
                  const jsName = map.get(name);
                  if (!jsName) {
                    continue;
                  }
                  link[jsName] = () => {
                    var _a;
                    (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: data.id,
                        name
                      }
                    });
                    return false;
                  };
                }
                link.className = "internalLink";
              }
            }
            class TextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable
                });
              }
              render() {
                this.container.className = "textAnnotation";
                const image = document.createElement("img");
                image.style.height = this.container.style.height;
                image.style.width = this.container.style.width;
                image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                image.alt = "[{{type}} Annotation]";
                image.dataset.l10nId = "text_annotation_type";
                image.dataset.l10nArgs = JSON.stringify({
                  type: this.data.name
                });
                if (!this.data.hasPopup) {
                  this._createPopup(image, this.data);
                }
                this.container.appendChild(image);
                return this.container;
              }
            }
            class WidgetAnnotationElement extends AnnotationElement {
              render() {
                if (this.data.alternativeText) {
                  this.container.title = this.data.alternativeText;
                }
                return this.container;
              }
              _getKeyModifier(event) {
                return navigator.platform.includes("Win") && event.ctrlKey || navigator.platform.includes("Mac") && event.metaKey;
              }
              _setEventListener(element, baseName, eventName, valueGetter) {
                if (baseName.includes("mouse")) {
                  element.addEventListener(baseName, (event) => {
                    var _a;
                    (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: this.data.id,
                        name: eventName,
                        value: valueGetter(event),
                        shift: event.shiftKey,
                        modifier: this._getKeyModifier(event)
                      }
                    });
                  });
                } else {
                  element.addEventListener(baseName, (event) => {
                    var _a;
                    (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: this.data.id,
                        name: eventName,
                        value: event.target.checked
                      }
                    });
                  });
                }
              }
              _setEventListeners(element, names, getter) {
                var _a;
                for (const [baseName, eventName] of names) {
                  if (eventName === "Action" || ((_a = this.data.actions) == null ? void 0 : _a[eventName])) {
                    this._setEventListener(element, baseName, eventName, getter);
                  }
                }
              }
              _setColor(event) {
                const {
                  detail,
                  target
                } = event;
                const {
                  style
                } = target;
                for (const name of ["bgColor", "fillColor", "fgColor", "textColor", "borderColor", "strokeColor"]) {
                  let color = detail[name];
                  if (!color) {
                    continue;
                  }
                  color = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
                  switch (name) {
                    case "bgColor":
                    case "fillColor":
                      style.backgroundColor = color;
                      break;
                    case "fgColor":
                    case "textColor":
                      style.color = color;
                      break;
                    case "borderColor":
                    case "strokeColor":
                      style.borderColor = color;
                      break;
                  }
                }
              }
            }
            class TextWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                super(parameters, {
                  isRenderable
                });
              }
              render() {
                var _a;
                const storage = this.annotationStorage;
                const id = this.data.id;
                this.container.className = "textWidgetAnnotation";
                let element = null;
                if (this.renderInteractiveForms) {
                  const storedData = storage.getValue(id, {
                    value: this.data.fieldValue,
                    valueAsString: this.data.fieldValue
                  });
                  const textContent = storedData.valueAsString || storedData.value || "";
                  const elementData = {
                    userValue: null,
                    formattedValue: null,
                    beforeInputSelectionRange: null,
                    beforeInputValue: null
                  };
                  if (this.data.multiLine) {
                    element = document.createElement("textarea");
                    element.textContent = textContent;
                  } else {
                    element = document.createElement("input");
                    element.type = "text";
                    element.setAttribute("value", textContent);
                  }
                  elementData.userValue = textContent;
                  element.setAttribute("id", id);
                  element.addEventListener("input", function(event) {
                    storage.setValue(id, {
                      value: event.target.value
                    });
                  });
                  let blurListener = (event) => {
                    if (elementData.formattedValue) {
                      event.target.value = elementData.formattedValue;
                    }
                    event.target.setSelectionRange(0, 0);
                    elementData.beforeInputSelectionRange = null;
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("focus", (event) => {
                      if (elementData.userValue) {
                        event.target.value = elementData.userValue;
                      }
                    });
                    element.addEventListener("updatefromsandbox", (event) => {
                      const {
                        detail
                      } = event;
                      const actions = {
                        value() {
                          elementData.userValue = detail.value || "";
                          storage.setValue(id, {
                            value: elementData.userValue.toString()
                          });
                          if (!elementData.formattedValue) {
                            event.target.value = elementData.userValue;
                          }
                        },
                        valueAsString() {
                          elementData.formattedValue = detail.valueAsString || "";
                          if (event.target !== document.activeElement) {
                            event.target.value = elementData.formattedValue;
                          }
                          storage.setValue(id, {
                            formattedValue: elementData.formattedValue
                          });
                        },
                        focus() {
                          setTimeout(() => event.target.focus({
                            preventScroll: false
                          }), 0);
                        },
                        userName() {
                          event.target.title = detail.userName;
                        },
                        hidden() {
                          event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                          storage.setValue(id, {
                            hidden: detail.hidden
                          });
                        },
                        editable() {
                          event.target.disabled = !detail.editable;
                        },
                        selRange() {
                          const [selStart, selEnd] = detail.selRange;
                          if (selStart >= 0 && selEnd < event.target.value.length) {
                            event.target.setSelectionRange(selStart, selEnd);
                          }
                        }
                      };
                      Object.keys(detail).filter((name) => name in actions).forEach((name) => actions[name]());
                      this._setColor(event);
                    });
                    element.addEventListener("keydown", (event) => {
                      var _a2;
                      elementData.beforeInputValue = event.target.value;
                      let commitKey = -1;
                      if (event.key === "Escape") {
                        commitKey = 0;
                      } else if (event.key === "Enter") {
                        commitKey = 2;
                      } else if (event.key === "Tab") {
                        commitKey = 3;
                      }
                      if (commitKey === -1) {
                        return;
                      }
                      elementData.userValue = event.target.value;
                      (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id,
                          name: "Keystroke",
                          value: event.target.value,
                          willCommit: true,
                          commitKey,
                          selStart: event.target.selectionStart,
                          selEnd: event.target.selectionEnd
                        }
                      });
                    });
                    const _blurListener = blurListener;
                    blurListener = null;
                    element.addEventListener("blur", (event) => {
                      var _a2;
                      if (this._mouseState.isDown) {
                        elementData.userValue = event.target.value;
                        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value: event.target.value,
                            willCommit: true,
                            commitKey: 1,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      }
                      _blurListener(event);
                    });
                    element.addEventListener("mousedown", (event) => {
                      elementData.beforeInputValue = event.target.value;
                      elementData.beforeInputSelectionRange = null;
                    });
                    element.addEventListener("keyup", (event) => {
                      if (event.target.selectionStart === event.target.selectionEnd) {
                        elementData.beforeInputSelectionRange = null;
                      }
                    });
                    element.addEventListener("select", (event) => {
                      elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
                    });
                    if ((_a = this.data.actions) == null ? void 0 : _a.Keystroke) {
                      element.addEventListener("input", (event) => {
                        var _a2;
                        let selStart = -1;
                        let selEnd = -1;
                        if (elementData.beforeInputSelectionRange) {
                          [selStart, selEnd] = elementData.beforeInputSelectionRange;
                        }
                        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value: elementData.beforeInputValue,
                            change: event.data,
                            willCommit: false,
                            selStart,
                            selEnd
                          }
                        });
                      });
                    }
                    this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                  }
                  if (blurListener) {
                    element.addEventListener("blur", blurListener);
                  }
                  element.disabled = this.data.readOnly;
                  element.name = this.data.fieldName;
                  if (this.data.maxLen !== null) {
                    element.maxLength = this.data.maxLen;
                  }
                  if (this.data.comb) {
                    const fieldWidth = this.data.rect[2] - this.data.rect[0];
                    const combWidth = fieldWidth / this.data.maxLen;
                    element.classList.add("comb");
                    element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
                  }
                } else {
                  element = document.createElement("div");
                  element.textContent = this.data.fieldValue;
                  element.style.verticalAlign = "middle";
                  element.style.display = "table-cell";
                }
                this._setTextStyle(element);
                this.container.appendChild(element);
                return this.container;
              }
              _setTextStyle(element) {
                const TEXT_ALIGNMENT = ["left", "center", "right"];
                const {
                  fontSize,
                  fontColor
                } = this.data.defaultAppearanceData;
                const style = element.style;
                if (fontSize) {
                  style.fontSize = `${fontSize}px`;
                }
                style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                if (this.data.textAlignment !== null) {
                  style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                }
              }
            }
            class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: parameters.renderInteractiveForms
                });
              }
              render() {
                const storage = this.annotationStorage;
                const data = this.data;
                const id = data.id;
                const value = storage.getValue(id, {
                  value: data.fieldValue && (data.exportValue && data.exportValue === data.fieldValue || !data.exportValue && data.fieldValue !== "Off")
                }).value;
                this.container.className = "buttonWidgetAnnotation checkBox";
                const element = document.createElement("input");
                element.disabled = data.readOnly;
                element.type = "checkbox";
                element.name = this.data.fieldName;
                if (value) {
                  element.setAttribute("checked", true);
                }
                element.setAttribute("id", id);
                element.addEventListener("change", function(event) {
                  const name = event.target.name;
                  for (const checkbox of document.getElementsByName(name)) {
                    if (checkbox !== event.target) {
                      checkbox.checked = false;
                      storage.setValue(checkbox.parentNode.getAttribute("data-annotation-id"), {
                        value: false
                      });
                    }
                  }
                  storage.setValue(id, {
                    value: event.target.checked
                  });
                });
                if (this.enableScripting && this.hasJSActions) {
                  element.addEventListener("updatefromsandbox", (event) => {
                    const {
                      detail
                    } = event;
                    const actions = {
                      value() {
                        event.target.checked = detail.value !== "Off";
                        storage.setValue(id, {
                          value: event.target.checked
                        });
                      },
                      focus() {
                        setTimeout(() => event.target.focus({
                          preventScroll: false
                        }), 0);
                      },
                      hidden() {
                        event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                        storage.setValue(id, {
                          hidden: detail.hidden
                        });
                      },
                      editable() {
                        event.target.disabled = !detail.editable;
                      }
                    };
                    Object.keys(detail).filter((name) => name in actions).forEach((name) => actions[name]());
                    this._setColor(event);
                  });
                  this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                }
                this.container.appendChild(element);
                return this.container;
              }
            }
            class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: parameters.renderInteractiveForms
                });
              }
              render() {
                this.container.className = "buttonWidgetAnnotation radioButton";
                const storage = this.annotationStorage;
                const data = this.data;
                const id = data.id;
                const value = storage.getValue(id, {
                  value: data.fieldValue === data.buttonValue
                }).value;
                const element = document.createElement("input");
                element.disabled = data.readOnly;
                element.type = "radio";
                element.name = data.fieldName;
                if (value) {
                  element.setAttribute("checked", true);
                }
                element.setAttribute("id", id);
                element.addEventListener("change", function(event) {
                  const {
                    target
                  } = event;
                  for (const radio of document.getElementsByName(target.name)) {
                    if (radio !== target) {
                      storage.setValue(radio.getAttribute("id"), {
                        value: false
                      });
                    }
                  }
                  storage.setValue(id, {
                    value: target.checked
                  });
                });
                if (this.enableScripting && this.hasJSActions) {
                  const pdfButtonValue = data.buttonValue;
                  element.addEventListener("updatefromsandbox", (event) => {
                    const {
                      detail
                    } = event;
                    const actions = {
                      value() {
                        const checked = pdfButtonValue === detail.value;
                        for (const radio of document.getElementsByName(event.target.name)) {
                          const radioId = radio.getAttribute("id");
                          radio.checked = radioId === id && checked;
                          storage.setValue(radioId, {
                            value: radio.checked
                          });
                        }
                      },
                      focus() {
                        setTimeout(() => event.target.focus({
                          preventScroll: false
                        }), 0);
                      },
                      hidden() {
                        event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                        storage.setValue(id, {
                          hidden: detail.hidden
                        });
                      },
                      editable() {
                        event.target.disabled = !detail.editable;
                      }
                    };
                    Object.keys(detail).filter((name) => name in actions).forEach((name) => actions[name]());
                    this._setColor(event);
                  });
                  this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                }
                this.container.appendChild(element);
                return this.container;
              }
            }
            class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
              render() {
                const container = super.render();
                container.className = "buttonWidgetAnnotation pushButton";
                if (this.data.alternativeText) {
                  container.title = this.data.alternativeText;
                }
                return container;
              }
            }
            class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: parameters.renderInteractiveForms
                });
              }
              render() {
                this.container.className = "choiceWidgetAnnotation";
                const storage = this.annotationStorage;
                const id = this.data.id;
                storage.getValue(id, {
                  value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : void 0
                });
                const selectElement = document.createElement("select");
                selectElement.disabled = this.data.readOnly;
                selectElement.name = this.data.fieldName;
                selectElement.setAttribute("id", id);
                if (!this.data.combo) {
                  selectElement.size = this.data.options.length;
                  if (this.data.multiSelect) {
                    selectElement.multiple = true;
                  }
                }
                for (const option of this.data.options) {
                  const optionElement = document.createElement("option");
                  optionElement.textContent = option.displayValue;
                  optionElement.value = option.exportValue;
                  if (this.data.fieldValue.includes(option.exportValue)) {
                    optionElement.setAttribute("selected", true);
                  }
                  selectElement.appendChild(optionElement);
                }
                const getValue = (event, isExport) => {
                  const name = isExport ? "value" : "textContent";
                  const options = event.target.options;
                  if (!event.target.multiple) {
                    return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                  }
                  return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                };
                const getItems = (event) => {
                  const options = event.target.options;
                  return Array.prototype.map.call(options, (option) => {
                    return {
                      displayValue: option.textContent,
                      exportValue: option.value
                    };
                  });
                };
                if (this.enableScripting && this.hasJSActions) {
                  selectElement.addEventListener("updatefromsandbox", (event) => {
                    const {
                      detail
                    } = event;
                    const actions = {
                      value() {
                        const options = selectElement.options;
                        const value = detail.value;
                        const values = new Set(Array.isArray(value) ? value : [value]);
                        Array.prototype.forEach.call(options, (option) => {
                          option.selected = values.has(option.value);
                        });
                        storage.setValue(id, {
                          value: getValue(event, true)
                        });
                      },
                      multipleSelection() {
                        selectElement.multiple = true;
                      },
                      remove() {
                        const options = selectElement.options;
                        const index = detail.remove;
                        options[index].selected = false;
                        selectElement.remove(index);
                        if (options.length > 0) {
                          const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                          if (i === -1) {
                            options[0].selected = true;
                          }
                        }
                        storage.setValue(id, {
                          value: getValue(event, true),
                          items: getItems(event)
                        });
                      },
                      clear() {
                        while (selectElement.length !== 0) {
                          selectElement.remove(0);
                        }
                        storage.setValue(id, {
                          value: null,
                          items: []
                        });
                      },
                      insert() {
                        const {
                          index,
                          displayValue,
                          exportValue
                        } = detail.insert;
                        const optionElement = document.createElement("option");
                        optionElement.textContent = displayValue;
                        optionElement.value = exportValue;
                        selectElement.insertBefore(optionElement, selectElement.children[index]);
                        storage.setValue(id, {
                          value: getValue(event, true),
                          items: getItems(event)
                        });
                      },
                      items() {
                        const {
                          items
                        } = detail;
                        while (selectElement.length !== 0) {
                          selectElement.remove(0);
                        }
                        for (const item of items) {
                          const {
                            displayValue,
                            exportValue
                          } = item;
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          selectElement.appendChild(optionElement);
                        }
                        if (selectElement.options.length > 0) {
                          selectElement.options[0].selected = true;
                        }
                        storage.setValue(id, {
                          value: getValue(event, true),
                          items: getItems(event)
                        });
                      },
                      indices() {
                        const indices = new Set(detail.indices);
                        const options = event.target.options;
                        Array.prototype.forEach.call(options, (option, i) => {
                          option.selected = indices.has(i);
                        });
                        storage.setValue(id, {
                          value: getValue(event, true)
                        });
                      },
                      focus() {
                        setTimeout(() => event.target.focus({
                          preventScroll: false
                        }), 0);
                      },
                      hidden() {
                        event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                        storage.setValue(id, {
                          hidden: detail.hidden
                        });
                      },
                      editable() {
                        event.target.disabled = !detail.editable;
                      }
                    };
                    Object.keys(detail).filter((name) => name in actions).forEach((name) => actions[name]());
                    this._setColor(event);
                  });
                  selectElement.addEventListener("input", (event) => {
                    var _a;
                    const exportValue = getValue(event, true);
                    const value = getValue(event, false);
                    storage.setValue(id, {
                      value: exportValue
                    });
                    (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id,
                        name: "Keystroke",
                        value,
                        changeEx: exportValue,
                        willCommit: true,
                        commitKey: 1,
                        keyDown: false
                      }
                    });
                  });
                  this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (event) => event.target.checked);
                } else {
                  selectElement.addEventListener("input", function(event) {
                    storage.setValue(id, {
                      value: getValue(event)
                    });
                  });
                }
                this.container.appendChild(selectElement);
                return this.container;
              }
            }
            class PopupAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable
                });
              }
              render() {
                const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                this.container.className = "popupAnnotation";
                if (IGNORE_TYPES.includes(this.data.parentType)) {
                  return this.container;
                }
                const selector = `[data-annotation-id="${this.data.parentId}"]`;
                const parentElements = this.layer.querySelectorAll(selector);
                if (parentElements.length === 0) {
                  return this.container;
                }
                const popup = new PopupElement({
                  container: this.container,
                  trigger: Array.from(parentElements),
                  color: this.data.color,
                  title: this.data.title,
                  modificationDate: this.data.modificationDate,
                  contents: this.data.contents
                });
                const page = this.page;
                const rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                const popupTop = rect[1];
                this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;
                this.container.style.left = `${popupLeft}px`;
                this.container.style.top = `${popupTop}px`;
                this.container.appendChild(popup.render());
                return this.container;
              }
            }
            class PopupElement {
              constructor(parameters) {
                this.container = parameters.container;
                this.trigger = parameters.trigger;
                this.color = parameters.color;
                this.title = parameters.title;
                this.modificationDate = parameters.modificationDate;
                this.contents = parameters.contents;
                this.hideWrapper = parameters.hideWrapper || false;
                this.pinned = false;
              }
              render() {
                const BACKGROUND_ENLIGHT = 0.7;
                const wrapper = document.createElement("div");
                wrapper.className = "popupWrapper";
                this.hideElement = this.hideWrapper ? wrapper : this.container;
                this.hideElement.hidden = true;
                const popup = document.createElement("div");
                popup.className = "popup";
                const color = this.color;
                if (color) {
                  const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                  const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                  const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                  popup.style.backgroundColor = _util2.Util.makeHexColor(r | 0, g | 0, b | 0);
                }
                const title = document.createElement("h1");
                title.textContent = this.title;
                popup.appendChild(title);
                const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                if (dateObject) {
                  const modificationDate = document.createElement("span");
                  modificationDate.textContent = "{{date}}, {{time}}";
                  modificationDate.dataset.l10nId = "annotation_date_string";
                  modificationDate.dataset.l10nArgs = JSON.stringify({
                    date: dateObject.toLocaleDateString(),
                    time: dateObject.toLocaleTimeString()
                  });
                  popup.appendChild(modificationDate);
                }
                const contents = this._formatContents(this.contents);
                popup.appendChild(contents);
                if (!Array.isArray(this.trigger)) {
                  this.trigger = [this.trigger];
                }
                this.trigger.forEach((element) => {
                  element.addEventListener("click", this._toggle.bind(this));
                  element.addEventListener("mouseover", this._show.bind(this, false));
                  element.addEventListener("mouseout", this._hide.bind(this, false));
                });
                popup.addEventListener("click", this._hide.bind(this, true));
                wrapper.appendChild(popup);
                return wrapper;
              }
              _formatContents(contents) {
                const p = document.createElement("p");
                const lines = contents.split(/(?:\r\n?|\n)/);
                for (let i = 0, ii = lines.length; i < ii; ++i) {
                  const line = lines[i];
                  p.appendChild(document.createTextNode(line));
                  if (i < ii - 1) {
                    p.appendChild(document.createElement("br"));
                  }
                }
                return p;
              }
              _toggle() {
                if (this.pinned) {
                  this._hide(true);
                } else {
                  this._show(true);
                }
              }
              _show(pin = false) {
                if (pin) {
                  this.pinned = true;
                }
                if (this.hideElement.hidden) {
                  this.hideElement.hidden = false;
                  this.container.style.zIndex += 1;
                }
              }
              _hide(unpin = true) {
                if (unpin) {
                  this.pinned = false;
                }
                if (!this.hideElement.hidden && !this.pinned) {
                  this.hideElement.hidden = true;
                  this.container.style.zIndex -= 1;
                }
              }
            }
            class FreeTextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.className = "freeTextAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(null, this.data);
                }
                return this.container;
              }
            }
            class LineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.className = "lineAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const line = this.svgFactory.createElement("svg:line");
                line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                line.setAttribute("stroke-width", data.borderStyle.width || 1);
                line.setAttribute("stroke", "transparent");
                svg.appendChild(line);
                this.container.append(svg);
                this._createPopup(line, data);
                return this.container;
              }
            }
            class SquareAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.className = "squareAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const borderWidth = data.borderStyle.width;
                const square = this.svgFactory.createElement("svg:rect");
                square.setAttribute("x", borderWidth / 2);
                square.setAttribute("y", borderWidth / 2);
                square.setAttribute("width", width - borderWidth);
                square.setAttribute("height", height - borderWidth);
                square.setAttribute("stroke-width", borderWidth || 1);
                square.setAttribute("stroke", "transparent");
                square.setAttribute("fill", "none");
                svg.appendChild(square);
                this.container.append(svg);
                this._createPopup(square, data);
                return this.container;
              }
            }
            class CircleAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.className = "circleAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const borderWidth = data.borderStyle.width;
                const circle = this.svgFactory.createElement("svg:ellipse");
                circle.setAttribute("cx", width / 2);
                circle.setAttribute("cy", height / 2);
                circle.setAttribute("rx", width / 2 - borderWidth / 2);
                circle.setAttribute("ry", height / 2 - borderWidth / 2);
                circle.setAttribute("stroke-width", borderWidth || 1);
                circle.setAttribute("stroke", "transparent");
                circle.setAttribute("fill", "none");
                svg.appendChild(circle);
                this.container.append(svg);
                this._createPopup(circle, data);
                return this.container;
              }
            }
            class PolylineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
                this.containerClassName = "polylineAnnotation";
                this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.className = this.containerClassName;
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                let points = [];
                for (const coordinate of data.vertices) {
                  const x = coordinate.x - data.rect[0];
                  const y = data.rect[3] - coordinate.y;
                  points.push(x + "," + y);
                }
                points = points.join(" ");
                const polyline = this.svgFactory.createElement(this.svgElementName);
                polyline.setAttribute("points", points);
                polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                polyline.setAttribute("stroke", "transparent");
                polyline.setAttribute("fill", "none");
                svg.appendChild(polyline);
                this.container.append(svg);
                this._createPopup(polyline, data);
                return this.container;
              }
            }
            class PolygonAnnotationElement extends PolylineAnnotationElement {
              constructor(parameters) {
                super(parameters);
                this.containerClassName = "polygonAnnotation";
                this.svgElementName = "svg:polygon";
              }
            }
            class CaretAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.className = "caretAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(null, this.data);
                }
                return this.container;
              }
            }
            class InkAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
                this.containerClassName = "inkAnnotation";
                this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.className = this.containerClassName;
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                for (const inkList of data.inkLists) {
                  let points = [];
                  for (const coordinate of inkList) {
                    const x = coordinate.x - data.rect[0];
                    const y = data.rect[3] - coordinate.y;
                    points.push(`${x},${y}`);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "none");
                  this._createPopup(polyline, data);
                  svg.appendChild(polyline);
                }
                this.container.append(svg);
                return this.container;
              }
            }
            class HighlightAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.hasPopup) {
                  this._createPopup(null, this.data);
                }
                if (this.quadrilaterals) {
                  return this._renderQuadrilaterals("highlightAnnotation");
                }
                this.container.className = "highlightAnnotation";
                return this.container;
              }
            }
            class UnderlineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.hasPopup) {
                  this._createPopup(null, this.data);
                }
                if (this.quadrilaterals) {
                  return this._renderQuadrilaterals("underlineAnnotation");
                }
                this.container.className = "underlineAnnotation";
                return this.container;
              }
            }
            class SquigglyAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.hasPopup) {
                  this._createPopup(null, this.data);
                }
                if (this.quadrilaterals) {
                  return this._renderQuadrilaterals("squigglyAnnotation");
                }
                this.container.className = "squigglyAnnotation";
                return this.container;
              }
            }
            class StrikeOutAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.hasPopup) {
                  this._createPopup(null, this.data);
                }
                if (this.quadrilaterals) {
                  return this._renderQuadrilaterals("strikeoutAnnotation");
                }
                this.container.className = "strikeoutAnnotation";
                return this.container;
              }
            }
            class StampAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.className = "stampAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(null, this.data);
                }
                return this.container;
              }
            }
            class FileAttachmentAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                var _a;
                super(parameters, {
                  isRenderable: true
                });
                const {
                  filename,
                  content
                } = this.data.file;
                this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                this.content = content;
                (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("fileattachmentannotation", {
                  source: this,
                  id: (0, _util2.stringToPDFString)(filename),
                  filename,
                  content
                });
              }
              render() {
                this.container.className = "fileAttachmentAnnotation";
                const trigger = document.createElement("div");
                trigger.style.height = this.container.style.height;
                trigger.style.width = this.container.style.width;
                trigger.addEventListener("dblclick", this._download.bind(this));
                if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
                  this._createPopup(trigger, this.data);
                }
                this.container.appendChild(trigger);
                return this.container;
              }
              _download() {
                var _a;
                (_a = this.downloadManager) == null ? void 0 : _a.openOrDownloadData(this.container, this.content, this.filename);
              }
            }
            class AnnotationLayer {
              static render(parameters) {
                const sortedAnnotations = [], popupAnnotations = [];
                for (const data of parameters.annotations) {
                  if (!data) {
                    continue;
                  }
                  if (data.annotationType === _util2.AnnotationType.POPUP) {
                    popupAnnotations.push(data);
                    continue;
                  }
                  sortedAnnotations.push(data);
                }
                if (popupAnnotations.length) {
                  sortedAnnotations.push(...popupAnnotations);
                }
                for (const data of sortedAnnotations) {
                  const element = AnnotationElementFactory.create({
                    data,
                    layer: parameters.div,
                    page: parameters.page,
                    viewport: parameters.viewport,
                    linkService: parameters.linkService,
                    downloadManager: parameters.downloadManager,
                    imageResourcesPath: parameters.imageResourcesPath || "",
                    renderInteractiveForms: parameters.renderInteractiveForms !== false,
                    svgFactory: new _display_utils2.DOMSVGFactory(),
                    annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                    enableScripting: parameters.enableScripting,
                    hasJSActions: parameters.hasJSActions,
                    mouseState: parameters.mouseState || {
                      isDown: false
                    }
                  });
                  if (element.isRenderable) {
                    const rendered = element.render();
                    if (data.hidden) {
                      rendered.style.visibility = "hidden";
                    }
                    if (Array.isArray(rendered)) {
                      for (const renderedElement of rendered) {
                        parameters.div.appendChild(renderedElement);
                      }
                    } else {
                      if (element instanceof PopupAnnotationElement) {
                        parameters.div.prepend(rendered);
                      } else {
                        parameters.div.appendChild(rendered);
                      }
                    }
                  }
                }
              }
              static update(parameters) {
                const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                for (const data of parameters.annotations) {
                  const elements = parameters.div.querySelectorAll(`[data-annotation-id="${data.id}"]`);
                  if (elements) {
                    elements.forEach((element) => {
                      element.style.transform = transform;
                    });
                  }
                }
                parameters.div.hidden = false;
              }
            }
            exports2.AnnotationLayer = AnnotationLayer;
          },
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ColorConverters = void 0;
            function makeColorComp(n) {
              return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
            }
            class ColorConverters {
              static CMYK_G([c, y, m, k]) {
                return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
              }
              static G_CMYK([g]) {
                return ["CMYK", 0, 0, 0, 1 - g];
              }
              static G_RGB([g]) {
                return ["RGB", g, g, g];
              }
              static G_HTML([g]) {
                const G = makeColorComp(g);
                return `#${G}${G}${G}`;
              }
              static RGB_G([r, g, b]) {
                return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
              }
              static RGB_HTML([r, g, b]) {
                const R = makeColorComp(r);
                const G = makeColorComp(g);
                const B = makeColorComp(b);
                return `#${R}${G}${B}`;
              }
              static T_HTML() {
                return "#00000000";
              }
              static CMYK_RGB([c, y, m, k]) {
                return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
              }
              static CMYK_HTML(components) {
                return this.RGB_HTML(this.CMYK_RGB(components));
              }
              static RGB_CMYK([r, g, b]) {
                const c = 1 - r;
                const m = 1 - g;
                const y = 1 - b;
                const k = Math.min(c, m, y);
                return ["CMYK", c, m, y, k];
              }
            }
            exports2.ColorConverters = ColorConverters;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.renderTextLayer = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            const renderTextLayer = function renderTextLayerClosure() {
              const MAX_TEXT_DIVS_TO_RENDER = 1e5;
              const DEFAULT_FONT_SIZE = 30;
              const DEFAULT_FONT_ASCENT = 0.8;
              const ascentCache = /* @__PURE__ */ new Map();
              const NonWhitespaceRegexp = /\S/;
              function isAllWhitespace(str) {
                return !NonWhitespaceRegexp.test(str);
              }
              function getAscent(fontFamily, ctx) {
                const cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                ctx.save();
                ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                const metrics = ctx.measureText("");
                let ascent = metrics.fontBoundingBoxAscent;
                let descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  ctx.restore();
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (let i = 0, ii = pixels.length; i < ii; i += 4) {
                  if (pixels[i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.restore();
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles, ctx) {
                const textDiv = document.createElement("span");
                const textDivProperties = {
                  angle: 0,
                  canvasWidth: 0,
                  isWhitespace: false,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1
                };
                task._textDivs.push(textDiv);
                if (isAllWhitespace(geom.str)) {
                  textDivProperties.isWhitespace = true;
                  task._textDivProperties.set(textDiv, textDivProperties);
                  return;
                }
                const tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                let angle = Math.atan2(tx[1], tx[0]);
                const style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                const fontHeight = Math.hypot(tx[2], tx[3]);
                const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                let left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                textDiv.style.left = `${left}px`;
                textDiv.style.top = `${top}px`;
                textDiv.style.fontSize = `${fontHeight}px`;
                textDiv.style.fontFamily = style.fontFamily;
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                let shouldScaleText = false;
                if (geom.str.length > 1) {
                  shouldScaleText = true;
                } else if (geom.transform[0] !== geom.transform[3]) {
                  const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection) {
                  let angleCos = 1, angleSin = 0;
                  if (angle !== 0) {
                    angleCos = Math.cos(angle);
                    angleSin = Math.sin(angle);
                  }
                  const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  const divHeight = fontHeight;
                  let m, b;
                  if (angle !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                const textDivs = task._textDivs;
                const capability = task._capability;
                const textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (let i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function findPositiveMin(ts, offset, count) {
                let result = 0;
                for (let i = 0; i < count; i++) {
                  const t = ts[offset++];
                  if (t > 0) {
                    result = result ? Math.min(t, result) : t;
                  }
                }
                return result;
              }
              function expand(task) {
                const bounds = task._bounds;
                const viewport = task._viewport;
                const expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (let i = 0; i < expanded.length; i++) {
                  const div = bounds[i].div;
                  const divProperties = task._textDivProperties.get(div);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div, divProperties);
                    continue;
                  }
                  const e = expanded[i], b = bounds[i];
                  const m = b.m, c = m[0], s = m[1];
                  const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  const ts = new Float64Array(64);
                  points.forEach(function(p, j) {
                    const t = _util2.Util.applyTransform(p, m);
                    ts[j + 0] = c && (e.left - t[0]) / c;
                    ts[j + 4] = s && (e.top - t[1]) / s;
                    ts[j + 8] = c && (e.right - t[0]) / c;
                    ts[j + 12] = s && (e.bottom - t[1]) / s;
                    ts[j + 16] = s && (e.left - t[0]) / -s;
                    ts[j + 20] = c && (e.top - t[1]) / c;
                    ts[j + 24] = s && (e.right - t[0]) / -s;
                    ts[j + 28] = c && (e.bottom - t[1]) / c;
                    ts[j + 32] = c && (e.left - t[0]) / -c;
                    ts[j + 36] = s && (e.top - t[1]) / -s;
                    ts[j + 40] = c && (e.right - t[0]) / -c;
                    ts[j + 44] = s && (e.bottom - t[1]) / -s;
                    ts[j + 48] = s && (e.left - t[0]) / s;
                    ts[j + 52] = c && (e.top - t[1]) / -c;
                    ts[j + 56] = s && (e.right - t[0]) / s;
                    ts[j + 60] = c && (e.bottom - t[1]) / -c;
                  });
                  const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div, divProperties);
                }
              }
              function expandBounds(width, height, boxes) {
                const bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                const expanded = new Array(boxes.length);
                bounds.forEach(function(b) {
                  const i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                });
                boxes.map(function(box, i) {
                  const e = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width - e.right;
                  b.x2 = box.bottom;
                  b.y2 = width - e.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                bounds.forEach(function(b) {
                  const i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                });
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                const fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                const horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                bounds.forEach(function(boundary) {
                  let i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  let j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  let horizonPart, affectedBoundary;
                  let q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    let xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  const changedHorizon = [];
                  let lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    let used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
                });
                horizon.forEach(function(horizonPart) {
                  const affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                });
              }
              function TextLayerRenderTask({
                textContent,
                textContentStream,
                container,
                viewport,
                textDivs,
                textContentItemsStr,
                enhanceTextSelection
              }) {
                var _a;
                this._textContent = textContent;
                this._textContentStream = textContentStream;
                this._container = container;
                this._document = container.ownerDocument;
                this._viewport = viewport;
                this._textDivs = textDivs || [];
                this._textContentItemsStr = textContentItemsStr || [];
                this._enhanceTextSelection = !!enhanceTextSelection;
                this._fontInspectorEnabled = !!((_a = globalThis.FontInspector) == null ? void 0 : _a.enabled);
                this._reader = null;
                this._layoutTextLastFontSize = null;
                this._layoutTextLastFontFamily = null;
                this._layoutTextCtx = null;
                this._textDivProperties = /* @__PURE__ */ new WeakMap();
                this._renderingDone = false;
                this._canceled = false;
                this._capability = (0, _util2.createPromiseCapability)();
                this._renderTimer = null;
                this._bounds = [];
                this._capability.promise.finally(() => {
                  if (this._layoutTextCtx) {
                    this._layoutTextCtx.canvas.width = 0;
                    this._layoutTextCtx.canvas.height = 0;
                    this._layoutTextCtx = null;
                  }
                }).catch(() => {
                });
              }
              TextLayerRenderTask.prototype = {
                get promise() {
                  return this._capability.promise;
                },
                cancel: function TextLayer_cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled."));
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                },
                _processItems(items, styleCache) {
                  for (let i = 0, len = items.length; i < len; i++) {
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache, this._layoutTextCtx);
                  }
                },
                _layoutText(textDiv) {
                  const textDivProperties = this._textDivProperties.get(textDiv);
                  if (textDivProperties.isWhitespace) {
                    return;
                  }
                  let transform = "";
                  if (textDivProperties.canvasWidth !== 0) {
                    const {
                      fontSize,
                      fontFamily
                    } = textDiv.style;
                    if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
                      this._layoutTextLastFontSize = fontSize;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    const {
                      width
                    } = this._layoutTextCtx.measureText(textDiv.textContent);
                    if (width > 0) {
                      textDivProperties.scale = textDivProperties.canvasWidth / width;
                      transform = `scaleX(${textDivProperties.scale})`;
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
                  }
                  if (transform.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform;
                    }
                    textDiv.style.transform = transform;
                  }
                  this._textDivProperties.set(textDiv, textDivProperties);
                  this._container.appendChild(textDiv);
                },
                _render: function TextLayer_render(timeout) {
                  const capability = (0, _util2.createPromiseCapability)();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  const canvas = this._document.createElement("canvas");
                  canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                  canvas.mozOpaque = true;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    const textItems = this._textContent.items;
                    const textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        this._processItems(value.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    if (!timeout) {
                      render(this);
                    } else {
                      this._renderTimer = setTimeout(() => {
                        render(this);
                        this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                },
                expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  const transformBuf = [], paddingBuf = [];
                  for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
                    const div = this._textDivs[i];
                    const divProps = this._textDivProperties.get(div);
                    if (divProps.isWhitespace) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push(`${divProps.paddingTop}px`);
                        transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push(`${divProps.paddingBottom}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                        transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      div.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div.style.padding = null;
                      div.style.transform = divProps.originalTransform;
                    }
                  }
                }
              };
              function renderTextLayer2(renderParameters) {
                const task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
              return renderTextLayer2;
            }();
            exports2.renderTextLayer = renderTextLayer;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SVGGraphics = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _is_node2 = __w_pdfjs_require__2(4);
            let SVGGraphics = function() {
              throw new Error("Not implemented: SVGGraphics");
            };
            exports2.SVGGraphics = SVGGraphics;
            {
              let opListToTree = function(opList) {
                let opTree = [];
                const tmp = [];
                for (const opListElement of opList) {
                  if (opListElement.fn === "save") {
                    opTree.push({
                      fnId: 92,
                      fn: "group",
                      items: []
                    });
                    tmp.push(opTree);
                    opTree = opTree[opTree.length - 1].items;
                    continue;
                  }
                  if (opListElement.fn === "restore") {
                    opTree = tmp.pop();
                  } else {
                    opTree.push(opListElement);
                  }
                }
                return opTree;
              }, pf = function(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                const s = value.toFixed(10);
                let i = s.length - 1;
                if (s[i] !== "0") {
                  return s;
                }
                do {
                  i--;
                } while (s[i] === "0");
                return s.substring(0, s[i] === "." ? i : i + 1);
              }, pm = function(m) {
                if (m[4] === 0 && m[5] === 0) {
                  if (m[1] === 0 && m[2] === 0) {
                    if (m[0] === 1 && m[3] === 1) {
                      return "";
                    }
                    return `scale(${pf(m[0])} ${pf(m[3])})`;
                  }
                  if (m[0] === m[3] && m[1] === -m[2]) {
                    const a = Math.acos(m[0]) * 180 / Math.PI;
                    return `rotate(${pf(a)})`;
                  }
                } else {
                  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                    return `translate(${pf(m[4])} ${pf(m[5])})`;
                  }
                }
                return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
              };
              const SVG_DEFAULTS = {
                fontStyle: "normal",
                fontWeight: "normal",
                fillColor: "#000000"
              };
              const XML_NS = "http://www.w3.org/XML/1998/namespace";
              const XLINK_NS = "http://www.w3.org/1999/xlink";
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const convertImgDataToPng = function() {
                const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                const CHUNK_WRAPPER_SIZE = 12;
                const crcTable = new Int32Array(256);
                for (let i = 0; i < 256; i++) {
                  let c = i;
                  for (let h = 0; h < 8; h++) {
                    if (c & 1) {
                      c = 3988292384 ^ c >> 1 & 2147483647;
                    } else {
                      c = c >> 1 & 2147483647;
                    }
                  }
                  crcTable[i] = c;
                }
                function crc32(data, start, end) {
                  let crc = -1;
                  for (let i = start; i < end; i++) {
                    const a = (crc ^ data[i]) & 255;
                    const b = crcTable[a];
                    crc = crc >>> 8 ^ b;
                  }
                  return crc ^ -1;
                }
                function writePngChunk(type, body, data, offset) {
                  let p = offset;
                  const len = body.length;
                  data[p] = len >> 24 & 255;
                  data[p + 1] = len >> 16 & 255;
                  data[p + 2] = len >> 8 & 255;
                  data[p + 3] = len & 255;
                  p += 4;
                  data[p] = type.charCodeAt(0) & 255;
                  data[p + 1] = type.charCodeAt(1) & 255;
                  data[p + 2] = type.charCodeAt(2) & 255;
                  data[p + 3] = type.charCodeAt(3) & 255;
                  p += 4;
                  data.set(body, p);
                  p += body.length;
                  const crc = crc32(data, offset + 4, p);
                  data[p] = crc >> 24 & 255;
                  data[p + 1] = crc >> 16 & 255;
                  data[p + 2] = crc >> 8 & 255;
                  data[p + 3] = crc & 255;
                }
                function adler32(data, start, end) {
                  let a = 1;
                  let b = 0;
                  for (let i = start; i < end; ++i) {
                    a = (a + (data[i] & 255)) % 65521;
                    b = (b + a) % 65521;
                  }
                  return b << 16 | a;
                }
                function deflateSync(literals) {
                  if (!_is_node2.isNodeJS) {
                    return deflateSyncUncompressed(literals);
                  }
                  try {
                    let input;
                    if (parseInt(process.versions.node) >= 8) {
                      input = literals;
                    } else {
                      input = Buffer.from(literals);
                    }
                    const output = require_zlib().deflateSync(input, {
                      level: 9
                    });
                    return output instanceof Uint8Array ? output : new Uint8Array(output);
                  } catch (e) {
                    (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                  }
                  return deflateSyncUncompressed(literals);
                }
                function deflateSyncUncompressed(literals) {
                  let len = literals.length;
                  const maxBlockLength = 65535;
                  const deflateBlocks = Math.ceil(len / maxBlockLength);
                  const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                  let pi = 0;
                  idat[pi++] = 120;
                  idat[pi++] = 156;
                  let pos = 0;
                  while (len > maxBlockLength) {
                    idat[pi++] = 0;
                    idat[pi++] = 255;
                    idat[pi++] = 255;
                    idat[pi++] = 0;
                    idat[pi++] = 0;
                    idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                    pi += maxBlockLength;
                    pos += maxBlockLength;
                    len -= maxBlockLength;
                  }
                  idat[pi++] = 1;
                  idat[pi++] = len & 255;
                  idat[pi++] = len >> 8 & 255;
                  idat[pi++] = ~len & 65535 & 255;
                  idat[pi++] = (~len & 65535) >> 8 & 255;
                  idat.set(literals.subarray(pos), pi);
                  pi += literals.length - pos;
                  const adler = adler32(literals, 0, literals.length);
                  idat[pi++] = adler >> 24 & 255;
                  idat[pi++] = adler >> 16 & 255;
                  idat[pi++] = adler >> 8 & 255;
                  idat[pi++] = adler & 255;
                  return idat;
                }
                function encode(imgData, kind, forceDataSchema, isMask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  let bitDepth, colorType, lineSize;
                  const bytes = imgData.data;
                  switch (kind) {
                    case _util2.ImageKind.GRAYSCALE_1BPP:
                      colorType = 0;
                      bitDepth = 1;
                      lineSize = width + 7 >> 3;
                      break;
                    case _util2.ImageKind.RGB_24BPP:
                      colorType = 2;
                      bitDepth = 8;
                      lineSize = width * 3;
                      break;
                    case _util2.ImageKind.RGBA_32BPP:
                      colorType = 6;
                      bitDepth = 8;
                      lineSize = width * 4;
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  const literals = new Uint8Array((1 + lineSize) * height);
                  let offsetLiterals = 0, offsetBytes = 0;
                  for (let y = 0; y < height; ++y) {
                    literals[offsetLiterals++] = 0;
                    literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                    offsetBytes += lineSize;
                    offsetLiterals += lineSize;
                  }
                  if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                    offsetLiterals = 0;
                    for (let y = 0; y < height; y++) {
                      offsetLiterals++;
                      for (let i = 0; i < lineSize; i++) {
                        literals[offsetLiterals++] ^= 255;
                      }
                    }
                  }
                  const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                  const idat = deflateSync(literals);
                  const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                  const data = new Uint8Array(pngLength);
                  let offset = 0;
                  data.set(PNG_HEADER, offset);
                  offset += PNG_HEADER.length;
                  writePngChunk("IHDR", ihdr, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                  writePngChunk("IDATA", idat, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + idat.length;
                  writePngChunk("IEND", new Uint8Array(0), data, offset);
                  return (0, _util2.createObjectURL)(data, "image/png", forceDataSchema);
                }
                return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                  const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                  return encode(imgData, kind, forceDataSchema, isMask);
                };
              }();
              class SVGExtraState {
                constructor() {
                  this.fontSizeScale = 1;
                  this.fontWeight = SVG_DEFAULTS.fontWeight;
                  this.fontSize = 0;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textMatrixScale = 1;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                  this.fillColor = SVG_DEFAULTS.fillColor;
                  this.strokeColor = "#000000";
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.lineJoin = "";
                  this.lineCap = "";
                  this.miterLimit = 0;
                  this.dashArray = [];
                  this.dashPhase = 0;
                  this.dependencies = [];
                  this.activeClipUrl = null;
                  this.clipGroup = null;
                  this.maskId = "";
                }
                clone() {
                  return Object.create(this);
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              }
              let clipCount = 0;
              let maskCount = 0;
              let shadingCount = 0;
              exports2.SVGGraphics = SVGGraphics = class SVGGraphics {
                constructor(commonObjs, objs, forceDataSchema = false) {
                  this.svgFactory = new _display_utils2.DOMSVGFactory();
                  this.current = new SVGExtraState();
                  this.transformMatrix = _util2.IDENTITY_MATRIX;
                  this.transformStack = [];
                  this.extraStack = [];
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.embedFonts = false;
                  this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                  this.cssStyle = null;
                  this.forceDataSchema = !!forceDataSchema;
                  this._operatorIdMapping = [];
                  for (const op in _util2.OPS) {
                    this._operatorIdMapping[_util2.OPS[op]] = op;
                  }
                }
                save() {
                  this.transformStack.push(this.transformMatrix);
                  const old = this.current;
                  this.extraStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  this.transformMatrix = this.transformStack.pop();
                  this.current = this.extraStack.pop();
                  this.pendingClip = null;
                  this.tgrp = null;
                }
                group(items) {
                  this.save();
                  this.executeOpTree(items);
                  this.restore();
                }
                loadDependencies(operatorList) {
                  const fnArray = operatorList.fnArray;
                  const argsArray = operatorList.argsArray;
                  for (let i = 0, ii = fnArray.length; i < ii; i++) {
                    if (fnArray[i] !== _util2.OPS.dependency) {
                      continue;
                    }
                    for (const obj of argsArray[i]) {
                      const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                      const promise = new Promise((resolve) => {
                        objsPool.get(obj, resolve);
                      });
                      this.current.dependencies.push(promise);
                    }
                  }
                  return Promise.all(this.current.dependencies);
                }
                transform(a, b, c, d, e, f) {
                  const transformMatrix = [a, b, c, d, e, f];
                  this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                  this.tgrp = null;
                }
                getSVG(operatorList, viewport) {
                  this.viewport = viewport;
                  const svgElement = this._initialize(viewport);
                  return this.loadDependencies(operatorList).then(() => {
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.executeOpTree(this.convertOpList(operatorList));
                    return svgElement;
                  });
                }
                convertOpList(operatorList) {
                  const operatorIdMapping = this._operatorIdMapping;
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  const opList = [];
                  for (let i = 0, ii = fnArray.length; i < ii; i++) {
                    const fnId = fnArray[i];
                    opList.push({
                      fnId,
                      fn: operatorIdMapping[fnId],
                      args: argsArray[i]
                    });
                  }
                  return opListToTree(opList);
                }
                executeOpTree(opTree) {
                  for (const opTreeElement of opTree) {
                    const fn = opTreeElement.fn;
                    const fnId = opTreeElement.fnId;
                    const args = opTreeElement.args;
                    switch (fnId | 0) {
                      case _util2.OPS.beginText:
                        this.beginText();
                        break;
                      case _util2.OPS.dependency:
                        break;
                      case _util2.OPS.setLeading:
                        this.setLeading(args);
                        break;
                      case _util2.OPS.setLeadingMoveText:
                        this.setLeadingMoveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setFont:
                        this.setFont(args);
                        break;
                      case _util2.OPS.showText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.showSpacedText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.endText:
                        this.endText();
                        break;
                      case _util2.OPS.moveText:
                        this.moveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setCharSpacing:
                        this.setCharSpacing(args[0]);
                        break;
                      case _util2.OPS.setWordSpacing:
                        this.setWordSpacing(args[0]);
                        break;
                      case _util2.OPS.setHScale:
                        this.setHScale(args[0]);
                        break;
                      case _util2.OPS.setTextMatrix:
                        this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.setTextRise:
                        this.setTextRise(args[0]);
                        break;
                      case _util2.OPS.setTextRenderingMode:
                        this.setTextRenderingMode(args[0]);
                        break;
                      case _util2.OPS.setLineWidth:
                        this.setLineWidth(args[0]);
                        break;
                      case _util2.OPS.setLineJoin:
                        this.setLineJoin(args[0]);
                        break;
                      case _util2.OPS.setLineCap:
                        this.setLineCap(args[0]);
                        break;
                      case _util2.OPS.setMiterLimit:
                        this.setMiterLimit(args[0]);
                        break;
                      case _util2.OPS.setFillRGBColor:
                        this.setFillRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeRGBColor:
                        this.setStrokeRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeColorN:
                        this.setStrokeColorN(args);
                        break;
                      case _util2.OPS.setFillColorN:
                        this.setFillColorN(args);
                        break;
                      case _util2.OPS.shadingFill:
                        this.shadingFill(args[0]);
                        break;
                      case _util2.OPS.setDash:
                        this.setDash(args[0], args[1]);
                        break;
                      case _util2.OPS.setRenderingIntent:
                        this.setRenderingIntent(args[0]);
                        break;
                      case _util2.OPS.setFlatness:
                        this.setFlatness(args[0]);
                        break;
                      case _util2.OPS.setGState:
                        this.setGState(args[0]);
                        break;
                      case _util2.OPS.fill:
                        this.fill();
                        break;
                      case _util2.OPS.eoFill:
                        this.eoFill();
                        break;
                      case _util2.OPS.stroke:
                        this.stroke();
                        break;
                      case _util2.OPS.fillStroke:
                        this.fillStroke();
                        break;
                      case _util2.OPS.eoFillStroke:
                        this.eoFillStroke();
                        break;
                      case _util2.OPS.clip:
                        this.clip("nonzero");
                        break;
                      case _util2.OPS.eoClip:
                        this.clip("evenodd");
                        break;
                      case _util2.OPS.paintSolidColorImageMask:
                        this.paintSolidColorImageMask();
                        break;
                      case _util2.OPS.paintImageXObject:
                        this.paintImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintInlineImageXObject:
                        this.paintInlineImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintImageMaskXObject:
                        this.paintImageMaskXObject(args[0]);
                        break;
                      case _util2.OPS.paintFormXObjectBegin:
                        this.paintFormXObjectBegin(args[0], args[1]);
                        break;
                      case _util2.OPS.paintFormXObjectEnd:
                        this.paintFormXObjectEnd();
                        break;
                      case _util2.OPS.closePath:
                        this.closePath();
                        break;
                      case _util2.OPS.closeStroke:
                        this.closeStroke();
                        break;
                      case _util2.OPS.closeFillStroke:
                        this.closeFillStroke();
                        break;
                      case _util2.OPS.closeEOFillStroke:
                        this.closeEOFillStroke();
                        break;
                      case _util2.OPS.nextLine:
                        this.nextLine();
                        break;
                      case _util2.OPS.transform:
                        this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.constructPath:
                        this.constructPath(args[0], args[1]);
                        break;
                      case _util2.OPS.endPath:
                        this.endPath();
                        break;
                      case 92:
                        this.group(opTreeElement.items);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented operator ${fn}`);
                        break;
                    }
                  }
                }
                setWordSpacing(wordSpacing) {
                  this.current.wordSpacing = wordSpacing;
                }
                setCharSpacing(charSpacing) {
                  this.current.charSpacing = charSpacing;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                setTextMatrix(a, b, c, d, e, f) {
                  const current = this.current;
                  current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                  current.textMatrixScale = Math.hypot(a, b);
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.xcoords = [];
                  current.ycoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtElement.appendChild(current.tspan);
                }
                beginText() {
                  const current = this.current;
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.textMatrix = _util2.IDENTITY_MATRIX;
                  current.lineMatrix = _util2.IDENTITY_MATRIX;
                  current.textMatrixScale = 1;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtgrp = this.svgFactory.createElement("svg:g");
                  current.xcoords = [];
                  current.ycoords = [];
                }
                moveText(x, y) {
                  const current = this.current;
                  current.x = current.lineX += x;
                  current.y = current.lineY += y;
                  current.xcoords = [];
                  current.ycoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return;
                  }
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  let x = 0;
                  for (const glyph of glyphs) {
                    if (glyph === null) {
                      x += fontDirection * wordSpacing;
                      continue;
                    } else if ((0, _util2.isNum)(glyph)) {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      let vx;
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                      vx = -vx * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (glyph.isInFont || font.missingFile) {
                      current.xcoords.push(current.x + scaledX);
                      if (vertical) {
                        current.ycoords.push(-current.y + scaledY);
                      }
                      current.tspan.textContent += character;
                    } else {
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                  }
                  current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                  if (vertical) {
                    current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                  } else {
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                    current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                  }
                  if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                    current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                  }
                  const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                      current.tspan.setAttributeNS(null, "fill", current.fillColor);
                    }
                    if (current.fillAlpha < 1) {
                      current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    }
                  } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                    current.tspan.setAttributeNS(null, "fill", "transparent");
                  } else {
                    current.tspan.setAttributeNS(null, "fill", "none");
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    const lineWidthScale = 1 / (current.textMatrixScale || 1);
                    this._setStrokeAttributes(current.tspan, lineWidthScale);
                  }
                  let textMatrix = current.textMatrix;
                  if (current.textRise !== 0) {
                    textMatrix = textMatrix.slice();
                    textMatrix[5] += current.textRise;
                  }
                  current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                  current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                  current.txtElement.appendChild(current.tspan);
                  current.txtgrp.appendChild(current.txtElement);
                  this._ensureTransformGroup().appendChild(current.txtElement);
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                addFontStyle(fontObj) {
                  if (!fontObj.data) {
                    throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                  }
                  if (!this.cssStyle) {
                    this.cssStyle = this.svgFactory.createElement("svg:style");
                    this.cssStyle.setAttributeNS(null, "type", "text/css");
                    this.defs.appendChild(this.cssStyle);
                  }
                  const url = (0, _util2.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                  this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
                }
                setFont(details) {
                  const current = this.current;
                  const fontObj = this.commonObjs.get(details[0]);
                  let size = details[1];
                  current.font = fontObj;
                  if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                    this.addFontStyle(fontObj);
                    this.embeddedFonts[fontObj.loadedName] = fontObj;
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  current.fontSize = size;
                  current.fontFamily = fontObj.loadedName;
                  current.fontWeight = bold;
                  current.fontStyle = italic;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.xcoords = [];
                  current.ycoords = [];
                }
                endText() {
                  var _a;
                  const current = this.current;
                  if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && ((_a = current.txtElement) == null ? void 0 : _a.hasChildNodes())) {
                    current.element = current.txtElement;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                setLineWidth(width) {
                  if (width > 0) {
                    this.current.lineWidth = width;
                  }
                }
                setLineCap(style) {
                  this.current.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.current.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.current.miterLimit = limit;
                }
                setStrokeAlpha(strokeAlpha) {
                  this.current.strokeAlpha = strokeAlpha;
                }
                setStrokeRGBColor(r, g, b) {
                  this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                }
                setFillAlpha(fillAlpha) {
                  this.current.fillAlpha = fillAlpha;
                }
                setFillRGBColor(r, g, b) {
                  this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                  this.current.tspan = this.svgFactory.createElement("svg:tspan");
                  this.current.xcoords = [];
                  this.current.ycoords = [];
                }
                setStrokeColorN(args) {
                  this.current.strokeColor = this._makeColorN_Pattern(args);
                }
                setFillColorN(args) {
                  this.current.fillColor = this._makeColorN_Pattern(args);
                }
                shadingFill(args) {
                  const width = this.viewport.width;
                  const height = this.viewport.height;
                  const inv = _util2.Util.inverseTransform(this.transformMatrix);
                  const bl = _util2.Util.applyTransform([0, 0], inv);
                  const br = _util2.Util.applyTransform([0, height], inv);
                  const ul = _util2.Util.applyTransform([width, 0], inv);
                  const ur = _util2.Util.applyTransform([width, height], inv);
                  const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                  const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                  const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                  const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", x0);
                  rect.setAttributeNS(null, "y", y0);
                  rect.setAttributeNS(null, "width", x1 - x0);
                  rect.setAttributeNS(null, "height", y1 - y0);
                  rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                  if (this.current.fillAlpha < 1) {
                    rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                  }
                  this._ensureTransformGroup().appendChild(rect);
                }
                _makeColorN_Pattern(args) {
                  if (args[0] === "TilingPattern") {
                    return this._makeTilingPattern(args);
                  }
                  return this._makeShadingPattern(args);
                }
                _makeTilingPattern(args) {
                  const color = args[1];
                  const operatorList = args[2];
                  const matrix = args[3] || _util2.IDENTITY_MATRIX;
                  const [x0, y0, x1, y1] = args[4];
                  const xstep = args[5];
                  const ystep = args[6];
                  const paintType = args[7];
                  const tilingId = `shading${shadingCount++}`;
                  const [tx0, ty0] = _util2.Util.applyTransform([x0, y0], matrix);
                  const [tx1, ty1] = _util2.Util.applyTransform([x1, y1], matrix);
                  const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                  const txstep = xstep * xscale;
                  const tystep = ystep * yscale;
                  const tiling = this.svgFactory.createElement("svg:pattern");
                  tiling.setAttributeNS(null, "id", tilingId);
                  tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                  tiling.setAttributeNS(null, "width", txstep);
                  tiling.setAttributeNS(null, "height", tystep);
                  tiling.setAttributeNS(null, "x", `${tx0}`);
                  tiling.setAttributeNS(null, "y", `${ty0}`);
                  const svg = this.svg;
                  const transformMatrix = this.transformMatrix;
                  const fillColor = this.current.fillColor;
                  const strokeColor = this.current.strokeColor;
                  const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                  this.svg = bbox;
                  this.transformMatrix = matrix;
                  if (paintType === 2) {
                    const cssColor = _util2.Util.makeHexColor(...color);
                    this.current.fillColor = cssColor;
                    this.current.strokeColor = cssColor;
                  }
                  this.executeOpTree(this.convertOpList(operatorList));
                  this.svg = svg;
                  this.transformMatrix = transformMatrix;
                  this.current.fillColor = fillColor;
                  this.current.strokeColor = strokeColor;
                  tiling.appendChild(bbox.childNodes[0]);
                  this.defs.appendChild(tiling);
                  return `url(#${tilingId})`;
                }
                _makeShadingPattern(args) {
                  switch (args[0]) {
                    case "RadialAxial":
                      const shadingId = `shading${shadingCount++}`;
                      const colorStops = args[3];
                      let gradient;
                      switch (args[1]) {
                        case "axial":
                          const point0 = args[4];
                          const point1 = args[5];
                          gradient = this.svgFactory.createElement("svg:linearGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "x1", point0[0]);
                          gradient.setAttributeNS(null, "y1", point0[1]);
                          gradient.setAttributeNS(null, "x2", point1[0]);
                          gradient.setAttributeNS(null, "y2", point1[1]);
                          break;
                        case "radial":
                          const focalPoint = args[4];
                          const circlePoint = args[5];
                          const focalRadius = args[6];
                          const circleRadius = args[7];
                          gradient = this.svgFactory.createElement("svg:radialGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "cx", circlePoint[0]);
                          gradient.setAttributeNS(null, "cy", circlePoint[1]);
                          gradient.setAttributeNS(null, "r", circleRadius);
                          gradient.setAttributeNS(null, "fx", focalPoint[0]);
                          gradient.setAttributeNS(null, "fy", focalPoint[1]);
                          gradient.setAttributeNS(null, "fr", focalRadius);
                          break;
                        default:
                          throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                      }
                      for (const colorStop of colorStops) {
                        const stop = this.svgFactory.createElement("svg:stop");
                        stop.setAttributeNS(null, "offset", colorStop[0]);
                        stop.setAttributeNS(null, "stop-color", colorStop[1]);
                        gradient.appendChild(stop);
                      }
                      this.defs.appendChild(gradient);
                      return `url(#${shadingId})`;
                    case "Mesh":
                      (0, _util2.warn)("Unimplemented pattern Mesh");
                      return null;
                    case "Dummy":
                      return "hotpink";
                    default:
                      throw new Error(`Unknown IR type: ${args[0]}`);
                  }
                }
                setDash(dashArray, dashPhase) {
                  this.current.dashArray = dashArray;
                  this.current.dashPhase = dashPhase;
                }
                constructPath(ops, args) {
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let d = [];
                  let j = 0;
                  for (const op of ops) {
                    switch (op | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width = args[j++];
                        const height = args[j++];
                        const xw = x + width;
                        const yh = y + height;
                        d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("M", pf(x), pf(y));
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("L", pf(x), pf(y));
                        break;
                      case _util2.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        d.push("Z");
                        break;
                    }
                  }
                  d = d.join(" ");
                  if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                    d = current.path.getAttributeNS(null, "d") + d;
                  } else {
                    current.path = this.svgFactory.createElement("svg:path");
                    this._ensureTransformGroup().appendChild(current.path);
                  }
                  current.path.setAttributeNS(null, "d", d);
                  current.path.setAttributeNS(null, "fill", "none");
                  current.element = current.path;
                  current.setCurrentPoint(x, y);
                }
                endPath() {
                  const current = this.current;
                  current.path = null;
                  if (!this.pendingClip) {
                    return;
                  }
                  if (!current.element) {
                    this.pendingClip = null;
                    return;
                  }
                  const clipId = `clippath${clipCount++}`;
                  const clipPath = this.svgFactory.createElement("svg:clipPath");
                  clipPath.setAttributeNS(null, "id", clipId);
                  clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                  const clipElement = current.element.cloneNode(true);
                  if (this.pendingClip === "evenodd") {
                    clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                  } else {
                    clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                  }
                  this.pendingClip = null;
                  clipPath.appendChild(clipElement);
                  this.defs.appendChild(clipPath);
                  if (current.activeClipUrl) {
                    current.clipGroup = null;
                    this.extraStack.forEach(function(prev) {
                      prev.clipGroup = null;
                    });
                    clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                  }
                  current.activeClipUrl = `url(#${clipId})`;
                  this.tgrp = null;
                }
                clip(type) {
                  this.pendingClip = type;
                }
                closePath() {
                  const current = this.current;
                  if (current.path) {
                    const d = `${current.path.getAttributeNS(null, "d")}Z`;
                    current.path.setAttributeNS(null, "d", d);
                  }
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setTextRise(textRise) {
                  this.current.textRise = textRise;
                }
                setTextRenderingMode(textRenderingMode) {
                  this.current.textRenderingMode = textRenderingMode;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (const [key, value] of states) {
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value);
                        break;
                      case "CA":
                        this.setStrokeAlpha(value);
                        break;
                      case "ca":
                        this.setFillAlpha(value);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                        break;
                    }
                  }
                }
                fill() {
                  const current = this.current;
                  if (current.element) {
                    current.element.setAttributeNS(null, "fill", current.fillColor);
                    current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    this.endPath();
                  }
                }
                stroke() {
                  const current = this.current;
                  if (current.element) {
                    this._setStrokeAttributes(current.element);
                    current.element.setAttributeNS(null, "fill", "none");
                    this.endPath();
                  }
                }
                _setStrokeAttributes(element, lineWidthScale = 1) {
                  const current = this.current;
                  let dashArray = current.dashArray;
                  if (lineWidthScale !== 1 && dashArray.length > 0) {
                    dashArray = dashArray.map(function(value) {
                      return lineWidthScale * value;
                    });
                  }
                  element.setAttributeNS(null, "stroke", current.strokeColor);
                  element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                  element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                  element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                  element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                  element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                  element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                  element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                }
                eoFill() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }
                  this.fill();
                }
                fillStroke() {
                  this.stroke();
                  this.fill();
                }
                eoFillStroke() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }
                  this.fillStroke();
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.closePath();
                  this.eoFillStroke();
                }
                paintSolidColorImageMask() {
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", "1px");
                  rect.setAttributeNS(null, "height", "1px");
                  rect.setAttributeNS(null, "fill", this.current.fillColor);
                  this._ensureTransformGroup().appendChild(rect);
                }
                paintImageXObject(objId) {
                  const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintInlineImageXObject(imgData, mask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                  const cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", "0");
                  cliprect.setAttributeNS(null, "y", "0");
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  const imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-height));
                  imgEl.setAttributeNS(null, "width", pf(width) + "px");
                  imgEl.setAttributeNS(null, "height", pf(height) + "px");
                  imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                  if (mask) {
                    mask.appendChild(imgEl);
                  } else {
                    this._ensureTransformGroup().appendChild(imgEl);
                  }
                }
                paintImageMaskXObject(imgData) {
                  const current = this.current;
                  const width = imgData.width;
                  const height = imgData.height;
                  const fillColor = current.fillColor;
                  current.maskId = `mask${maskCount++}`;
                  const mask = this.svgFactory.createElement("svg:mask");
                  mask.setAttributeNS(null, "id", current.maskId);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", pf(width));
                  rect.setAttributeNS(null, "height", pf(height));
                  rect.setAttributeNS(null, "fill", fillColor);
                  rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                  this.defs.appendChild(mask);
                  this._ensureTransformGroup().appendChild(rect);
                  this.paintInlineImageXObject(imgData, mask);
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                  }
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", bbox[0]);
                    cliprect.setAttributeNS(null, "y", bbox[1]);
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                }
                _initialize(viewport) {
                  const svg = this.svgFactory.create(viewport.width, viewport.height);
                  const definitions = this.svgFactory.createElement("svg:defs");
                  svg.appendChild(definitions);
                  this.defs = definitions;
                  const rootGroup = this.svgFactory.createElement("svg:g");
                  rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                  svg.appendChild(rootGroup);
                  this.svg = rootGroup;
                  return svg;
                }
                _ensureClipGroup() {
                  if (!this.current.clipGroup) {
                    const clipGroup = this.svgFactory.createElement("svg:g");
                    clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                    this.svg.appendChild(clipGroup);
                    this.current.clipGroup = clipGroup;
                  }
                  return this.current.clipGroup;
                }
                _ensureTransformGroup() {
                  if (!this.tgrp) {
                    this.tgrp = this.svgFactory.createElement("svg:g");
                    this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    if (this.current.activeClipUrl) {
                      this._ensureClipGroup().appendChild(this.tgrp);
                    } else {
                      this.svg.appendChild(this.tgrp);
                    }
                  }
                  return this.tgrp;
                }
              };
            }
          },
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.XfaLayer = void 0;
            class XfaLayer {
              static setAttributes(html, attrs) {
                for (const [key, value] of Object.entries(attrs)) {
                  if (value === null || value === void 0) {
                    continue;
                  }
                  if (key !== "style") {
                    html.setAttribute(key, value);
                  } else {
                    Object.assign(html.style, value);
                  }
                }
              }
              static render(parameters) {
                const root = parameters.xfa;
                const rootHtml = document.createElement(root.name);
                if (root.attributes) {
                  XfaLayer.setAttributes(rootHtml, root.attributes);
                }
                const stack = [[root, -1, rootHtml]];
                const rootDiv = parameters.div;
                rootDiv.appendChild(rootHtml);
                const coeffs = parameters.viewport.transform.join(",");
                rootDiv.style.transform = `matrix(${coeffs})`;
                rootDiv.setAttribute("class", "xfaLayer xfaFont");
                while (stack.length > 0) {
                  const [parent, i, html] = stack[stack.length - 1];
                  if (i + 1 === parent.children.length) {
                    stack.pop();
                    continue;
                  }
                  const child = parent.children[++stack[stack.length - 1][1]];
                  if (child === null) {
                    continue;
                  }
                  const {
                    name
                  } = child;
                  if (name === "#text") {
                    html.appendChild(document.createTextNode(child.value));
                    continue;
                  }
                  const childHtml = document.createElement(name);
                  html.appendChild(childHtml);
                  if (child.attributes) {
                    XfaLayer.setAttributes(childHtml, child.attributes);
                  }
                  if (child.children && child.children.length > 0) {
                    stack.push([child, -1, childHtml]);
                  } else if (child.value) {
                    childHtml.appendChild(document.createTextNode(child.value));
                  }
                }
              }
              static update(parameters) {
                const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                parameters.div.style.transform = transform;
                parameters.div.hidden = false;
              }
            }
            exports2.XfaLayer = XfaLayer;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNodeStream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _network_utils = __w_pdfjs_require__2(24);
            ;
            const fs = require_fs();
            const http = require_http();
            const https = require_https();
            const url = require_url();
            const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
            function parseUrl(sourceUrl) {
              const parsedUrl = url.parse(sourceUrl);
              if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                return parsedUrl;
              }
              if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                return url.parse(`file:///${sourceUrl}`);
              }
              if (!parsedUrl.host) {
                parsedUrl.protocol = "file:";
              }
              return parsedUrl;
            }
            class PDFNodeStream {
              constructor(source) {
                this.source = source;
                this.url = parseUrl(source.url);
                this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                this.isFsUrl = this.url.protocol === "file:";
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                var _a, _b;
                return (_b = (_a = this._fullRequestReader) == null ? void 0 : _a._loaded) != null ? _b : 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(start, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                this._rangeRequestReaders.push(rangeReader);
                return rangeReader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.PDFNodeStream = PDFNodeStream;
            class BaseFullReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                const source = stream.source;
                this._contentLength = source.length;
                this._loaded = 0;
                this._filename = null;
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._headersCapability = (0, _util2.createPromiseCapability)();
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              read() {
                return __async(this, null, function* () {
                  yield this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                });
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (!this._isStreamingSupported && this._isRangeSupported) {
                  this._error(new _util2.AbortException("streaming is disabled"));
                }
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }
            class BaseRangeReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                this._loaded = 0;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                const source = stream.source;
                this._isStreamingSupported = !source.disableStream;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              read() {
                return __async(this, null, function* () {
                  yield this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                });
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }
            function createRequestOptions(parsedUrl, headers) {
              return {
                protocol: parsedUrl.protocol,
                auth: parsedUrl.auth,
                host: parsedUrl.hostname,
                port: parsedUrl.port,
                path: parsedUrl.path,
                method: "GET",
                headers
              };
            }
            class PDFNodeStreamFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                const handleResponse = (response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._headersCapability.resolve();
                  this._setReadableStream(response);
                  const getResponseHeader = (name) => {
                    return this._readableStream.headers[name.toLowerCase()];
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                };
                this._request = null;
                if (this._url.protocol === "http:") {
                  this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                } else {
                  this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                  this._headersCapability.reject(reason);
                });
                this._request.end();
              }
            }
            class PDFNodeStreamRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                this._httpHeaders = {};
                for (const property in stream.httpHeaders) {
                  const value = stream.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  this._httpHeaders[property] = value;
                }
                this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
                const handleResponse = (response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    return;
                  }
                  this._setReadableStream(response);
                };
                this._request = null;
                if (this._url.protocol === "http:") {
                  this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                } else {
                  this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                });
                this._request.end();
              }
            }
            class PDFNodeStreamFsFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                fs.lstat(path, (error, stat) => {
                  if (error) {
                    if (error.code === "ENOENT") {
                      error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                    }
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._contentLength = stat.size;
                  this._setReadableStream(fs.createReadStream(path));
                  this._headersCapability.resolve();
                });
              }
            }
            class PDFNodeStreamFsRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                this._setReadableStream(fs.createReadStream(path, {
                  start,
                  end: end - 1
                }));
              }
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.createResponseStatusError = createResponseStatusError;
            exports2.extractFilenameFromHeader = extractFilenameFromHeader;
            exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
            exports2.validateResponseStatus = validateResponseStatus;
            var _util2 = __w_pdfjs_require__2(2);
            var _content_disposition = __w_pdfjs_require__2(25);
            var _display_utils2 = __w_pdfjs_require__2(1);
            function validateRangeRequestCapabilities({
              getResponseHeader,
              isHttp,
              rangeChunkSize,
              disableRange
            }) {
              (0, _util2.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
              const returnValues = {
                allowRangeRequests: false,
                suggestedLength: void 0
              };
              const length = parseInt(getResponseHeader("Content-Length"), 10);
              if (!Number.isInteger(length)) {
                return returnValues;
              }
              returnValues.suggestedLength = length;
              if (length <= 2 * rangeChunkSize) {
                return returnValues;
              }
              if (disableRange || !isHttp) {
                return returnValues;
              }
              if (getResponseHeader("Accept-Ranges") !== "bytes") {
                return returnValues;
              }
              const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
              if (contentEncoding !== "identity") {
                return returnValues;
              }
              returnValues.allowRangeRequests = true;
              return returnValues;
            }
            function extractFilenameFromHeader(getResponseHeader) {
              const contentDisposition = getResponseHeader("Content-Disposition");
              if (contentDisposition) {
                let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                if (filename.includes("%")) {
                  try {
                    filename = decodeURIComponent(filename);
                  } catch (ex) {
                  }
                }
                if ((0, _display_utils2.isPdfFile)(filename)) {
                  return filename;
                }
              }
              return null;
            }
            function createResponseStatusError(status, url) {
              if (status === 404 || status === 0 && url.startsWith("file:")) {
                return new _util2.MissingPDFException('Missing PDF "' + url + '".');
              }
              return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
            }
            function validateResponseStatus(status) {
              return status === 200 || status === 206;
            }
          },
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
            function getFilenameFromContentDispositionHeader(contentDisposition) {
              let needsEncodingFixup = true;
              let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = unescape(filename);
                filename = rfc5987decode(filename);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              tmp = rfc2231getparam(contentDisposition);
              if (tmp) {
                const filename = rfc2047decode(tmp);
                return fixupEncoding(filename);
              }
              tmp = toParamRegExp("filename", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              function toParamRegExp(attributePattern, flags) {
                return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
              }
              function textdecode(encoding, value) {
                if (encoding) {
                  if (!/^[\x00-\xFF]+$/.test(value)) {
                    return value;
                  }
                  try {
                    const decoder = new TextDecoder(encoding, {
                      fatal: true
                    });
                    const bytes = Array.from(value, function(ch) {
                      return ch.charCodeAt(0) & 255;
                    });
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                  } catch (e) {
                    if (/^utf-?8$/i.test(encoding)) {
                      try {
                        value = decodeURIComponent(escape(value));
                        needsEncodingFixup = false;
                      } catch (err) {
                      }
                    }
                  }
                }
                return value;
              }
              function fixupEncoding(value) {
                if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                  value = textdecode("utf-8", value);
                  if (needsEncodingFixup) {
                    value = textdecode("iso-8859-1", value);
                  }
                }
                return value;
              }
              function rfc2231getparam(contentDispositionStr) {
                const matches = [];
                let match;
                const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                while ((match = iter.exec(contentDispositionStr)) !== null) {
                  let [, n, quot, part] = match;
                  n = parseInt(n, 10);
                  if (n in matches) {
                    if (n === 0) {
                      break;
                    }
                    continue;
                  }
                  matches[n] = [quot, part];
                }
                const parts = [];
                for (let n = 0; n < matches.length; ++n) {
                  if (!(n in matches)) {
                    break;
                  }
                  let [quot, part] = matches[n];
                  part = rfc2616unquote(part);
                  if (quot) {
                    part = unescape(part);
                    if (n === 0) {
                      part = rfc5987decode(part);
                    }
                  }
                  parts.push(part);
                }
                return parts.join("");
              }
              function rfc2616unquote(value) {
                if (value.startsWith('"')) {
                  const parts = value.slice(1).split('\\"');
                  for (let i = 0; i < parts.length; ++i) {
                    const quotindex = parts[i].indexOf('"');
                    if (quotindex !== -1) {
                      parts[i] = parts[i].slice(0, quotindex);
                      parts.length = i + 1;
                    }
                    parts[i] = parts[i].replace(/\\(.)/g, "$1");
                  }
                  value = parts.join('"');
                }
                return value;
              }
              function rfc5987decode(extvalue) {
                const encodingend = extvalue.indexOf("'");
                if (encodingend === -1) {
                  return extvalue;
                }
                const encoding = extvalue.slice(0, encodingend);
                const langvalue = extvalue.slice(encodingend + 1);
                const value = langvalue.replace(/^[^']*'/, "");
                return textdecode(encoding, value);
              }
              function rfc2047decode(value) {
                if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                  return value;
                }
                return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                  if (encoding === "q" || encoding === "Q") {
                    text = text.replace(/_/g, " ");
                    text = text.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                      return String.fromCharCode(parseInt(hex, 16));
                    });
                    return textdecode(charset, text);
                  }
                  try {
                    text = atob(text);
                  } catch (e) {
                  }
                  return textdecode(charset, text);
                });
              }
              return "";
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNetworkStream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _network_utils = __w_pdfjs_require__2(24);
            ;
            const OK_RESPONSE = 200;
            const PARTIAL_CONTENT_RESPONSE = 206;
            function getArrayBuffer(xhr) {
              const data = xhr.response;
              if (typeof data !== "string") {
                return data;
              }
              const array = (0, _util2.stringToBytes)(data);
              return array.buffer;
            }
            class NetworkManager {
              constructor(url, args) {
                this.url = url;
                args = args || {};
                this.isHttp = /^https?:/i.test(url);
                this.httpHeaders = this.isHttp && args.httpHeaders || {};
                this.withCredentials = args.withCredentials || false;
                this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                  return new XMLHttpRequest();
                };
                this.currXhrId = 0;
                this.pendingRequests = /* @__PURE__ */ Object.create(null);
              }
              requestRange(begin, end, listeners) {
                const args = {
                  begin,
                  end
                };
                for (const prop in listeners) {
                  args[prop] = listeners[prop];
                }
                return this.request(args);
              }
              requestFull(listeners) {
                return this.request(listeners);
              }
              request(args) {
                const xhr = this.getXhr();
                const xhrId = this.currXhrId++;
                const pendingRequest = this.pendingRequests[xhrId] = {
                  xhr
                };
                xhr.open("GET", this.url);
                xhr.withCredentials = this.withCredentials;
                for (const property in this.httpHeaders) {
                  const value = this.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  xhr.setRequestHeader(property, value);
                }
                if (this.isHttp && "begin" in args && "end" in args) {
                  xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                  pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                } else {
                  pendingRequest.expectedStatus = OK_RESPONSE;
                }
                xhr.responseType = "arraybuffer";
                if (args.onError) {
                  xhr.onerror = function(evt) {
                    args.onError(xhr.status);
                  };
                }
                xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                xhr.onprogress = this.onProgress.bind(this, xhrId);
                pendingRequest.onHeadersReceived = args.onHeadersReceived;
                pendingRequest.onDone = args.onDone;
                pendingRequest.onError = args.onError;
                pendingRequest.onProgress = args.onProgress;
                xhr.send(null);
                return xhrId;
              }
              onProgress(xhrId, evt) {
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                if (pendingRequest.onProgress) {
                  pendingRequest.onProgress(evt);
                }
              }
              onStateChange(xhrId, evt) {
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                const xhr = pendingRequest.xhr;
                if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                  pendingRequest.onHeadersReceived();
                  delete pendingRequest.onHeadersReceived;
                }
                if (xhr.readyState !== 4) {
                  return;
                }
                if (!(xhrId in this.pendingRequests)) {
                  return;
                }
                delete this.pendingRequests[xhrId];
                if (xhr.status === 0 && this.isHttp) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                const xhrStatus = xhr.status || OK_RESPONSE;
                const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                const chunk = getArrayBuffer(xhr);
                if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                  const rangeHeader = xhr.getResponseHeader("Content-Range");
                  const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                  pendingRequest.onDone({
                    begin: parseInt(matches[1], 10),
                    chunk
                  });
                } else if (chunk) {
                  pendingRequest.onDone({
                    begin: 0,
                    chunk
                  });
                } else if (pendingRequest.onError) {
                  pendingRequest.onError(xhr.status);
                }
              }
              getRequestXhr(xhrId) {
                return this.pendingRequests[xhrId].xhr;
              }
              isPendingRequest(xhrId) {
                return xhrId in this.pendingRequests;
              }
              abortRequest(xhrId) {
                const xhr = this.pendingRequests[xhrId].xhr;
                delete this.pendingRequests[xhrId];
                xhr.abort();
              }
            }
            class PDFNetworkStream {
              constructor(source) {
                this._source = source;
                this._manager = new NetworkManager(source.url, {
                  httpHeaders: source.httpHeaders,
                  withCredentials: source.withCredentials
                });
                this._rangeChunkSize = source.rangeChunkSize;
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _onRangeRequestReaderClosed(reader) {
                const i = this._rangeRequestReaders.indexOf(reader);
                if (i >= 0) {
                  this._rangeRequestReaders.splice(i, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.PDFNetworkStream = PDFNetworkStream;
            class PDFNetworkStreamFullRequestReader {
              constructor(manager, source) {
                this._manager = manager;
                const args = {
                  onHeadersReceived: this._onHeadersReceived.bind(this),
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = source.url;
                this._fullRequestId = manager.requestFull(args);
                this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._contentLength = source.length;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = false;
                this._isRangeSupported = false;
                this._cachedChunks = [];
                this._requests = [];
                this._done = false;
                this._storedError = void 0;
                this._filename = null;
                this.onProgress = null;
              }
              _onHeadersReceived() {
                const fullRequestXhrId = this._fullRequestId;
                const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                const getResponseHeader = (name) => {
                  return fullRequestXhr.getResponseHeader(name);
                };
                const {
                  allowRangeRequests,
                  suggestedLength
                } = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader,
                  isHttp: this._manager.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                if (allowRangeRequests) {
                  this._isRangeSupported = true;
                }
                this._contentLength = suggestedLength || this._contentLength;
                this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                if (this._isRangeSupported) {
                  this._manager.abortRequest(fullRequestXhrId);
                }
                this._headersReceivedCapability.resolve();
              }
              _onDone(args) {
                if (args) {
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: args.chunk,
                      done: false
                    });
                  } else {
                    this._cachedChunks.push(args.chunk);
                  }
                }
                this._done = true;
                if (this._cachedChunks.length > 0) {
                  return;
                }
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
              }
              _onError(status) {
                const url = this._url;
                const exception = (0, _network_utils.createResponseStatusError)(status, url);
                this._storedError = exception;
                this._headersReceivedCapability.reject(exception);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.reject(exception);
                });
                this._requests = [];
                this._cachedChunks = [];
              }
              _onProgress(data) {
                if (this.onProgress) {
                  this.onProgress({
                    loaded: data.loaded,
                    total: data.lengthComputable ? data.total : this._contentLength
                  });
                }
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              get contentLength() {
                return this._contentLength;
              }
              get headersReady() {
                return this._headersReceivedCapability.promise;
              }
              read() {
                return __async(this, null, function* () {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._cachedChunks.length > 0) {
                    const chunk = this._cachedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                });
              }
              cancel(reason) {
                this._done = true;
                this._headersReceivedCapability.reject(reason);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._fullRequestId)) {
                  this._manager.abortRequest(this._fullRequestId);
                }
                this._fullRequestReader = null;
              }
            }
            class PDFNetworkStreamRangeRequestReader {
              constructor(manager, begin, end) {
                this._manager = manager;
                const args = {
                  onDone: this._onDone.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._requestId = manager.requestRange(begin, end, args);
                this._requests = [];
                this._queuedChunk = null;
                this._done = false;
                this.onProgress = null;
                this.onClosed = null;
              }
              _close() {
                if (this.onClosed) {
                  this.onClosed(this);
                }
              }
              _onDone(data) {
                const chunk = data.chunk;
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunk = chunk;
                }
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                this._close();
              }
              _onProgress(evt) {
                if (!this.isStreamingSupported && this.onProgress) {
                  this.onProgress({
                    loaded: evt.loaded
                  });
                }
              }
              get isStreamingSupported() {
                return false;
              }
              read() {
                return __async(this, null, function* () {
                  if (this._queuedChunk !== null) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                });
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._requestId)) {
                  this._manager.abortRequest(this._requestId);
                }
                this._close();
              }
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFFetchStream = void 0;
            var _util2 = __w_pdfjs_require__2(2);
            var _network_utils = __w_pdfjs_require__2(24);
            ;
            function createFetchOptions(headers, withCredentials, abortController) {
              return {
                method: "GET",
                headers,
                signal: abortController == null ? void 0 : abortController.signal,
                mode: "cors",
                credentials: withCredentials ? "include" : "same-origin",
                redirect: "follow"
              };
            }
            function createHeaders(httpHeaders) {
              const headers = new Headers();
              for (const property in httpHeaders) {
                const value = httpHeaders[property];
                if (typeof value === "undefined") {
                  continue;
                }
                headers.append(property, value);
              }
              return headers;
            }
            class PDFFetchStream {
              constructor(source) {
                this.source = source;
                this.isHttp = /^https?:/i.test(source.url);
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                var _a, _b;
                return (_b = (_a = this._fullRequestReader) == null ? void 0 : _a._loaded) != null ? _b : 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                this._fullRequestReader = new PDFFetchStreamReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFFetchStreamRangeReader(this, begin, end);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.PDFFetchStream = PDFFetchStream;
            class PDFFetchStreamReader {
              constructor(stream) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                this._filename = null;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._contentLength = source.length;
                this._headersCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._headers = createHeaders(this._stream.httpHeaders);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._reader = response.body.getReader();
                  this._headersCapability.resolve();
                  const getResponseHeader = (name) => {
                    return response.headers.get(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this.cancel(new _util2.AbortException("Streaming is disabled."));
                  }
                }).catch(this._headersCapability.reject);
                this.onProgress = null;
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              read() {
                return __async(this, null, function* () {
                  yield this._headersCapability.promise;
                  const {
                    value,
                    done
                  } = yield this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(value).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                });
              }
              cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }
                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }
            class PDFFetchStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._isStreamingSupported = !source.disableStream;
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._headers = createHeaders(this._stream.httpHeaders);
                this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._readCapability.resolve();
                  this._reader = response.body.getReader();
                }).catch((reason) => {
                  if ((reason == null ? void 0 : reason.name) === "AbortError") {
                    return;
                  }
                  throw reason;
                });
                this.onProgress = null;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              read() {
                return __async(this, null, function* () {
                  yield this._readCapability.promise;
                  const {
                    value,
                    done
                  } = yield this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(value).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                });
              }
              cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }
                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }
          }
        ];
        var __webpack_module_cache__ = {};
        function __w_pdfjs_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            exports: {}
          };
          __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
          return module2.exports;
        }
        var __webpack_exports__ = {};
        (() => {
          var exports2 = __webpack_exports__;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          Object.defineProperty(exports2, "addLinkAttributes", {
            enumerable: true,
            get: function() {
              return _display_utils2.addLinkAttributes;
            }
          });
          Object.defineProperty(exports2, "getFilenameFromUrl", {
            enumerable: true,
            get: function() {
              return _display_utils2.getFilenameFromUrl;
            }
          });
          Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
            enumerable: true,
            get: function() {
              return _display_utils2.getPdfFilenameFromUrl;
            }
          });
          Object.defineProperty(exports2, "isPdfFile", {
            enumerable: true,
            get: function() {
              return _display_utils2.isPdfFile;
            }
          });
          Object.defineProperty(exports2, "LinkTarget", {
            enumerable: true,
            get: function() {
              return _display_utils2.LinkTarget;
            }
          });
          Object.defineProperty(exports2, "loadScript", {
            enumerable: true,
            get: function() {
              return _display_utils2.loadScript;
            }
          });
          Object.defineProperty(exports2, "PDFDateString", {
            enumerable: true,
            get: function() {
              return _display_utils2.PDFDateString;
            }
          });
          Object.defineProperty(exports2, "RenderingCancelledException", {
            enumerable: true,
            get: function() {
              return _display_utils2.RenderingCancelledException;
            }
          });
          Object.defineProperty(exports2, "build", {
            enumerable: true,
            get: function() {
              return _api.build;
            }
          });
          Object.defineProperty(exports2, "getDocument", {
            enumerable: true,
            get: function() {
              return _api.getDocument;
            }
          });
          Object.defineProperty(exports2, "LoopbackPort", {
            enumerable: true,
            get: function() {
              return _api.LoopbackPort;
            }
          });
          Object.defineProperty(exports2, "PDFDataRangeTransport", {
            enumerable: true,
            get: function() {
              return _api.PDFDataRangeTransport;
            }
          });
          Object.defineProperty(exports2, "PDFWorker", {
            enumerable: true,
            get: function() {
              return _api.PDFWorker;
            }
          });
          Object.defineProperty(exports2, "version", {
            enumerable: true,
            get: function() {
              return _api.version;
            }
          });
          Object.defineProperty(exports2, "CMapCompressionType", {
            enumerable: true,
            get: function() {
              return _util2.CMapCompressionType;
            }
          });
          Object.defineProperty(exports2, "createObjectURL", {
            enumerable: true,
            get: function() {
              return _util2.createObjectURL;
            }
          });
          Object.defineProperty(exports2, "createPromiseCapability", {
            enumerable: true,
            get: function() {
              return _util2.createPromiseCapability;
            }
          });
          Object.defineProperty(exports2, "createValidAbsoluteUrl", {
            enumerable: true,
            get: function() {
              return _util2.createValidAbsoluteUrl;
            }
          });
          Object.defineProperty(exports2, "InvalidPDFException", {
            enumerable: true,
            get: function() {
              return _util2.InvalidPDFException;
            }
          });
          Object.defineProperty(exports2, "MissingPDFException", {
            enumerable: true,
            get: function() {
              return _util2.MissingPDFException;
            }
          });
          Object.defineProperty(exports2, "OPS", {
            enumerable: true,
            get: function() {
              return _util2.OPS;
            }
          });
          Object.defineProperty(exports2, "PasswordResponses", {
            enumerable: true,
            get: function() {
              return _util2.PasswordResponses;
            }
          });
          Object.defineProperty(exports2, "PermissionFlag", {
            enumerable: true,
            get: function() {
              return _util2.PermissionFlag;
            }
          });
          Object.defineProperty(exports2, "removeNullCharacters", {
            enumerable: true,
            get: function() {
              return _util2.removeNullCharacters;
            }
          });
          Object.defineProperty(exports2, "shadow", {
            enumerable: true,
            get: function() {
              return _util2.shadow;
            }
          });
          Object.defineProperty(exports2, "UnexpectedResponseException", {
            enumerable: true,
            get: function() {
              return _util2.UnexpectedResponseException;
            }
          });
          Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
            enumerable: true,
            get: function() {
              return _util2.UNSUPPORTED_FEATURES;
            }
          });
          Object.defineProperty(exports2, "Util", {
            enumerable: true,
            get: function() {
              return _util2.Util;
            }
          });
          Object.defineProperty(exports2, "VerbosityLevel", {
            enumerable: true,
            get: function() {
              return _util2.VerbosityLevel;
            }
          });
          Object.defineProperty(exports2, "AnnotationLayer", {
            enumerable: true,
            get: function() {
              return _annotation_layer.AnnotationLayer;
            }
          });
          Object.defineProperty(exports2, "apiCompatibilityParams", {
            enumerable: true,
            get: function() {
              return _api_compatibility2.apiCompatibilityParams;
            }
          });
          Object.defineProperty(exports2, "GlobalWorkerOptions", {
            enumerable: true,
            get: function() {
              return _worker_options2.GlobalWorkerOptions;
            }
          });
          Object.defineProperty(exports2, "renderTextLayer", {
            enumerable: true,
            get: function() {
              return _text_layer.renderTextLayer;
            }
          });
          Object.defineProperty(exports2, "SVGGraphics", {
            enumerable: true,
            get: function() {
              return _svg.SVGGraphics;
            }
          });
          Object.defineProperty(exports2, "XfaLayer", {
            enumerable: true,
            get: function() {
              return _xfa_layer.XfaLayer;
            }
          });
          var _display_utils2 = __w_pdfjs_require__(1);
          var _api = __w_pdfjs_require__(5);
          var _util2 = __w_pdfjs_require__(2);
          var _annotation_layer = __w_pdfjs_require__(18);
          var _api_compatibility2 = __w_pdfjs_require__(9);
          var _worker_options2 = __w_pdfjs_require__(12);
          var _text_layer = __w_pdfjs_require__(20);
          var _svg = __w_pdfjs_require__(21);
          var _xfa_layer = __w_pdfjs_require__(22);
          const pdfjsVersion = "2.8.335";
          const pdfjsBuild = "228adbf67";
          {
            const {
              isNodeJS
            } = __w_pdfjs_require__(4);
            if (isNodeJS) {
              const PDFNodeStream = __w_pdfjs_require__(23).PDFNodeStream;
              (0, _api.setPDFNetworkStreamFactory)((params) => {
                return new PDFNodeStream(params);
              });
            } else {
              const PDFNetworkStream = __w_pdfjs_require__(26).PDFNetworkStream;
              let PDFFetchStream;
              if ((0, _display_utils2.isFetchSupported)()) {
                PDFFetchStream = __w_pdfjs_require__(27).PDFFetchStream;
              }
              (0, _api.setPDFNetworkStreamFactory)((params) => {
                if (PDFFetchStream && (0, _display_utils2.isValidFetchUrl)(params.url)) {
                  return new PDFFetchStream(params);
                }
                return new PDFNetworkStream(params);
              });
            }
          }
        })();
        return __webpack_exports__;
      })();
    });
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range2 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range2;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/pdfjs-dist/legacy/build/pdf.js
var require_pdf2 = __commonJS({
  "node_modules/pdfjs-dist/legacy/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(exports, function() {
      return (() => {
        var __webpack_modules__ = [
          ,
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.addLinkAttributes = addLinkAttributes;
            exports2.deprecated = deprecated;
            exports2.getFilenameFromUrl = getFilenameFromUrl;
            exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
            exports2.isDataScheme = isDataScheme;
            exports2.isFetchSupported = isFetchSupported;
            exports2.isPdfFile = isPdfFile;
            exports2.isValidFetchUrl = isValidFetchUrl;
            exports2.loadScript = loadScript;
            exports2.StatTimer = exports2.RenderingCancelledException = exports2.PDFDateString = exports2.PageViewport = exports2.LinkTarget = exports2.DOMSVGFactory = exports2.DOMCMapReaderFactory = exports2.DOMCanvasFactory = exports2.DEFAULT_LINK_REL = exports2.BaseCMapReaderFactory = exports2.BaseCanvasFactory = void 0;
            var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(2));
            var _util2 = __w_pdfjs_require__2(4);
            function _interopRequireDefault2(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function _createForOfIteratorHelper2(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e) {
                    throw _e;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e2) {
                didErr = true;
                err = _e2;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator2(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
            exports2.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
            var SVG_NS = "http://www.w3.org/2000/svg";
            var BaseCanvasFactory = /* @__PURE__ */ function() {
              function BaseCanvasFactory2() {
                _classCallCheck2(this, BaseCanvasFactory2);
                if (this.constructor === BaseCanvasFactory2) {
                  (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                }
              }
              _createClass2(BaseCanvasFactory2, [{
                key: "create",
                value: function create(width, height) {
                  (0, _util2.unreachable)("Abstract method `create` called.");
                }
              }, {
                key: "reset",
                value: function reset(canvasAndContext, width, height) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width;
                  canvasAndContext.canvas.height = height;
                }
              }, {
                key: "destroy",
                value: function destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
              }]);
              return BaseCanvasFactory2;
            }();
            exports2.BaseCanvasFactory = BaseCanvasFactory;
            var DOMCanvasFactory = /* @__PURE__ */ function(_BaseCanvasFactory) {
              _inherits(DOMCanvasFactory2, _BaseCanvasFactory);
              var _super = _createSuper(DOMCanvasFactory2);
              function DOMCanvasFactory2() {
                var _this;
                var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$ownerDocument = _ref.ownerDocument, ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;
                _classCallCheck2(this, DOMCanvasFactory2);
                _this = _super.call(this);
                _this._document = ownerDocument;
                return _this;
              }
              _createClass2(DOMCanvasFactory2, [{
                key: "create",
                value: function create(width, height) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  var canvas = this._document.createElement("canvas");
                  var context = canvas.getContext("2d");
                  canvas.width = width;
                  canvas.height = height;
                  return {
                    canvas,
                    context
                  };
                }
              }]);
              return DOMCanvasFactory2;
            }(BaseCanvasFactory);
            exports2.DOMCanvasFactory = DOMCanvasFactory;
            var BaseCMapReaderFactory = /* @__PURE__ */ function() {
              function BaseCMapReaderFactory2(_ref2) {
                var _ref2$baseUrl = _ref2.baseUrl, baseUrl = _ref2$baseUrl === void 0 ? null : _ref2$baseUrl, _ref2$isCompressed = _ref2.isCompressed, isCompressed = _ref2$isCompressed === void 0 ? false : _ref2$isCompressed;
                _classCallCheck2(this, BaseCMapReaderFactory2);
                if (this.constructor === BaseCMapReaderFactory2) {
                  (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                }
                this.baseUrl = baseUrl;
                this.isCompressed = isCompressed;
              }
              _createClass2(BaseCMapReaderFactory2, [{
                key: "fetch",
                value: function() {
                  var _fetch = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2(_ref3) {
                    var _this2 = this;
                    var name, url, compressionType;
                    return _regenerator2["default"].wrap(function _callee$2(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            name = _ref3.name;
                            if (this.baseUrl) {
                              _context2.next = 3;
                              break;
                            }
                            throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                          case 3:
                            if (name) {
                              _context2.next = 5;
                              break;
                            }
                            throw new Error("CMap name must be specified.");
                          case 5:
                            url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                            compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                            return _context2.abrupt("return", this._fetchData(url, compressionType)["catch"](function(reason) {
                              throw new Error("Unable to load ".concat(_this2.isCompressed ? "binary " : "", "CMap at: ").concat(url));
                            }));
                          case 8:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function fetch2(_x) {
                    return _fetch.apply(this, arguments);
                  }
                  return fetch2;
                }()
              }, {
                key: "_fetchData",
                value: function _fetchData(url, compressionType) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }]);
              return BaseCMapReaderFactory2;
            }();
            exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
            var DOMCMapReaderFactory = /* @__PURE__ */ function(_BaseCMapReaderFactor) {
              _inherits(DOMCMapReaderFactory2, _BaseCMapReaderFactor);
              var _super2 = _createSuper(DOMCMapReaderFactory2);
              function DOMCMapReaderFactory2() {
                _classCallCheck2(this, DOMCMapReaderFactory2);
                return _super2.apply(this, arguments);
              }
              _createClass2(DOMCMapReaderFactory2, [{
                key: "_fetchData",
                value: function _fetchData(url, compressionType) {
                  var _this3 = this;
                  if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {
                    return fetch(url).then(/* @__PURE__ */ function() {
                      var _ref4 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2(response) {
                        var cMapData;
                        return _regenerator2["default"].wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                if (response.ok) {
                                  _context2.next = 2;
                                  break;
                                }
                                throw new Error(response.statusText);
                              case 2:
                                if (!_this3.isCompressed) {
                                  _context2.next = 10;
                                  break;
                                }
                                _context2.t0 = Uint8Array;
                                _context2.next = 6;
                                return response.arrayBuffer();
                              case 6:
                                _context2.t1 = _context2.sent;
                                cMapData = new _context2.t0(_context2.t1);
                                _context2.next = 15;
                                break;
                              case 10:
                                _context2.t2 = _util2.stringToBytes;
                                _context2.next = 13;
                                return response.text();
                              case 13:
                                _context2.t3 = _context2.sent;
                                cMapData = (0, _context2.t2)(_context2.t3);
                              case 15:
                                return _context2.abrupt("return", {
                                  cMapData,
                                  compressionType
                                });
                              case 16:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2);
                      }));
                      return function(_x2) {
                        return _ref4.apply(this, arguments);
                      };
                    }());
                  }
                  return new Promise(function(resolve, reject) {
                    var request = new XMLHttpRequest();
                    request.open("GET", url, true);
                    if (_this3.isCompressed) {
                      request.responseType = "arraybuffer";
                    }
                    request.onreadystatechange = function() {
                      if (request.readyState !== XMLHttpRequest.DONE) {
                        return;
                      }
                      if (request.status === 200 || request.status === 0) {
                        var cMapData;
                        if (_this3.isCompressed && request.response) {
                          cMapData = new Uint8Array(request.response);
                        } else if (!_this3.isCompressed && request.responseText) {
                          cMapData = (0, _util2.stringToBytes)(request.responseText);
                        }
                        if (cMapData) {
                          resolve({
                            cMapData,
                            compressionType
                          });
                          return;
                        }
                      }
                      reject(new Error(request.statusText));
                    };
                    request.send(null);
                  });
                }
              }]);
              return DOMCMapReaderFactory2;
            }(BaseCMapReaderFactory);
            exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
            var DOMSVGFactory = /* @__PURE__ */ function() {
              function DOMSVGFactory2() {
                _classCallCheck2(this, DOMSVGFactory2);
              }
              _createClass2(DOMSVGFactory2, [{
                key: "create",
                value: function create(width, height) {
                  (0, _util2.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
                  var svg = document.createElementNS(SVG_NS, "svg:svg");
                  svg.setAttribute("version", "1.1");
                  svg.setAttribute("width", width + "px");
                  svg.setAttribute("height", height + "px");
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", "0 0 " + width + " " + height);
                  return svg;
                }
              }, {
                key: "createElement",
                value: function createElement(type) {
                  (0, _util2.assert)(typeof type === "string", "Invalid SVG element type");
                  return document.createElementNS(SVG_NS, type);
                }
              }]);
              return DOMSVGFactory2;
            }();
            exports2.DOMSVGFactory = DOMSVGFactory;
            var PageViewport = /* @__PURE__ */ function() {
              function PageViewport2(_ref5) {
                var viewBox = _ref5.viewBox, scale = _ref5.scale, rotation = _ref5.rotation, _ref5$offsetX = _ref5.offsetX, offsetX = _ref5$offsetX === void 0 ? 0 : _ref5$offsetX, _ref5$offsetY = _ref5.offsetY, offsetY = _ref5$offsetY === void 0 ? 0 : _ref5$offsetY, _ref5$dontFlip = _ref5.dontFlip, dontFlip = _ref5$dontFlip === void 0 ? false : _ref5$dontFlip;
                _classCallCheck2(this, PageViewport2);
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                var centerX = (viewBox[2] + viewBox[0]) / 2;
                var centerY = (viewBox[3] + viewBox[1]) / 2;
                var rotateA, rotateB, rotateC, rotateD;
                rotation %= 360;
                if (rotation < 0) {
                  rotation += 360;
                }
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  case 0:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                  default:
                    throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                var offsetCanvasX, offsetCanvasY;
                var width, height;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
              }
              _createClass2(PageViewport2, [{
                key: "clone",
                value: function clone() {
                  var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref6$scale = _ref6.scale, scale = _ref6$scale === void 0 ? this.scale : _ref6$scale, _ref6$rotation = _ref6.rotation, rotation = _ref6$rotation === void 0 ? this.rotation : _ref6$rotation, _ref6$offsetX = _ref6.offsetX, offsetX = _ref6$offsetX === void 0 ? this.offsetX : _ref6$offsetX, _ref6$offsetY = _ref6.offsetY, offsetY = _ref6$offsetY === void 0 ? this.offsetY : _ref6$offsetY, _ref6$dontFlip = _ref6.dontFlip, dontFlip = _ref6$dontFlip === void 0 ? false : _ref6$dontFlip;
                  return new PageViewport2({
                    viewBox: this.viewBox.slice(),
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
              }, {
                key: "convertToViewportPoint",
                value: function convertToViewportPoint(x, y) {
                  return _util2.Util.applyTransform([x, y], this.transform);
                }
              }, {
                key: "convertToViewportRectangle",
                value: function convertToViewportRectangle(rect) {
                  var topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                  var bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                }
              }, {
                key: "convertToPdfPoint",
                value: function convertToPdfPoint(x, y) {
                  return _util2.Util.applyInverseTransform([x, y], this.transform);
                }
              }]);
              return PageViewport2;
            }();
            exports2.PageViewport = PageViewport;
            var RenderingCancelledException = /* @__PURE__ */ function(_BaseException) {
              _inherits(RenderingCancelledException2, _BaseException);
              var _super3 = _createSuper(RenderingCancelledException2);
              function RenderingCancelledException2(msg, type) {
                var _this4;
                _classCallCheck2(this, RenderingCancelledException2);
                _this4 = _super3.call(this, msg);
                _this4.type = type;
                return _this4;
              }
              return RenderingCancelledException2;
            }(_util2.BaseException);
            exports2.RenderingCancelledException = RenderingCancelledException;
            var LinkTarget = {
              NONE: 0,
              SELF: 1,
              BLANK: 2,
              PARENT: 3,
              TOP: 4
            };
            exports2.LinkTarget = LinkTarget;
            function addLinkAttributes(link) {
              var _ref7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, url = _ref7.url, target = _ref7.target, rel = _ref7.rel, _ref7$enabled = _ref7.enabled, enabled = _ref7$enabled === void 0 ? true : _ref7$enabled;
              (0, _util2.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
              var urlNullRemoved = (0, _util2.removeNullCharacters)(url);
              if (enabled) {
                link.href = link.title = urlNullRemoved;
              } else {
                link.href = "";
                link.title = "Disabled: ".concat(urlNullRemoved);
                link.onclick = function() {
                  return false;
                };
              }
              var targetStr = "";
              switch (target) {
                case LinkTarget.NONE:
                  break;
                case LinkTarget.SELF:
                  targetStr = "_self";
                  break;
                case LinkTarget.BLANK:
                  targetStr = "_blank";
                  break;
                case LinkTarget.PARENT:
                  targetStr = "_parent";
                  break;
                case LinkTarget.TOP:
                  targetStr = "_top";
                  break;
              }
              link.target = targetStr;
              link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
            }
            function isDataScheme(url) {
              var ii = url.length;
              var i = 0;
              while (i < ii && url[i].trim() === "") {
                i++;
              }
              return url.substring(i, i + 5).toLowerCase() === "data:";
            }
            function isPdfFile(filename) {
              return typeof filename === "string" && /\.pdf$/i.test(filename);
            }
            function getFilenameFromUrl(url) {
              var anchor = url.indexOf("#");
              var query = url.indexOf("?");
              var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
              return url.substring(url.lastIndexOf("/", end) + 1, end);
            }
            function getPdfFilenameFromUrl(url) {
              var defaultFilename = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "document.pdf";
              if (typeof url !== "string") {
                return defaultFilename;
              }
              if (isDataScheme(url)) {
                (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                return defaultFilename;
              }
              var reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
              var reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
              var splitURI = reURI.exec(url);
              var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
              if (suggestedFilename) {
                suggestedFilename = suggestedFilename[0];
                if (suggestedFilename.includes("%")) {
                  try {
                    suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                  } catch (ex) {
                  }
                }
              }
              return suggestedFilename || defaultFilename;
            }
            var StatTimer = /* @__PURE__ */ function() {
              function StatTimer2() {
                _classCallCheck2(this, StatTimer2);
                this.started = /* @__PURE__ */ Object.create(null);
                this.times = [];
              }
              _createClass2(StatTimer2, [{
                key: "time",
                value: function time(name) {
                  if (name in this.started) {
                    (0, _util2.warn)("Timer is already running for ".concat(name));
                  }
                  this.started[name] = Date.now();
                }
              }, {
                key: "timeEnd",
                value: function timeEnd(name) {
                  if (!(name in this.started)) {
                    (0, _util2.warn)("Timer has not been started for ".concat(name));
                  }
                  this.times.push({
                    name,
                    start: this.started[name],
                    end: Date.now()
                  });
                  delete this.started[name];
                }
              }, {
                key: "toString",
                value: function toString() {
                  var outBuf = [];
                  var longest = 0;
                  var _iterator = _createForOfIteratorHelper2(this.times), _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var time = _step.value;
                      var name = time.name;
                      if (name.length > longest) {
                        longest = name.length;
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  var _iterator2 = _createForOfIteratorHelper2(this.times), _step2;
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var _time = _step2.value;
                      var duration = _time.end - _time.start;
                      outBuf.push("".concat(_time.name.padEnd(longest), " ").concat(duration, "ms\n"));
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                  return outBuf.join("");
                }
              }]);
              return StatTimer2;
            }();
            exports2.StatTimer = StatTimer;
            function isFetchSupported() {
              return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
            }
            function isValidFetchUrl(url, baseUrl) {
              try {
                var _ref8 = baseUrl ? new URL(url, baseUrl) : new URL(url), protocol = _ref8.protocol;
                return protocol === "http:" || protocol === "https:";
              } catch (ex) {
                return false;
              }
            }
            function loadScript(src) {
              var removeScriptElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              return new Promise(function(resolve, reject) {
                var script = document.createElement("script");
                script.src = src;
                script.onload = function(evt) {
                  if (removeScriptElement) {
                    script.remove();
                  }
                  resolve(evt);
                };
                script.onerror = function() {
                  reject(new Error("Cannot load script at: ".concat(script.src)));
                };
                (document.head || document.documentElement).appendChild(script);
              });
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            var pdfDateStringRegex;
            var PDFDateString = /* @__PURE__ */ function() {
              function PDFDateString2() {
                _classCallCheck2(this, PDFDateString2);
              }
              _createClass2(PDFDateString2, null, [{
                key: "toDateObject",
                value: function toDateObject(input) {
                  if (!input || !(0, _util2.isString)(input)) {
                    return null;
                  }
                  if (!pdfDateStringRegex) {
                    pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                  }
                  var matches = pdfDateStringRegex.exec(input);
                  if (!matches) {
                    return null;
                  }
                  var year = parseInt(matches[1], 10);
                  var month = parseInt(matches[2], 10);
                  month = month >= 1 && month <= 12 ? month - 1 : 0;
                  var day = parseInt(matches[3], 10);
                  day = day >= 1 && day <= 31 ? day : 1;
                  var hour = parseInt(matches[4], 10);
                  hour = hour >= 0 && hour <= 23 ? hour : 0;
                  var minute = parseInt(matches[5], 10);
                  minute = minute >= 0 && minute <= 59 ? minute : 0;
                  var second = parseInt(matches[6], 10);
                  second = second >= 0 && second <= 59 ? second : 0;
                  var universalTimeRelation = matches[7] || "Z";
                  var offsetHour = parseInt(matches[8], 10);
                  offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                  var offsetMinute = parseInt(matches[9], 10) || 0;
                  offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                  if (universalTimeRelation === "-") {
                    hour += offsetHour;
                    minute += offsetMinute;
                  } else if (universalTimeRelation === "+") {
                    hour -= offsetHour;
                    minute -= offsetMinute;
                  }
                  return new Date(Date.UTC(year, month, day, hour, minute, second));
                }
              }]);
              return PDFDateString2;
            }();
            exports2.PDFDateString = PDFDateString;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            module2.exports = __w_pdfjs_require__2(3);
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            module2 = __w_pdfjs_require__2.nmd(module2);
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            var runtime = function(exports2) {
              "use strict";
              var Op = Object.prototype;
              var hasOwn = Op.hasOwnProperty;
              var undefined2;
              var $Symbol = typeof Symbol === "function" ? Symbol : {};
              var iteratorSymbol = $Symbol.iterator || "@@iterator";
              var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
              var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
              function define2(obj, key, value) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
                return obj[key];
              }
              try {
                define2({}, "");
              } catch (err) {
                define2 = function define3(obj, key, value) {
                  return obj[key] = value;
                };
              }
              function wrap(innerFn, outerFn, self2, tryLocsList) {
                var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
                var generator = Object.create(protoGenerator.prototype);
                var context = new Context(tryLocsList || []);
                generator._invoke = makeInvokeMethod(innerFn, self2, context);
                return generator;
              }
              exports2.wrap = wrap;
              function tryCatch(fn, obj, arg) {
                try {
                  return {
                    type: "normal",
                    arg: fn.call(obj, arg)
                  };
                } catch (err) {
                  return {
                    type: "throw",
                    arg: err
                  };
                }
              }
              var GenStateSuspendedStart = "suspendedStart";
              var GenStateSuspendedYield = "suspendedYield";
              var GenStateExecuting = "executing";
              var GenStateCompleted = "completed";
              var ContinueSentinel = {};
              function Generator() {
              }
              function GeneratorFunction() {
              }
              function GeneratorFunctionPrototype() {
              }
              var IteratorPrototype = {};
              IteratorPrototype[iteratorSymbol] = function() {
                return this;
              };
              var getProto = Object.getPrototypeOf;
              var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
              if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
                IteratorPrototype = NativeIteratorPrototype;
              }
              var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
              GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
              GeneratorFunctionPrototype.constructor = GeneratorFunction;
              GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
              function defineIteratorMethods(prototype) {
                ["next", "throw", "return"].forEach(function(method) {
                  define2(prototype, method, function(arg) {
                    return this._invoke(method, arg);
                  });
                });
              }
              exports2.isGeneratorFunction = function(genFun) {
                var ctor = typeof genFun === "function" && genFun.constructor;
                return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
              };
              exports2.mark = function(genFun) {
                if (Object.setPrototypeOf) {
                  Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
                } else {
                  genFun.__proto__ = GeneratorFunctionPrototype;
                  define2(genFun, toStringTagSymbol, "GeneratorFunction");
                }
                genFun.prototype = Object.create(Gp);
                return genFun;
              };
              exports2.awrap = function(arg) {
                return {
                  __await: arg
                };
              };
              function AsyncIterator(generator, PromiseImpl) {
                function invoke(method, arg, resolve, reject) {
                  var record = tryCatch(generator[method], generator, arg);
                  if (record.type === "throw") {
                    reject(record.arg);
                  } else {
                    var result = record.arg;
                    var value = result.value;
                    if (value && _typeof2(value) === "object" && hasOwn.call(value, "__await")) {
                      return PromiseImpl.resolve(value.__await).then(function(value2) {
                        invoke("next", value2, resolve, reject);
                      }, function(err) {
                        invoke("throw", err, resolve, reject);
                      });
                    }
                    return PromiseImpl.resolve(value).then(function(unwrapped) {
                      result.value = unwrapped;
                      resolve(result);
                    }, function(error) {
                      return invoke("throw", error, resolve, reject);
                    });
                  }
                }
                var previousPromise;
                function enqueue(method, arg) {
                  function callInvokeWithMethodAndArg() {
                    return new PromiseImpl(function(resolve, reject) {
                      invoke(method, arg, resolve, reject);
                    });
                  }
                  return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                }
                this._invoke = enqueue;
              }
              defineIteratorMethods(AsyncIterator.prototype);
              AsyncIterator.prototype[asyncIteratorSymbol] = function() {
                return this;
              };
              exports2.AsyncIterator = AsyncIterator;
              exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
                if (PromiseImpl === void 0)
                  PromiseImpl = Promise;
                var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
                return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                  return result.done ? result.value : iter.next();
                });
              };
              function makeInvokeMethod(innerFn, self2, context) {
                var state = GenStateSuspendedStart;
                return function invoke(method, arg) {
                  if (state === GenStateExecuting) {
                    throw new Error("Generator is already running");
                  }
                  if (state === GenStateCompleted) {
                    if (method === "throw") {
                      throw arg;
                    }
                    return doneResult();
                  }
                  context.method = method;
                  context.arg = arg;
                  while (true) {
                    var delegate = context.delegate;
                    if (delegate) {
                      var delegateResult = maybeInvokeDelegate(delegate, context);
                      if (delegateResult) {
                        if (delegateResult === ContinueSentinel)
                          continue;
                        return delegateResult;
                      }
                    }
                    if (context.method === "next") {
                      context.sent = context._sent = context.arg;
                    } else if (context.method === "throw") {
                      if (state === GenStateSuspendedStart) {
                        state = GenStateCompleted;
                        throw context.arg;
                      }
                      context.dispatchException(context.arg);
                    } else if (context.method === "return") {
                      context.abrupt("return", context.arg);
                    }
                    state = GenStateExecuting;
                    var record = tryCatch(innerFn, self2, context);
                    if (record.type === "normal") {
                      state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                      if (record.arg === ContinueSentinel) {
                        continue;
                      }
                      return {
                        value: record.arg,
                        done: context.done
                      };
                    } else if (record.type === "throw") {
                      state = GenStateCompleted;
                      context.method = "throw";
                      context.arg = record.arg;
                    }
                  }
                };
              }
              function maybeInvokeDelegate(delegate, context) {
                var method = delegate.iterator[context.method];
                if (method === undefined2) {
                  context.delegate = null;
                  if (context.method === "throw") {
                    if (delegate.iterator["return"]) {
                      context.method = "return";
                      context.arg = undefined2;
                      maybeInvokeDelegate(delegate, context);
                      if (context.method === "throw") {
                        return ContinueSentinel;
                      }
                    }
                    context.method = "throw";
                    context.arg = new TypeError("The iterator does not provide a 'throw' method");
                  }
                  return ContinueSentinel;
                }
                var record = tryCatch(method, delegate.iterator, context.arg);
                if (record.type === "throw") {
                  context.method = "throw";
                  context.arg = record.arg;
                  context.delegate = null;
                  return ContinueSentinel;
                }
                var info = record.arg;
                if (!info) {
                  context.method = "throw";
                  context.arg = new TypeError("iterator result is not an object");
                  context.delegate = null;
                  return ContinueSentinel;
                }
                if (info.done) {
                  context[delegate.resultName] = info.value;
                  context.next = delegate.nextLoc;
                  if (context.method !== "return") {
                    context.method = "next";
                    context.arg = undefined2;
                  }
                } else {
                  return info;
                }
                context.delegate = null;
                return ContinueSentinel;
              }
              defineIteratorMethods(Gp);
              define2(Gp, toStringTagSymbol, "Generator");
              Gp[iteratorSymbol] = function() {
                return this;
              };
              Gp.toString = function() {
                return "[object Generator]";
              };
              function pushTryEntry(locs) {
                var entry = {
                  tryLoc: locs[0]
                };
                if (1 in locs) {
                  entry.catchLoc = locs[1];
                }
                if (2 in locs) {
                  entry.finallyLoc = locs[2];
                  entry.afterLoc = locs[3];
                }
                this.tryEntries.push(entry);
              }
              function resetTryEntry(entry) {
                var record = entry.completion || {};
                record.type = "normal";
                delete record.arg;
                entry.completion = record;
              }
              function Context(tryLocsList) {
                this.tryEntries = [{
                  tryLoc: "root"
                }];
                tryLocsList.forEach(pushTryEntry, this);
                this.reset(true);
              }
              exports2.keys = function(object) {
                var keys = [];
                for (var key in object) {
                  keys.push(key);
                }
                keys.reverse();
                return function next() {
                  while (keys.length) {
                    var key2 = keys.pop();
                    if (key2 in object) {
                      next.value = key2;
                      next.done = false;
                      return next;
                    }
                  }
                  next.done = true;
                  return next;
                };
              };
              function values(iterable) {
                if (iterable) {
                  var iteratorMethod = iterable[iteratorSymbol];
                  if (iteratorMethod) {
                    return iteratorMethod.call(iterable);
                  }
                  if (typeof iterable.next === "function") {
                    return iterable;
                  }
                  if (!isNaN(iterable.length)) {
                    var i = -1, next = function next2() {
                      while (++i < iterable.length) {
                        if (hasOwn.call(iterable, i)) {
                          next2.value = iterable[i];
                          next2.done = false;
                          return next2;
                        }
                      }
                      next2.value = undefined2;
                      next2.done = true;
                      return next2;
                    };
                    return next.next = next;
                  }
                }
                return {
                  next: doneResult
                };
              }
              exports2.values = values;
              function doneResult() {
                return {
                  value: undefined2,
                  done: true
                };
              }
              Context.prototype = {
                constructor: Context,
                reset: function reset(skipTempReset) {
                  this.prev = 0;
                  this.next = 0;
                  this.sent = this._sent = undefined2;
                  this.done = false;
                  this.delegate = null;
                  this.method = "next";
                  this.arg = undefined2;
                  this.tryEntries.forEach(resetTryEntry);
                  if (!skipTempReset) {
                    for (var name in this) {
                      if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                        this[name] = undefined2;
                      }
                    }
                  }
                },
                stop: function stop() {
                  this.done = true;
                  var rootEntry = this.tryEntries[0];
                  var rootRecord = rootEntry.completion;
                  if (rootRecord.type === "throw") {
                    throw rootRecord.arg;
                  }
                  return this.rval;
                },
                dispatchException: function dispatchException(exception) {
                  if (this.done) {
                    throw exception;
                  }
                  var context = this;
                  function handle(loc, caught) {
                    record.type = "throw";
                    record.arg = exception;
                    context.next = loc;
                    if (caught) {
                      context.method = "next";
                      context.arg = undefined2;
                    }
                    return !!caught;
                  }
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    var record = entry.completion;
                    if (entry.tryLoc === "root") {
                      return handle("end");
                    }
                    if (entry.tryLoc <= this.prev) {
                      var hasCatch = hasOwn.call(entry, "catchLoc");
                      var hasFinally = hasOwn.call(entry, "finallyLoc");
                      if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) {
                          return handle(entry.catchLoc, true);
                        } else if (this.prev < entry.finallyLoc) {
                          return handle(entry.finallyLoc);
                        }
                      } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) {
                          return handle(entry.catchLoc, true);
                        }
                      } else if (hasFinally) {
                        if (this.prev < entry.finallyLoc) {
                          return handle(entry.finallyLoc);
                        }
                      } else {
                        throw new Error("try statement without catch or finally");
                      }
                    }
                  }
                },
                abrupt: function abrupt(type, arg) {
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                      var finallyEntry = entry;
                      break;
                    }
                  }
                  if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                    finallyEntry = null;
                  }
                  var record = finallyEntry ? finallyEntry.completion : {};
                  record.type = type;
                  record.arg = arg;
                  if (finallyEntry) {
                    this.method = "next";
                    this.next = finallyEntry.finallyLoc;
                    return ContinueSentinel;
                  }
                  return this.complete(record);
                },
                complete: function complete(record, afterLoc) {
                  if (record.type === "throw") {
                    throw record.arg;
                  }
                  if (record.type === "break" || record.type === "continue") {
                    this.next = record.arg;
                  } else if (record.type === "return") {
                    this.rval = this.arg = record.arg;
                    this.method = "return";
                    this.next = "end";
                  } else if (record.type === "normal" && afterLoc) {
                    this.next = afterLoc;
                  }
                  return ContinueSentinel;
                },
                finish: function finish(finallyLoc) {
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.finallyLoc === finallyLoc) {
                      this.complete(entry.completion, entry.afterLoc);
                      resetTryEntry(entry);
                      return ContinueSentinel;
                    }
                  }
                },
                "catch": function _catch(tryLoc) {
                  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc === tryLoc) {
                      var record = entry.completion;
                      if (record.type === "throw") {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                      }
                      return thrown;
                    }
                  }
                  throw new Error("illegal catch attempt");
                },
                delegateYield: function delegateYield(iterable, resultName, nextLoc) {
                  this.delegate = {
                    iterator: values(iterable),
                    resultName,
                    nextLoc
                  };
                  if (this.method === "next") {
                    this.arg = undefined2;
                  }
                  return ContinueSentinel;
                }
              };
              return exports2;
            }((false ? 0 : _typeof2(module2)) === "object" ? module2.exports : {});
            try {
              regeneratorRuntime = runtime;
            } catch (accidentalStrictMode) {
              Function("r", "regeneratorRuntime = r")(runtime);
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.arrayByteLength = arrayByteLength;
            exports2.arraysToBytes = arraysToBytes;
            exports2.assert = assert;
            exports2.bytesToString = bytesToString;
            exports2.createObjectURL = createObjectURL;
            exports2.createPromiseCapability = createPromiseCapability;
            exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports2.escapeString = escapeString;
            exports2.getModificationDate = getModificationDate;
            exports2.getVerbosityLevel = getVerbosityLevel;
            exports2.info = info;
            exports2.isArrayBuffer = isArrayBuffer;
            exports2.isArrayEqual = isArrayEqual;
            exports2.isAscii = isAscii;
            exports2.isBool = isBool;
            exports2.isNum = isNum;
            exports2.isSameOrigin = isSameOrigin;
            exports2.isString = isString;
            exports2.objectFromMap = objectFromMap;
            exports2.objectSize = objectSize;
            exports2.removeNullCharacters = removeNullCharacters;
            exports2.setVerbosityLevel = setVerbosityLevel;
            exports2.shadow = shadow;
            exports2.string32 = string32;
            exports2.stringToBytes = stringToBytes;
            exports2.stringToPDFString = stringToPDFString;
            exports2.stringToUTF16BEString = stringToUTF16BEString;
            exports2.stringToUTF8String = stringToUTF8String;
            exports2.unreachable = unreachable;
            exports2.utf8StringToString = utf8StringToString;
            exports2.warn = warn;
            exports2.VerbosityLevel = exports2.Util = exports2.UNSUPPORTED_FEATURES = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.IsLittleEndianCached = exports2.IsEvalSupportedCached = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
            __w_pdfjs_require__2(5);
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            function _toConsumableArray2(arr) {
              return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
            }
            function _nonIterableSpread2() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _iterableToArray2(iter) {
              if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                return Array.from(iter);
            }
            function _arrayWithoutHoles2(arr) {
              if (Array.isArray(arr))
                return _arrayLikeToArray2(arr);
            }
            function _slicedToArray2(arr, i) {
              return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
            }
            function _nonIterableRest2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _iterableToArrayLimit2(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles2(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _createForOfIteratorHelper2(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e2) {
                    throw _e2;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e3) {
                didErr = true;
                err = _e3;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
            var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            var PermissionFlag = {
              PRINT: 4,
              MODIFY_CONTENTS: 8,
              COPY: 16,
              MODIFY_ANNOTATIONS: 32,
              FILL_INTERACTIVE_FORMS: 256,
              COPY_FOR_ACCESSIBILITY: 512,
              ASSEMBLE: 1024,
              PRINT_HIGH_QUALITY: 2048
            };
            exports2.PermissionFlag = PermissionFlag;
            var TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            exports2.TextRenderingMode = TextRenderingMode;
            var ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            exports2.ImageKind = ImageKind;
            var AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            exports2.AnnotationType = AnnotationType;
            var AnnotationStateModelType = {
              MARKED: "Marked",
              REVIEW: "Review"
            };
            exports2.AnnotationStateModelType = AnnotationStateModelType;
            var AnnotationMarkedState = {
              MARKED: "Marked",
              UNMARKED: "Unmarked"
            };
            exports2.AnnotationMarkedState = AnnotationMarkedState;
            var AnnotationReviewState = {
              ACCEPTED: "Accepted",
              REJECTED: "Rejected",
              CANCELLED: "Cancelled",
              COMPLETED: "Completed",
              NONE: "None"
            };
            exports2.AnnotationReviewState = AnnotationReviewState;
            var AnnotationReplyType = {
              GROUP: "Group",
              REPLY: "R"
            };
            exports2.AnnotationReplyType = AnnotationReplyType;
            var AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            exports2.AnnotationFlag = AnnotationFlag;
            var AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            exports2.AnnotationFieldFlag = AnnotationFieldFlag;
            var AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
            var AnnotationActionEventType = {
              E: "Mouse Enter",
              X: "Mouse Exit",
              D: "Mouse Down",
              U: "Mouse Up",
              Fo: "Focus",
              Bl: "Blur",
              PO: "PageOpen",
              PC: "PageClose",
              PV: "PageVisible",
              PI: "PageInvisible",
              K: "Keystroke",
              F: "Format",
              V: "Validate",
              C: "Calculate"
            };
            exports2.AnnotationActionEventType = AnnotationActionEventType;
            var DocumentActionEventType = {
              WC: "WillClose",
              WS: "WillSave",
              DS: "DidSave",
              WP: "WillPrint",
              DP: "DidPrint"
            };
            exports2.DocumentActionEventType = DocumentActionEventType;
            var PageActionEventType = {
              O: "PageOpen",
              C: "PageClose"
            };
            exports2.PageActionEventType = PageActionEventType;
            var StreamType = {
              UNKNOWN: "UNKNOWN",
              FLATE: "FLATE",
              LZW: "LZW",
              DCT: "DCT",
              JPX: "JPX",
              JBIG: "JBIG",
              A85: "A85",
              AHX: "AHX",
              CCF: "CCF",
              RLX: "RLX"
            };
            exports2.StreamType = StreamType;
            var FontType = {
              UNKNOWN: "UNKNOWN",
              TYPE1: "TYPE1",
              TYPE1C: "TYPE1C",
              CIDFONTTYPE0: "CIDFONTTYPE0",
              CIDFONTTYPE0C: "CIDFONTTYPE0C",
              TRUETYPE: "TRUETYPE",
              CIDFONTTYPE2: "CIDFONTTYPE2",
              TYPE3: "TYPE3",
              OPENTYPE: "OPENTYPE",
              TYPE0: "TYPE0",
              MMTYPE1: "MMTYPE1"
            };
            exports2.FontType = FontType;
            var VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            exports2.VerbosityLevel = VerbosityLevel;
            var CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            exports2.CMapCompressionType = CMapCompressionType;
            var OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            exports2.OPS = OPS;
            var UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font",
              errorTilingPattern: "errorTilingPattern",
              errorExtGState: "errorExtGState",
              errorXObject: "errorXObject",
              errorFontLoadType3: "errorFontLoadType3",
              errorFontState: "errorFontState",
              errorFontMissing: "errorFontMissing",
              errorFontTranslate: "errorFontTranslate",
              errorColorSpace: "errorColorSpace",
              errorOperatorList: "errorOperatorList",
              errorFontToUnicode: "errorFontToUnicode",
              errorFontLoadNative: "errorFontLoadNative",
              errorFontGetPath: "errorFontGetPath",
              errorMarkedContent: "errorMarkedContent"
            };
            exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            var PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            exports2.PasswordResponses = PasswordResponses;
            var verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log("Info: ".concat(msg));
              }
            }
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log("Warning: ".concat(msg));
              }
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            function isSameOrigin(baseUrl, otherUrl) {
              var base;
              try {
                base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e) {
                return false;
              }
              var other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function _isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (_isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            var BaseException = function BaseExceptionClosure() {
              function BaseException2(message) {
                if (this.constructor === BaseException2) {
                  unreachable("Cannot initialize BaseException.");
                }
                this.message = message;
                this.name = this.constructor.name;
              }
              BaseException2.prototype = new Error();
              BaseException2.constructor = BaseException2;
              return BaseException2;
            }();
            exports2.BaseException = BaseException;
            var PasswordException = /* @__PURE__ */ function(_BaseException) {
              _inherits(PasswordException2, _BaseException);
              var _super = _createSuper(PasswordException2);
              function PasswordException2(msg, code) {
                var _this;
                _classCallCheck2(this, PasswordException2);
                _this = _super.call(this, msg);
                _this.code = code;
                return _this;
              }
              return PasswordException2;
            }(BaseException);
            exports2.PasswordException = PasswordException;
            var UnknownErrorException = /* @__PURE__ */ function(_BaseException2) {
              _inherits(UnknownErrorException2, _BaseException2);
              var _super2 = _createSuper(UnknownErrorException2);
              function UnknownErrorException2(msg, details) {
                var _this2;
                _classCallCheck2(this, UnknownErrorException2);
                _this2 = _super2.call(this, msg);
                _this2.details = details;
                return _this2;
              }
              return UnknownErrorException2;
            }(BaseException);
            exports2.UnknownErrorException = UnknownErrorException;
            var InvalidPDFException = /* @__PURE__ */ function(_BaseException3) {
              _inherits(InvalidPDFException2, _BaseException3);
              var _super3 = _createSuper(InvalidPDFException2);
              function InvalidPDFException2() {
                _classCallCheck2(this, InvalidPDFException2);
                return _super3.apply(this, arguments);
              }
              return InvalidPDFException2;
            }(BaseException);
            exports2.InvalidPDFException = InvalidPDFException;
            var MissingPDFException = /* @__PURE__ */ function(_BaseException4) {
              _inherits(MissingPDFException2, _BaseException4);
              var _super4 = _createSuper(MissingPDFException2);
              function MissingPDFException2() {
                _classCallCheck2(this, MissingPDFException2);
                return _super4.apply(this, arguments);
              }
              return MissingPDFException2;
            }(BaseException);
            exports2.MissingPDFException = MissingPDFException;
            var UnexpectedResponseException = /* @__PURE__ */ function(_BaseException5) {
              _inherits(UnexpectedResponseException2, _BaseException5);
              var _super5 = _createSuper(UnexpectedResponseException2);
              function UnexpectedResponseException2(msg, status) {
                var _this3;
                _classCallCheck2(this, UnexpectedResponseException2);
                _this3 = _super5.call(this, msg);
                _this3.status = status;
                return _this3;
              }
              return UnexpectedResponseException2;
            }(BaseException);
            exports2.UnexpectedResponseException = UnexpectedResponseException;
            var FormatError = /* @__PURE__ */ function(_BaseException6) {
              _inherits(FormatError2, _BaseException6);
              var _super6 = _createSuper(FormatError2);
              function FormatError2() {
                _classCallCheck2(this, FormatError2);
                return _super6.apply(this, arguments);
              }
              return FormatError2;
            }(BaseException);
            exports2.FormatError = FormatError;
            var AbortException = /* @__PURE__ */ function(_BaseException7) {
              _inherits(AbortException2, _BaseException7);
              var _super7 = _createSuper(AbortException2);
              function AbortException2() {
                _classCallCheck2(this, AbortException2);
                return _super7.apply(this, arguments);
              }
              return AbortException2;
            }(BaseException);
            exports2.AbortException = AbortException;
            var NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && _typeof2(bytes) === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              var length = bytes.length;
              var MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              var strBuf = [];
              for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                var chunk = bytes.subarray(i, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              var length = str.length;
              var bytes = new Uint8Array(length);
              for (var i = 0; i < length; ++i) {
                bytes[i] = str.charCodeAt(i) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0, "arrayByteLength - invalid argument.");
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              var length = arr.length;
              if (length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              var resultLength = 0;
              for (var i = 0; i < length; i++) {
                resultLength += arrayByteLength(arr[i]);
              }
              var pos = 0;
              var data = new Uint8Array(resultLength);
              for (var _i = 0; _i < length; _i++) {
                var item = arr[_i];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                var itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function objectSize(obj) {
              return Object.keys(obj).length;
            }
            function objectFromMap(map) {
              var obj = /* @__PURE__ */ Object.create(null);
              var _iterator = _createForOfIteratorHelper2(map), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var _step$value = _slicedToArray2(_step.value, 2), key = _step$value[0], value = _step$value[1];
                  obj[key] = value;
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return obj;
            }
            function isLittleEndian() {
              var buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              var view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            var IsLittleEndianCached = {
              get value() {
                return shadow(this, "value", isLittleEndian());
              }
            };
            exports2.IsLittleEndianCached = IsLittleEndianCached;
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e) {
                return false;
              }
            }
            var IsEvalSupportedCached = {
              get value() {
                return shadow(this, "value", isEvalSupported());
              }
            };
            exports2.IsEvalSupportedCached = IsEvalSupportedCached;
            var hexNumbers = _toConsumableArray2(Array(256).keys()).map(function(n) {
              return n.toString(16).padStart(2, "0");
            });
            var Util = /* @__PURE__ */ function() {
              function Util2() {
                _classCallCheck2(this, Util2);
              }
              _createClass2(Util2, null, [{
                key: "makeHexColor",
                value: function makeHexColor(r, g, b) {
                  return "#".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);
                }
              }, {
                key: "transform",
                value: function transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
              }, {
                key: "applyTransform",
                value: function applyTransform(p, m) {
                  var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
              }, {
                key: "applyInverseTransform",
                value: function applyInverseTransform(p, m) {
                  var d = m[0] * m[3] - m[1] * m[2];
                  var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
              }, {
                key: "getAxialAlignedBoundingBox",
                value: function getAxialAlignedBoundingBox(r, m) {
                  var p1 = Util2.applyTransform(r, m);
                  var p2 = Util2.applyTransform(r.slice(2, 4), m);
                  var p3 = Util2.applyTransform([r[0], r[3]], m);
                  var p4 = Util2.applyTransform([r[2], r[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
              }, {
                key: "inverseTransform",
                value: function inverseTransform(m) {
                  var d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
              }, {
                key: "apply3dTransform",
                value: function apply3dTransform(m, v) {
                  return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                }
              }, {
                key: "singularValueDecompose2dScale",
                value: function singularValueDecompose2dScale(m) {
                  var transpose = [m[0], m[2], m[1], m[3]];
                  var a = m[0] * transpose[0] + m[1] * transpose[2];
                  var b = m[0] * transpose[1] + m[1] * transpose[3];
                  var c = m[2] * transpose[0] + m[3] * transpose[2];
                  var d = m[2] * transpose[1] + m[3] * transpose[3];
                  var first = (a + d) / 2;
                  var second = Math.sqrt(Math.pow(a + d, 2) - 4 * (a * d - c * b)) / 2;
                  var sx = first + second || 1;
                  var sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
              }, {
                key: "normalizeRect",
                value: function normalizeRect(rect) {
                  var r = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r[0] = rect[2];
                    r[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r[1] = rect[3];
                    r[3] = rect[1];
                  }
                  return r;
                }
              }, {
                key: "intersect",
                value: function intersect(rect1, rect2) {
                  function compare(a, b) {
                    return a - b;
                  }
                  var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                  var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                  var result = [];
                  rect1 = Util2.normalizeRect(rect1);
                  rect2 = Util2.normalizeRect(rect2);
                  if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                    result[0] = orderedX[1];
                    result[2] = orderedX[2];
                  } else {
                    return null;
                  }
                  if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                    result[1] = orderedY[1];
                    result[3] = orderedY[2];
                  } else {
                    return null;
                  }
                  return result;
                }
              }]);
              return Util2;
            }();
            exports2.Util = Util;
            var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              var length = str.length, strBuf = [];
              if (str[0] === "\xFE" && str[1] === "\xFF") {
                for (var i = 2; i < length; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                }
              } else if (str[0] === "\xFF" && str[1] === "\xFE") {
                for (var _i2 = 2; _i2 < length; _i2 += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));
                }
              } else {
                for (var _i3 = 0; _i3 < length; ++_i3) {
                  var code = PDFStringTranslateTable[str.charCodeAt(_i3)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));
                }
              }
              return strBuf.join("");
            }
            function escapeString(str) {
              return str.replace(/([()\\\n\r])/g, function(match) {
                if (match === "\n") {
                  return "\\n";
                } else if (match === "\r") {
                  return "\\r";
                }
                return "\\".concat(match);
              });
            }
            function isAscii(str) {
              return /^[\x00-\x7F]*$/.test(str);
            }
            function stringToUTF16BEString(str) {
              var buf = ["\xFE\xFF"];
              for (var i = 0, ii = str.length; i < ii; i++) {
                var _char = str.charCodeAt(i);
                buf.push(String.fromCharCode(_char >> 8 & 255));
                buf.push(String.fromCharCode(_char & 255));
              }
              return buf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isString(v) {
              return typeof v === "string";
            }
            function isArrayBuffer(v) {
              return _typeof2(v) === "object" && v !== null && v.byteLength !== void 0;
            }
            function isArrayEqual(arr1, arr2) {
              if (arr1.length !== arr2.length) {
                return false;
              }
              for (var i = 0, ii = arr1.length; i < ii; i++) {
                if (arr1[i] !== arr2[i]) {
                  return false;
                }
              }
              return true;
            }
            function getModificationDate() {
              var date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Date();
              var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
              return buffer.join("");
            }
            function createPromiseCapability() {
              var capability = /* @__PURE__ */ Object.create(null);
              var isSettled = false;
              Object.defineProperty(capability, "settled", {
                get: function get() {
                  return isSettled;
                }
              });
              capability.promise = new Promise(function(resolve, reject) {
                capability.resolve = function(data) {
                  isSettled = true;
                  resolve(data);
                };
                capability.reject = function(reason) {
                  isSettled = true;
                  reject(reason);
                };
              });
              return capability;
            }
            function createObjectURL(data) {
              var contentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
              var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (URL.createObjectURL && !forceDataSchema) {
                return URL.createObjectURL(new Blob([data], {
                  type: contentType
                }));
              }
              var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              var buffer = "data:".concat(contentType, ";base64,");
              for (var i = 0, ii = data.length; i < ii; i += 3) {
                var b1 = data[i] & 255;
                var b2 = data[i + 1] & 255;
                var b3 = data[i + 2] & 255;
                var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                var d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                var d4 = i + 2 < ii ? b3 & 63 : 64;
                buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
              }
              return buffer;
            }
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var _is_node2 = __w_pdfjs_require__2(6);
            if (typeof globalThis === "undefined" || !globalThis._pdfjsCompatibilityChecked) {
              if (typeof globalThis === "undefined" || globalThis.Math !== Math) {
                globalThis = __w_pdfjs_require__2(7);
              }
              globalThis._pdfjsCompatibilityChecked = true;
              (function checkNodeBtoa() {
                if (globalThis.btoa || !_is_node2.isNodeJS) {
                  return;
                }
                globalThis.btoa = function(chars) {
                  return Buffer.from(chars, "binary").toString("base64");
                };
              })();
              (function checkNodeAtob() {
                if (globalThis.atob || !_is_node2.isNodeJS) {
                  return;
                }
                globalThis.atob = function(input) {
                  return Buffer.from(input, "base64").toString("binary");
                };
              })();
              (function checkObjectFromEntries() {
                if (Object.fromEntries) {
                  return;
                }
                __w_pdfjs_require__2(52);
              })();
              (function checkPromise() {
                if (globalThis.Promise.allSettled) {
                  return;
                }
                globalThis.Promise = __w_pdfjs_require__2(85);
              })();
              (function checkReadableStream() {
                var isReadableStreamSupported = false;
                if (typeof ReadableStream !== "undefined") {
                  try {
                    new ReadableStream({
                      start: function start(controller) {
                        controller.close();
                      }
                    });
                    isReadableStreamSupported = true;
                  } catch (e) {
                  }
                }
                if (isReadableStreamSupported) {
                  return;
                }
                globalThis.ReadableStream = __w_pdfjs_require__2(111).ReadableStream;
              })();
              (function checkStringPadStart() {
                if (String.prototype.padStart) {
                  return;
                }
                __w_pdfjs_require__2(112);
              })();
              (function checkStringPadEnd() {
                if (String.prototype.padEnd) {
                  return;
                }
                __w_pdfjs_require__2(118);
              })();
              (function checkObjectValues() {
                if (Object.values) {
                  return;
                }
                Object.values = __w_pdfjs_require__2(120);
              })();
              (function checkObjectEntries() {
                if (Object.entries) {
                  return;
                }
                Object.entries = __w_pdfjs_require__2(123);
              })();
            }
          },
          (__unused_webpack_module2, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.isNodeJS = void 0;
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof2(process)) === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
            exports2.isNodeJS = isNodeJS;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            __w_pdfjs_require__2(8);
            module2.exports = __w_pdfjs_require__2(10);
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var $ = __w_pdfjs_require__2(9);
            var global2 = __w_pdfjs_require__2(10);
            $({ global: true }, { globalThis: global2 });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var getOwnPropertyDescriptor = __w_pdfjs_require__2(11).f;
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            var redefine = __w_pdfjs_require__2(28);
            var setGlobal = __w_pdfjs_require__2(29);
            var copyConstructorProperties = __w_pdfjs_require__2(39);
            var isForced = __w_pdfjs_require__2(51);
            module2.exports = function(options, source) {
              var TARGET = options.target;
              var GLOBAL = options.global;
              var STATIC = options.stat;
              var FORCED, target, key, targetProperty, sourceProperty, descriptor;
              if (GLOBAL) {
                target = global2;
              } else if (STATIC) {
                target = global2[TARGET] || setGlobal(TARGET, {});
              } else {
                target = (global2[TARGET] || {}).prototype;
              }
              if (target)
                for (key in source) {
                  sourceProperty = source[key];
                  if (options.noTargetGet) {
                    descriptor = getOwnPropertyDescriptor(target, key);
                    targetProperty = descriptor && descriptor.value;
                  } else
                    targetProperty = target[key];
                  FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                  if (!FORCED && targetProperty !== void 0) {
                    if (typeof sourceProperty === typeof targetProperty)
                      continue;
                    copyConstructorProperties(sourceProperty, targetProperty);
                  }
                  if (options.sham || targetProperty && targetProperty.sham) {
                    createNonEnumerableProperty(sourceProperty, "sham", true);
                  }
                  redefine(target, key, sourceProperty, options);
                }
            };
          },
          (module2) => {
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
              return this;
            }() || Function("return this")();
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var DESCRIPTORS = __w_pdfjs_require__2(12);
            var propertyIsEnumerableModule = __w_pdfjs_require__2(14);
            var createPropertyDescriptor = __w_pdfjs_require__2(15);
            var toIndexedObject = __w_pdfjs_require__2(16);
            var toPrimitive = __w_pdfjs_require__2(20);
            var has = __w_pdfjs_require__2(22);
            var IE8_DOM_DEFINE = __w_pdfjs_require__2(23);
            var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
              O = toIndexedObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE)
                try {
                  return $getOwnPropertyDescriptor(O, P);
                } catch (error) {
                }
              if (has(O, P))
                return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var fails = __w_pdfjs_require__2(13);
            module2.exports = !fails(function() {
              return Object.defineProperty({}, 1, {
                get: function() {
                  return 7;
                }
              })[1] != 7;
            });
          },
          (module2) => {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (error) {
                return true;
              }
            };
          },
          (__unused_webpack_module2, exports2) => {
            "use strict";
            var $propertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
            exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
              var descriptor = getOwnPropertyDescriptor(this, V);
              return !!descriptor && descriptor.enumerable;
            } : $propertyIsEnumerable;
          },
          (module2) => {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var IndexedObject = __w_pdfjs_require__2(17);
            var requireObjectCoercible = __w_pdfjs_require__2(19);
            module2.exports = function(it) {
              return IndexedObject(requireObjectCoercible(it));
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var fails = __w_pdfjs_require__2(13);
            var classof = __w_pdfjs_require__2(18);
            var split = "".split;
            module2.exports = fails(function() {
              return !Object("z").propertyIsEnumerable(0);
            }) ? function(it) {
              return classof(it) == "String" ? split.call(it, "") : Object(it);
            } : Object;
          },
          (module2) => {
            var toString = {}.toString;
            module2.exports = function(it) {
              return toString.call(it).slice(8, -1);
            };
          },
          (module2) => {
            module2.exports = function(it) {
              if (it == void 0)
                throw TypeError("Can't call method on " + it);
              return it;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var isObject = __w_pdfjs_require__2(21);
            module2.exports = function(input, PREFERRED_STRING) {
              if (!isObject(input))
                return input;
              var fn, val;
              if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
                return val;
              if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input)))
                return val;
              if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
                return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          (module2) => {
            module2.exports = function(it) {
              return typeof it === "object" ? it !== null : typeof it === "function";
            };
          },
          (module2) => {
            var hasOwnProperty = {}.hasOwnProperty;
            module2.exports = function(it, key) {
              return hasOwnProperty.call(it, key);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var DESCRIPTORS = __w_pdfjs_require__2(12);
            var fails = __w_pdfjs_require__2(13);
            var createElement = __w_pdfjs_require__2(24);
            module2.exports = !DESCRIPTORS && !fails(function() {
              return Object.defineProperty(createElement("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var isObject = __w_pdfjs_require__2(21);
            var document2 = global2.document;
            var EXISTS = isObject(document2) && isObject(document2.createElement);
            module2.exports = function(it) {
              return EXISTS ? document2.createElement(it) : {};
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var DESCRIPTORS = __w_pdfjs_require__2(12);
            var definePropertyModule = __w_pdfjs_require__2(26);
            var createPropertyDescriptor = __w_pdfjs_require__2(15);
            module2.exports = DESCRIPTORS ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var DESCRIPTORS = __w_pdfjs_require__2(12);
            var IE8_DOM_DEFINE = __w_pdfjs_require__2(23);
            var anObject = __w_pdfjs_require__2(27);
            var toPrimitive = __w_pdfjs_require__2(20);
            var $defineProperty = Object.defineProperty;
            exports2.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return $defineProperty(O, P, Attributes);
                } catch (error) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw TypeError("Accessors not supported");
              if ("value" in Attributes)
                O[P] = Attributes.value;
              return O;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var isObject = __w_pdfjs_require__2(21);
            module2.exports = function(it) {
              if (!isObject(it)) {
                throw TypeError(String(it) + " is not an object");
              }
              return it;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            var has = __w_pdfjs_require__2(22);
            var setGlobal = __w_pdfjs_require__2(29);
            var inspectSource = __w_pdfjs_require__2(30);
            var InternalStateModule = __w_pdfjs_require__2(32);
            var getInternalState = InternalStateModule.get;
            var enforceInternalState = InternalStateModule.enforce;
            var TEMPLATE = String(String).split("String");
            (module2.exports = function(O, key, value, options) {
              var unsafe = options ? !!options.unsafe : false;
              var simple = options ? !!options.enumerable : false;
              var noTargetGet = options ? !!options.noTargetGet : false;
              var state;
              if (typeof value == "function") {
                if (typeof key == "string" && !has(value, "name")) {
                  createNonEnumerableProperty(value, "name", key);
                }
                state = enforceInternalState(value);
                if (!state.source) {
                  state.source = TEMPLATE.join(typeof key == "string" ? key : "");
                }
              }
              if (O === global2) {
                if (simple)
                  O[key] = value;
                else
                  setGlobal(key, value);
                return;
              } else if (!unsafe) {
                delete O[key];
              } else if (!noTargetGet && O[key]) {
                simple = true;
              }
              if (simple)
                O[key] = value;
              else
                createNonEnumerableProperty(O, key, value);
            })(Function.prototype, "toString", function toString() {
              return typeof this == "function" && getInternalState(this).source || inspectSource(this);
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            module2.exports = function(key, value) {
              try {
                createNonEnumerableProperty(global2, key, value);
              } catch (error) {
                global2[key] = value;
              }
              return value;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var store = __w_pdfjs_require__2(31);
            var functionToString = Function.toString;
            if (typeof store.inspectSource != "function") {
              store.inspectSource = function(it) {
                return functionToString.call(it);
              };
            }
            module2.exports = store.inspectSource;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var setGlobal = __w_pdfjs_require__2(29);
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || setGlobal(SHARED, {});
            module2.exports = store;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var NATIVE_WEAK_MAP = __w_pdfjs_require__2(33);
            var global2 = __w_pdfjs_require__2(10);
            var isObject = __w_pdfjs_require__2(21);
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            var objectHas = __w_pdfjs_require__2(22);
            var shared = __w_pdfjs_require__2(31);
            var sharedKey = __w_pdfjs_require__2(34);
            var hiddenKeys = __w_pdfjs_require__2(38);
            var WeakMap2 = global2.WeakMap;
            var set, get, has;
            var enforce = function(it) {
              return has(it) ? get(it) : set(it, {});
            };
            var getterFor = function(TYPE) {
              return function(it) {
                var state;
                if (!isObject(it) || (state = get(it)).type !== TYPE) {
                  throw TypeError("Incompatible receiver, " + TYPE + " required");
                }
                return state;
              };
            };
            if (NATIVE_WEAK_MAP) {
              var store = shared.state || (shared.state = new WeakMap2());
              var wmget = store.get;
              var wmhas = store.has;
              var wmset = store.set;
              set = function(it, metadata) {
                metadata.facade = it;
                wmset.call(store, it, metadata);
                return metadata;
              };
              get = function(it) {
                return wmget.call(store, it) || {};
              };
              has = function(it) {
                return wmhas.call(store, it);
              };
            } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = true;
              set = function(it, metadata) {
                metadata.facade = it;
                createNonEnumerableProperty(it, STATE, metadata);
                return metadata;
              };
              get = function(it) {
                return objectHas(it, STATE) ? it[STATE] : {};
              };
              has = function(it) {
                return objectHas(it, STATE);
              };
            }
            module2.exports = {
              set,
              get,
              has,
              enforce,
              getterFor
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var inspectSource = __w_pdfjs_require__2(30);
            var WeakMap2 = global2.WeakMap;
            module2.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var shared = __w_pdfjs_require__2(35);
            var uid = __w_pdfjs_require__2(37);
            var keys = shared("keys");
            module2.exports = function(key) {
              return keys[key] || (keys[key] = uid(key));
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var IS_PURE = __w_pdfjs_require__2(36);
            var store = __w_pdfjs_require__2(31);
            (module2.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: "3.10.0",
              mode: IS_PURE ? "pure" : "global",
              copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
            });
          },
          (module2) => {
            module2.exports = false;
          },
          (module2) => {
            var id = 0;
            var postfix = Math.random();
            module2.exports = function(key) {
              return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
            };
          },
          (module2) => {
            module2.exports = {};
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var has = __w_pdfjs_require__2(22);
            var ownKeys = __w_pdfjs_require__2(40);
            var getOwnPropertyDescriptorModule = __w_pdfjs_require__2(11);
            var definePropertyModule = __w_pdfjs_require__2(26);
            module2.exports = function(target, source) {
              var keys = ownKeys(source);
              var defineProperty = definePropertyModule.f;
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (!has(target, key))
                  defineProperty(target, key, getOwnPropertyDescriptor(source, key));
              }
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var getBuiltIn = __w_pdfjs_require__2(41);
            var getOwnPropertyNamesModule = __w_pdfjs_require__2(43);
            var getOwnPropertySymbolsModule = __w_pdfjs_require__2(50);
            var anObject = __w_pdfjs_require__2(27);
            module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
              var keys = getOwnPropertyNamesModule.f(anObject(it));
              var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
              return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var path = __w_pdfjs_require__2(42);
            var global2 = __w_pdfjs_require__2(10);
            var aFunction = function(variable) {
              return typeof variable == "function" ? variable : void 0;
            };
            module2.exports = function(namespace, method) {
              return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            module2.exports = global2;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var internalObjectKeys = __w_pdfjs_require__2(44);
            var enumBugKeys = __w_pdfjs_require__2(49);
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return internalObjectKeys(O, hiddenKeys);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var has = __w_pdfjs_require__2(22);
            var toIndexedObject = __w_pdfjs_require__2(16);
            var indexOf = __w_pdfjs_require__2(45).indexOf;
            var hiddenKeys = __w_pdfjs_require__2(38);
            module2.exports = function(object, names) {
              var O = toIndexedObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O)
                !has(hiddenKeys, key) && has(O, key) && result.push(key);
              while (names.length > i)
                if (has(O, key = names[i++])) {
                  ~indexOf(result, key) || result.push(key);
                }
              return result;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var toIndexedObject = __w_pdfjs_require__2(16);
            var toLength = __w_pdfjs_require__2(46);
            var toAbsoluteIndex = __w_pdfjs_require__2(48);
            var createMethod = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIndexedObject($this);
                var length = toLength(O.length);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length > index) {
                    value = O[index++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length > index; index++) {
                    if ((IS_INCLUDES || index in O) && O[index] === el)
                      return IS_INCLUDES || index || 0;
                  }
                return !IS_INCLUDES && -1;
              };
            };
            module2.exports = {
              includes: createMethod(true),
              indexOf: createMethod(false)
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var toInteger = __w_pdfjs_require__2(47);
            var min = Math.min;
            module2.exports = function(argument) {
              return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
            };
          },
          (module2) => {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = function(argument) {
              return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var toInteger = __w_pdfjs_require__2(47);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length) {
              var integer = toInteger(index);
              return integer < 0 ? max(integer + length, 0) : min(integer, length);
            };
          },
          (module2) => {
            module2.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf"
            ];
          },
          (__unused_webpack_module2, exports2) => {
            exports2.f = Object.getOwnPropertySymbols;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var fails = __w_pdfjs_require__2(13);
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
              var value = data[normalize(feature)];
              return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
            };
            var normalize = isForced.normalize = function(string) {
              return String(string).replace(replacement, ".").toLowerCase();
            };
            var data = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module2.exports = isForced;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            __w_pdfjs_require__2(53);
            __w_pdfjs_require__2(75);
            var path = __w_pdfjs_require__2(42);
            module2.exports = path.Object.fromEntries;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var toIndexedObject = __w_pdfjs_require__2(16);
            var addToUnscopables = __w_pdfjs_require__2(54);
            var Iterators = __w_pdfjs_require__2(65);
            var InternalStateModule = __w_pdfjs_require__2(32);
            var defineIterator = __w_pdfjs_require__2(66);
            var ARRAY_ITERATOR = "Array Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
            module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
              setInternalState(this, {
                type: ARRAY_ITERATOR,
                target: toIndexedObject(iterated),
                index: 0,
                kind
              });
            }, function() {
              var state = getInternalState(this);
              var target = state.target;
              var kind = state.kind;
              var index = state.index++;
              if (!target || index >= target.length) {
                state.target = void 0;
                return {
                  value: void 0,
                  done: true
                };
              }
              if (kind == "keys")
                return {
                  value: index,
                  done: false
                };
              if (kind == "values")
                return {
                  value: target[index],
                  done: false
                };
              return {
                value: [
                  index,
                  target[index]
                ],
                done: false
              };
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var create = __w_pdfjs_require__2(61);
            var definePropertyModule = __w_pdfjs_require__2(26);
            var UNSCOPABLES = wellKnownSymbol("unscopables");
            var ArrayPrototype = Array.prototype;
            if (ArrayPrototype[UNSCOPABLES] == void 0) {
              definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                configurable: true,
                value: create(null)
              });
            }
            module2.exports = function(key) {
              ArrayPrototype[UNSCOPABLES][key] = true;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var shared = __w_pdfjs_require__2(35);
            var has = __w_pdfjs_require__2(22);
            var uid = __w_pdfjs_require__2(37);
            var NATIVE_SYMBOL = __w_pdfjs_require__2(56);
            var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(60);
            var WellKnownSymbolsStore = shared("wks");
            var Symbol2 = global2.Symbol;
            var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
            module2.exports = function(name) {
              if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                if (NATIVE_SYMBOL && has(Symbol2, name)) {
                  WellKnownSymbolsStore[name] = Symbol2[name];
                } else {
                  WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
                }
              }
              return WellKnownSymbolsStore[name];
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var IS_NODE = __w_pdfjs_require__2(57);
            var V8_VERSION = __w_pdfjs_require__2(58);
            var fails = __w_pdfjs_require__2(13);
            module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
              return !Symbol.sham && (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var classof = __w_pdfjs_require__2(18);
            var global2 = __w_pdfjs_require__2(10);
            module2.exports = classof(global2.process) == "process";
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var userAgent = __w_pdfjs_require__2(59);
            var process2 = global2.process;
            var versions = process2 && process2.versions;
            var v8 = versions && versions.v8;
            var match, version2;
            if (v8) {
              match = v8.split(".");
              version2 = match[0] + match[1];
            } else if (userAgent) {
              match = userAgent.match(/Edge\/(\d+)/);
              if (!match || match[1] >= 74) {
                match = userAgent.match(/Chrome\/(\d+)/);
                if (match)
                  version2 = match[1];
              }
            }
            module2.exports = version2 && +version2;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var getBuiltIn = __w_pdfjs_require__2(41);
            module2.exports = getBuiltIn("navigator", "userAgent") || "";
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var NATIVE_SYMBOL = __w_pdfjs_require__2(56);
            module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var anObject = __w_pdfjs_require__2(27);
            var defineProperties = __w_pdfjs_require__2(62);
            var enumBugKeys = __w_pdfjs_require__2(49);
            var hiddenKeys = __w_pdfjs_require__2(38);
            var html = __w_pdfjs_require__2(64);
            var documentCreateElement = __w_pdfjs_require__2(24);
            var sharedKey = __w_pdfjs_require__2(34);
            var GT = ">";
            var LT = "<";
            var PROTOTYPE = "prototype";
            var SCRIPT = "script";
            var IE_PROTO = sharedKey("IE_PROTO");
            var EmptyConstructor = function() {
            };
            var scriptTag = function(content) {
              return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
            };
            var NullProtoObjectViaActiveX = function(activeXDocument2) {
              activeXDocument2.write(scriptTag(""));
              activeXDocument2.close();
              var temp = activeXDocument2.parentWindow.Object;
              activeXDocument2 = null;
              return temp;
            };
            var NullProtoObjectViaIFrame = function() {
              var iframe = documentCreateElement("iframe");
              var JS = "java" + SCRIPT + ":";
              var iframeDocument;
              iframe.style.display = "none";
              html.appendChild(iframe);
              iframe.src = String(JS);
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(scriptTag("document.F=Object"));
              iframeDocument.close();
              return iframeDocument.F;
            };
            var activeXDocument;
            var NullProtoObject = function() {
              try {
                activeXDocument = document.domain && new ActiveXObject("htmlfile");
              } catch (error) {
              }
              NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
              var length = enumBugKeys.length;
              while (length--)
                delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
              return NullProtoObject();
            };
            hiddenKeys[IE_PROTO] = true;
            module2.exports = Object.create || function create(O, Properties) {
              var result;
              if (O !== null) {
                EmptyConstructor[PROTOTYPE] = anObject(O);
                result = new EmptyConstructor();
                EmptyConstructor[PROTOTYPE] = null;
                result[IE_PROTO] = O;
              } else
                result = NullProtoObject();
              return Properties === void 0 ? result : defineProperties(result, Properties);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var DESCRIPTORS = __w_pdfjs_require__2(12);
            var definePropertyModule = __w_pdfjs_require__2(26);
            var anObject = __w_pdfjs_require__2(27);
            var objectKeys = __w_pdfjs_require__2(63);
            module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
              anObject(O);
              var keys = objectKeys(Properties);
              var length = keys.length;
              var index = 0;
              var key;
              while (length > index)
                definePropertyModule.f(O, key = keys[index++], Properties[key]);
              return O;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var internalObjectKeys = __w_pdfjs_require__2(44);
            var enumBugKeys = __w_pdfjs_require__2(49);
            module2.exports = Object.keys || function keys(O) {
              return internalObjectKeys(O, enumBugKeys);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var getBuiltIn = __w_pdfjs_require__2(41);
            module2.exports = getBuiltIn("document", "documentElement");
          },
          (module2) => {
            module2.exports = {};
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var createIteratorConstructor = __w_pdfjs_require__2(67);
            var getPrototypeOf = __w_pdfjs_require__2(69);
            var setPrototypeOf = __w_pdfjs_require__2(73);
            var setToStringTag = __w_pdfjs_require__2(72);
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            var redefine = __w_pdfjs_require__2(28);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var IS_PURE = __w_pdfjs_require__2(36);
            var Iterators = __w_pdfjs_require__2(65);
            var IteratorsCore = __w_pdfjs_require__2(68);
            var IteratorPrototype = IteratorsCore.IteratorPrototype;
            var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
            var ITERATOR = wellKnownSymbol("iterator");
            var KEYS = "keys";
            var VALUES = "values";
            var ENTRIES = "entries";
            var returnThis = function() {
              return this;
            };
            module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
              createIteratorConstructor(IteratorConstructor, NAME, next);
              var getIterationMethod = function(KIND) {
                if (KIND === DEFAULT && defaultIterator)
                  return defaultIterator;
                if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                  return IterablePrototype[KIND];
                switch (KIND) {
                  case KEYS:
                    return function keys() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case VALUES:
                    return function values() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case ENTRIES:
                    return function entries() {
                      return new IteratorConstructor(this, KIND);
                    };
                }
                return function() {
                  return new IteratorConstructor(this);
                };
              };
              var TO_STRING_TAG = NAME + " Iterator";
              var INCORRECT_VALUES_NAME = false;
              var IterablePrototype = Iterable.prototype;
              var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
              var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
              var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
              var CurrentIteratorPrototype, methods, KEY;
              if (anyNativeIterator) {
                CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                  if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                    if (setPrototypeOf) {
                      setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                    } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                      createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                    }
                  }
                  setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                  if (IS_PURE)
                    Iterators[TO_STRING_TAG] = returnThis;
                }
              }
              if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                INCORRECT_VALUES_NAME = true;
                defaultIterator = function values() {
                  return nativeIterator.call(this);
                };
              }
              if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
              }
              Iterators[NAME] = defaultIterator;
              if (DEFAULT) {
                methods = {
                  values: getIterationMethod(VALUES),
                  keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                  entries: getIterationMethod(ENTRIES)
                };
                if (FORCED)
                  for (KEY in methods) {
                    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                      redefine(IterablePrototype, KEY, methods[KEY]);
                    }
                  }
                else
                  $({
                    target: NAME,
                    proto: true,
                    forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                  }, methods);
              }
              return methods;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var IteratorPrototype = __w_pdfjs_require__2(68).IteratorPrototype;
            var create = __w_pdfjs_require__2(61);
            var createPropertyDescriptor = __w_pdfjs_require__2(15);
            var setToStringTag = __w_pdfjs_require__2(72);
            var Iterators = __w_pdfjs_require__2(65);
            var returnThis = function() {
              return this;
            };
            module2.exports = function(IteratorConstructor, NAME, next) {
              var TO_STRING_TAG = NAME + " Iterator";
              IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
              setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
              Iterators[TO_STRING_TAG] = returnThis;
              return IteratorConstructor;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var fails = __w_pdfjs_require__2(13);
            var getPrototypeOf = __w_pdfjs_require__2(69);
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            var has = __w_pdfjs_require__2(22);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var IS_PURE = __w_pdfjs_require__2(36);
            var ITERATOR = wellKnownSymbol("iterator");
            var BUGGY_SAFARI_ITERATORS = false;
            var returnThis = function() {
              return this;
            };
            var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
            if ([].keys) {
              arrayIterator = [].keys();
              if (!("next" in arrayIterator))
                BUGGY_SAFARI_ITERATORS = true;
              else {
                PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                  IteratorPrototype = PrototypeOfArrayIteratorPrototype;
              }
            }
            var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
              var test = {};
              return IteratorPrototype[ITERATOR].call(test) !== test;
            });
            if (NEW_ITERATOR_PROTOTYPE)
              IteratorPrototype = {};
            if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
              createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
            }
            module2.exports = {
              IteratorPrototype,
              BUGGY_SAFARI_ITERATORS
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var has = __w_pdfjs_require__2(22);
            var toObject = __w_pdfjs_require__2(70);
            var sharedKey = __w_pdfjs_require__2(34);
            var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__2(71);
            var IE_PROTO = sharedKey("IE_PROTO");
            var ObjectPrototype = Object.prototype;
            module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO))
                return O[IE_PROTO];
              if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectPrototype : null;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var requireObjectCoercible = __w_pdfjs_require__2(19);
            module2.exports = function(argument) {
              return Object(requireObjectCoercible(argument));
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var fails = __w_pdfjs_require__2(13);
            module2.exports = !fails(function() {
              function F() {
              }
              F.prototype.constructor = null;
              return Object.getPrototypeOf(new F()) !== F.prototype;
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var defineProperty = __w_pdfjs_require__2(26).f;
            var has = __w_pdfjs_require__2(22);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            module2.exports = function(it, TAG, STATIC) {
              if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
                defineProperty(it, TO_STRING_TAG, {
                  configurable: true,
                  value: TAG
                });
              }
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var anObject = __w_pdfjs_require__2(27);
            var aPossiblePrototype = __w_pdfjs_require__2(74);
            module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var CORRECT_SETTER = false;
              var test = {};
              var setter;
              try {
                setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                setter.call(test, []);
                CORRECT_SETTER = test instanceof Array;
              } catch (error) {
              }
              return function setPrototypeOf(O, proto) {
                anObject(O);
                aPossiblePrototype(proto);
                if (CORRECT_SETTER)
                  setter.call(O, proto);
                else
                  O.__proto__ = proto;
                return O;
              };
            }() : void 0);
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var isObject = __w_pdfjs_require__2(21);
            module2.exports = function(it) {
              if (!isObject(it) && it !== null) {
                throw TypeError("Can't set " + String(it) + " as a prototype");
              }
              return it;
            };
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var $ = __w_pdfjs_require__2(9);
            var iterate = __w_pdfjs_require__2(76);
            var createProperty = __w_pdfjs_require__2(84);
            $({
              target: "Object",
              stat: true
            }, {
              fromEntries: function fromEntries(iterable) {
                var obj = {};
                iterate(iterable, function(k, v) {
                  createProperty(obj, k, v);
                }, { AS_ENTRIES: true });
                return obj;
              }
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var anObject = __w_pdfjs_require__2(27);
            var isArrayIteratorMethod = __w_pdfjs_require__2(77);
            var toLength = __w_pdfjs_require__2(46);
            var bind = __w_pdfjs_require__2(78);
            var getIteratorMethod = __w_pdfjs_require__2(80);
            var iteratorClose = __w_pdfjs_require__2(83);
            var Result = function(stopped, result) {
              this.stopped = stopped;
              this.result = result;
            };
            module2.exports = function(iterable, unboundFunction, options) {
              var that = options && options.that;
              var AS_ENTRIES = !!(options && options.AS_ENTRIES);
              var IS_ITERATOR = !!(options && options.IS_ITERATOR);
              var INTERRUPTED = !!(options && options.INTERRUPTED);
              var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
              var iterator, iterFn, index, length, result, next, step;
              var stop = function(condition) {
                if (iterator)
                  iteratorClose(iterator);
                return new Result(true, condition);
              };
              var callFn = function(value) {
                if (AS_ENTRIES) {
                  anObject(value);
                  return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
                }
                return INTERRUPTED ? fn(value, stop) : fn(value);
              };
              if (IS_ITERATOR) {
                iterator = iterable;
              } else {
                iterFn = getIteratorMethod(iterable);
                if (typeof iterFn != "function")
                  throw TypeError("Target is not iterable");
                if (isArrayIteratorMethod(iterFn)) {
                  for (index = 0, length = toLength(iterable.length); length > index; index++) {
                    result = callFn(iterable[index]);
                    if (result && result instanceof Result)
                      return result;
                  }
                  return new Result(false);
                }
                iterator = iterFn.call(iterable);
              }
              next = iterator.next;
              while (!(step = next.call(iterator)).done) {
                try {
                  result = callFn(step.value);
                } catch (error) {
                  iteratorClose(iterator);
                  throw error;
                }
                if (typeof result == "object" && result && result instanceof Result)
                  return result;
              }
              return new Result(false);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var Iterators = __w_pdfjs_require__2(65);
            var ITERATOR = wellKnownSymbol("iterator");
            var ArrayPrototype = Array.prototype;
            module2.exports = function(it) {
              return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var aFunction = __w_pdfjs_require__2(79);
            module2.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0)
                return fn;
              switch (length) {
                case 0:
                  return function() {
                    return fn.call(that);
                  };
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          (module2) => {
            module2.exports = function(it) {
              if (typeof it != "function") {
                throw TypeError(String(it) + " is not a function");
              }
              return it;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var classof = __w_pdfjs_require__2(81);
            var Iterators = __w_pdfjs_require__2(65);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var ITERATOR = wellKnownSymbol("iterator");
            module2.exports = function(it) {
              if (it != void 0)
                return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(82);
            var classofRaw = __w_pdfjs_require__2(18);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var CORRECT_ARGUMENTS = classofRaw(function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it, key) {
              try {
                return it[key];
              } catch (error) {
              }
            };
            module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
              var O, tag, result;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var test = {};
            test[TO_STRING_TAG] = "z";
            module2.exports = String(test) === "[object z]";
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var anObject = __w_pdfjs_require__2(27);
            module2.exports = function(iterator) {
              var returnMethod = iterator["return"];
              if (returnMethod !== void 0) {
                return anObject(returnMethod.call(iterator)).value;
              }
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var toPrimitive = __w_pdfjs_require__2(20);
            var definePropertyModule = __w_pdfjs_require__2(26);
            var createPropertyDescriptor = __w_pdfjs_require__2(15);
            module2.exports = function(object, key, value) {
              var propertyKey = toPrimitive(key);
              if (propertyKey in object)
                definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
              else
                object[propertyKey] = value;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            __w_pdfjs_require__2(86);
            __w_pdfjs_require__2(87);
            __w_pdfjs_require__2(89);
            __w_pdfjs_require__2(104);
            __w_pdfjs_require__2(105);
            __w_pdfjs_require__2(106);
            __w_pdfjs_require__2(107);
            __w_pdfjs_require__2(109);
            var path = __w_pdfjs_require__2(42);
            module2.exports = path.Promise;
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var getPrototypeOf = __w_pdfjs_require__2(69);
            var setPrototypeOf = __w_pdfjs_require__2(73);
            var create = __w_pdfjs_require__2(61);
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            var createPropertyDescriptor = __w_pdfjs_require__2(15);
            var iterate = __w_pdfjs_require__2(76);
            var $AggregateError = function AggregateError(errors, message) {
              var that = this;
              if (!(that instanceof $AggregateError))
                return new $AggregateError(errors, message);
              if (setPrototypeOf) {
                that = setPrototypeOf(new Error(void 0), getPrototypeOf(that));
              }
              if (message !== void 0)
                createNonEnumerableProperty(that, "message", String(message));
              var errorsArray = [];
              iterate(errors, errorsArray.push, { that: errorsArray });
              createNonEnumerableProperty(that, "errors", errorsArray);
              return that;
            };
            $AggregateError.prototype = create(Error.prototype, {
              constructor: createPropertyDescriptor(5, $AggregateError),
              message: createPropertyDescriptor(5, ""),
              name: createPropertyDescriptor(5, "AggregateError")
            });
            $({ global: true }, { AggregateError: $AggregateError });
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(82);
            var redefine = __w_pdfjs_require__2(28);
            var toString = __w_pdfjs_require__2(88);
            if (!TO_STRING_TAG_SUPPORT) {
              redefine(Object.prototype, "toString", toString, { unsafe: true });
            }
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(82);
            var classof = __w_pdfjs_require__2(81);
            module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
              return "[object " + classof(this) + "]";
            };
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var IS_PURE = __w_pdfjs_require__2(36);
            var global2 = __w_pdfjs_require__2(10);
            var getBuiltIn = __w_pdfjs_require__2(41);
            var NativePromise = __w_pdfjs_require__2(90);
            var redefine = __w_pdfjs_require__2(28);
            var redefineAll = __w_pdfjs_require__2(91);
            var setToStringTag = __w_pdfjs_require__2(72);
            var setSpecies = __w_pdfjs_require__2(92);
            var isObject = __w_pdfjs_require__2(21);
            var aFunction = __w_pdfjs_require__2(79);
            var anInstance = __w_pdfjs_require__2(93);
            var inspectSource = __w_pdfjs_require__2(30);
            var iterate = __w_pdfjs_require__2(76);
            var checkCorrectnessOfIteration = __w_pdfjs_require__2(94);
            var speciesConstructor = __w_pdfjs_require__2(95);
            var task = __w_pdfjs_require__2(96).set;
            var microtask = __w_pdfjs_require__2(98);
            var promiseResolve = __w_pdfjs_require__2(100);
            var hostReportErrors = __w_pdfjs_require__2(102);
            var newPromiseCapabilityModule = __w_pdfjs_require__2(101);
            var perform = __w_pdfjs_require__2(103);
            var InternalStateModule = __w_pdfjs_require__2(32);
            var isForced = __w_pdfjs_require__2(51);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var IS_NODE = __w_pdfjs_require__2(57);
            var V8_VERSION = __w_pdfjs_require__2(58);
            var SPECIES = wellKnownSymbol("species");
            var PROMISE = "Promise";
            var getInternalState = InternalStateModule.get;
            var setInternalState = InternalStateModule.set;
            var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
            var PromiseConstructor = NativePromise;
            var TypeError2 = global2.TypeError;
            var document2 = global2.document;
            var process2 = global2.process;
            var $fetch = getBuiltIn("fetch");
            var newPromiseCapability = newPromiseCapabilityModule.f;
            var newGenericPromiseCapability = newPromiseCapability;
            var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
            var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == "function";
            var UNHANDLED_REJECTION = "unhandledrejection";
            var REJECTION_HANDLED = "rejectionhandled";
            var PENDING = 0;
            var FULFILLED = 1;
            var REJECTED = 2;
            var HANDLED = 1;
            var UNHANDLED = 2;
            var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
            var FORCED = isForced(PROMISE, function() {
              var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
              if (!GLOBAL_CORE_JS_PROMISE) {
                if (V8_VERSION === 66)
                  return true;
                if (!IS_NODE && !NATIVE_REJECTION_EVENT)
                  return true;
              }
              if (IS_PURE && !PromiseConstructor.prototype["finally"])
                return true;
              if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor))
                return false;
              var promise = PromiseConstructor.resolve(1);
              var FakePromise = function(exec) {
                exec(function() {
                }, function() {
                });
              };
              var constructor = promise.constructor = {};
              constructor[SPECIES] = FakePromise;
              return !(promise.then(function() {
              }) instanceof FakePromise);
            });
            var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
              PromiseConstructor.all(iterable)["catch"](function() {
              });
            });
            var isThenable = function(it) {
              var then;
              return isObject(it) && typeof (then = it.then) == "function" ? then : false;
            };
            var notify = function(state, isReject) {
              if (state.notified)
                return;
              state.notified = true;
              var chain = state.reactions;
              microtask(function() {
                var value = state.value;
                var ok = state.state == FULFILLED;
                var index = 0;
                while (chain.length > index) {
                  var reaction = chain[index++];
                  var handler = ok ? reaction.ok : reaction.fail;
                  var resolve = reaction.resolve;
                  var reject = reaction.reject;
                  var domain = reaction.domain;
                  var result, then, exited;
                  try {
                    if (handler) {
                      if (!ok) {
                        if (state.rejection === UNHANDLED)
                          onHandleUnhandled(state);
                        state.rejection = HANDLED;
                      }
                      if (handler === true)
                        result = value;
                      else {
                        if (domain)
                          domain.enter();
                        result = handler(value);
                        if (domain) {
                          domain.exit();
                          exited = true;
                        }
                      }
                      if (result === reaction.promise) {
                        reject(TypeError2("Promise-chain cycle"));
                      } else if (then = isThenable(result)) {
                        then.call(result, resolve, reject);
                      } else
                        resolve(result);
                    } else
                      reject(value);
                  } catch (error) {
                    if (domain && !exited)
                      domain.exit();
                    reject(error);
                  }
                }
                state.reactions = [];
                state.notified = false;
                if (isReject && !state.rejection)
                  onUnhandled(state);
              });
            };
            var dispatchEvent = function(name, promise, reason) {
              var event, handler;
              if (DISPATCH_EVENT) {
                event = document2.createEvent("Event");
                event.promise = promise;
                event.reason = reason;
                event.initEvent(name, false, true);
                global2.dispatchEvent(event);
              } else
                event = {
                  promise,
                  reason
                };
              if (!NATIVE_REJECTION_EVENT && (handler = global2["on" + name]))
                handler(event);
              else if (name === UNHANDLED_REJECTION)
                hostReportErrors("Unhandled promise rejection", reason);
            };
            var onUnhandled = function(state) {
              task.call(global2, function() {
                var promise = state.facade;
                var value = state.value;
                var IS_UNHANDLED = isUnhandled(state);
                var result;
                if (IS_UNHANDLED) {
                  result = perform(function() {
                    if (IS_NODE) {
                      process2.emit("unhandledRejection", value, promise);
                    } else
                      dispatchEvent(UNHANDLED_REJECTION, promise, value);
                  });
                  state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
                  if (result.error)
                    throw result.value;
                }
              });
            };
            var isUnhandled = function(state) {
              return state.rejection !== HANDLED && !state.parent;
            };
            var onHandleUnhandled = function(state) {
              task.call(global2, function() {
                var promise = state.facade;
                if (IS_NODE) {
                  process2.emit("rejectionHandled", promise);
                } else
                  dispatchEvent(REJECTION_HANDLED, promise, state.value);
              });
            };
            var bind = function(fn, state, unwrap) {
              return function(value) {
                fn(state, value, unwrap);
              };
            };
            var internalReject = function(state, value, unwrap) {
              if (state.done)
                return;
              state.done = true;
              if (unwrap)
                state = unwrap;
              state.value = value;
              state.state = REJECTED;
              notify(state, true);
            };
            var internalResolve = function(state, value, unwrap) {
              if (state.done)
                return;
              state.done = true;
              if (unwrap)
                state = unwrap;
              try {
                if (state.facade === value)
                  throw TypeError2("Promise can't be resolved itself");
                var then = isThenable(value);
                if (then) {
                  microtask(function() {
                    var wrapper = { done: false };
                    try {
                      then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
                    } catch (error) {
                      internalReject(wrapper, error, state);
                    }
                  });
                } else {
                  state.value = value;
                  state.state = FULFILLED;
                  notify(state, false);
                }
              } catch (error) {
                internalReject({ done: false }, error, state);
              }
            };
            if (FORCED) {
              PromiseConstructor = function Promise2(executor) {
                anInstance(this, PromiseConstructor, PROMISE);
                aFunction(executor);
                Internal.call(this);
                var state = getInternalState(this);
                try {
                  executor(bind(internalResolve, state), bind(internalReject, state));
                } catch (error) {
                  internalReject(state, error);
                }
              };
              Internal = function Promise2(executor) {
                setInternalState(this, {
                  type: PROMISE,
                  done: false,
                  notified: false,
                  parent: false,
                  reactions: [],
                  rejection: false,
                  state: PENDING,
                  value: void 0
                });
              };
              Internal.prototype = redefineAll(PromiseConstructor.prototype, {
                then: function then(onFulfilled, onRejected) {
                  var state = getInternalPromiseState(this);
                  var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
                  reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
                  reaction.fail = typeof onRejected == "function" && onRejected;
                  reaction.domain = IS_NODE ? process2.domain : void 0;
                  state.parent = true;
                  state.reactions.push(reaction);
                  if (state.state != PENDING)
                    notify(state, false);
                  return reaction.promise;
                },
                "catch": function(onRejected) {
                  return this.then(void 0, onRejected);
                }
              });
              OwnPromiseCapability = function() {
                var promise = new Internal();
                var state = getInternalState(promise);
                this.promise = promise;
                this.resolve = bind(internalResolve, state);
                this.reject = bind(internalReject, state);
              };
              newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
                return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
              };
              if (!IS_PURE && typeof NativePromise == "function") {
                nativeThen = NativePromise.prototype.then;
                redefine(NativePromise.prototype, "then", function then(onFulfilled, onRejected) {
                  var that = this;
                  return new PromiseConstructor(function(resolve, reject) {
                    nativeThen.call(that, resolve, reject);
                  }).then(onFulfilled, onRejected);
                }, { unsafe: true });
                if (typeof $fetch == "function")
                  $({
                    global: true,
                    enumerable: true,
                    forced: true
                  }, {
                    fetch: function fetch2(input) {
                      return promiseResolve(PromiseConstructor, $fetch.apply(global2, arguments));
                    }
                  });
              }
            }
            $({
              global: true,
              wrap: true,
              forced: FORCED
            }, { Promise: PromiseConstructor });
            setToStringTag(PromiseConstructor, PROMISE, false, true);
            setSpecies(PROMISE);
            PromiseWrapper = getBuiltIn(PROMISE);
            $({
              target: PROMISE,
              stat: true,
              forced: FORCED
            }, {
              reject: function reject(r) {
                var capability = newPromiseCapability(this);
                capability.reject.call(void 0, r);
                return capability.promise;
              }
            });
            $({
              target: PROMISE,
              stat: true,
              forced: IS_PURE || FORCED
            }, {
              resolve: function resolve(x) {
                return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
              }
            });
            $({
              target: PROMISE,
              stat: true,
              forced: INCORRECT_ITERATION
            }, {
              all: function all(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var resolve = capability.resolve;
                var reject = capability.reject;
                var result = perform(function() {
                  var $promiseResolve = aFunction(C.resolve);
                  var values = [];
                  var counter = 0;
                  var remaining = 1;
                  iterate(iterable, function(promise) {
                    var index = counter++;
                    var alreadyCalled = false;
                    values.push(void 0);
                    remaining++;
                    $promiseResolve.call(C, promise).then(function(value) {
                      if (alreadyCalled)
                        return;
                      alreadyCalled = true;
                      values[index] = value;
                      --remaining || resolve(values);
                    }, reject);
                  });
                  --remaining || resolve(values);
                });
                if (result.error)
                  reject(result.value);
                return capability.promise;
              },
              race: function race(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var reject = capability.reject;
                var result = perform(function() {
                  var $promiseResolve = aFunction(C.resolve);
                  iterate(iterable, function(promise) {
                    $promiseResolve.call(C, promise).then(capability.resolve, reject);
                  });
                });
                if (result.error)
                  reject(result.value);
                return capability.promise;
              }
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            module2.exports = global2.Promise;
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var redefine = __w_pdfjs_require__2(28);
            module2.exports = function(target, src, options) {
              for (var key in src)
                redefine(target, key, src[key], options);
              return target;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var getBuiltIn = __w_pdfjs_require__2(41);
            var definePropertyModule = __w_pdfjs_require__2(26);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var DESCRIPTORS = __w_pdfjs_require__2(12);
            var SPECIES = wellKnownSymbol("species");
            module2.exports = function(CONSTRUCTOR_NAME) {
              var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
              var defineProperty = definePropertyModule.f;
              if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                defineProperty(Constructor, SPECIES, {
                  configurable: true,
                  get: function() {
                    return this;
                  }
                });
              }
            };
          },
          (module2) => {
            module2.exports = function(it, Constructor, name) {
              if (!(it instanceof Constructor)) {
                throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
              }
              return it;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var ITERATOR = wellKnownSymbol("iterator");
            var SAFE_CLOSING = false;
            try {
              var called = 0;
              var iteratorWithReturn = {
                next: function() {
                  return { done: !!called++ };
                },
                "return": function() {
                  SAFE_CLOSING = true;
                }
              };
              iteratorWithReturn[ITERATOR] = function() {
                return this;
              };
              Array.from(iteratorWithReturn, function() {
                throw 2;
              });
            } catch (error) {
            }
            module2.exports = function(exec, SKIP_CLOSING) {
              if (!SKIP_CLOSING && !SAFE_CLOSING)
                return false;
              var ITERATION_SUPPORT = false;
              try {
                var object = {};
                object[ITERATOR] = function() {
                  return {
                    next: function() {
                      return { done: ITERATION_SUPPORT = true };
                    }
                  };
                };
                exec(object);
              } catch (error) {
              }
              return ITERATION_SUPPORT;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var anObject = __w_pdfjs_require__2(27);
            var aFunction = __w_pdfjs_require__2(79);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var SPECIES = wellKnownSymbol("species");
            module2.exports = function(O, defaultConstructor) {
              var C = anObject(O).constructor;
              var S;
              return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aFunction(S);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var fails = __w_pdfjs_require__2(13);
            var bind = __w_pdfjs_require__2(78);
            var html = __w_pdfjs_require__2(64);
            var createElement = __w_pdfjs_require__2(24);
            var IS_IOS = __w_pdfjs_require__2(97);
            var IS_NODE = __w_pdfjs_require__2(57);
            var location = global2.location;
            var set = global2.setImmediate;
            var clear = global2.clearImmediate;
            var process2 = global2.process;
            var MessageChannel = global2.MessageChannel;
            var Dispatch = global2.Dispatch;
            var counter = 0;
            var queue = {};
            var ONREADYSTATECHANGE = "onreadystatechange";
            var defer, channel, port;
            var run = function(id) {
              if (queue.hasOwnProperty(id)) {
                var fn = queue[id];
                delete queue[id];
                fn();
              }
            };
            var runner = function(id) {
              return function() {
                run(id);
              };
            };
            var listener = function(event) {
              run(event.data);
            };
            var post = function(id) {
              global2.postMessage(id + "", location.protocol + "//" + location.host);
            };
            if (!set || !clear) {
              set = function setImmediate(fn) {
                var args = [];
                var i = 1;
                while (arguments.length > i)
                  args.push(arguments[i++]);
                queue[++counter] = function() {
                  (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
                };
                defer(counter);
                return counter;
              };
              clear = function clearImmediate(id) {
                delete queue[id];
              };
              if (IS_NODE) {
                defer = function(id) {
                  process2.nextTick(runner(id));
                };
              } else if (Dispatch && Dispatch.now) {
                defer = function(id) {
                  Dispatch.now(runner(id));
                };
              } else if (MessageChannel && !IS_IOS) {
                channel = new MessageChannel();
                port = channel.port2;
                channel.port1.onmessage = listener;
                defer = bind(port.postMessage, port, 1);
              } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts && location && location.protocol !== "file:" && !fails(post)) {
                defer = post;
                global2.addEventListener("message", listener, false);
              } else if (ONREADYSTATECHANGE in createElement("script")) {
                defer = function(id) {
                  html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
                    html.removeChild(this);
                    run(id);
                  };
                };
              } else {
                defer = function(id) {
                  setTimeout(runner(id), 0);
                };
              }
            }
            module2.exports = {
              set,
              clear
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var userAgent = __w_pdfjs_require__2(59);
            module2.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var getOwnPropertyDescriptor = __w_pdfjs_require__2(11).f;
            var macrotask = __w_pdfjs_require__2(96).set;
            var IS_IOS = __w_pdfjs_require__2(97);
            var IS_WEBOS_WEBKIT = __w_pdfjs_require__2(99);
            var IS_NODE = __w_pdfjs_require__2(57);
            var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
            var document2 = global2.document;
            var process2 = global2.process;
            var Promise2 = global2.Promise;
            var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
            var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
            var flush, head, last, notify, toggle, node, promise, then;
            if (!queueMicrotask) {
              flush = function() {
                var parent, fn;
                if (IS_NODE && (parent = process2.domain))
                  parent.exit();
                while (head) {
                  fn = head.fn;
                  head = head.next;
                  try {
                    fn();
                  } catch (error) {
                    if (head)
                      notify();
                    else
                      last = void 0;
                    throw error;
                  }
                }
                last = void 0;
                if (parent)
                  parent.enter();
              };
              if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
                toggle = true;
                node = document2.createTextNode("");
                new MutationObserver(flush).observe(node, { characterData: true });
                notify = function() {
                  node.data = toggle = !toggle;
                };
              } else if (Promise2 && Promise2.resolve) {
                promise = Promise2.resolve(void 0);
                then = promise.then;
                notify = function() {
                  then.call(promise, flush);
                };
              } else if (IS_NODE) {
                notify = function() {
                  process2.nextTick(flush);
                };
              } else {
                notify = function() {
                  macrotask.call(global2, flush);
                };
              }
            }
            module2.exports = queueMicrotask || function(fn) {
              var task = {
                fn,
                next: void 0
              };
              if (last)
                last.next = task;
              if (!head) {
                head = task;
                notify();
              }
              last = task;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var userAgent = __w_pdfjs_require__2(59);
            module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var anObject = __w_pdfjs_require__2(27);
            var isObject = __w_pdfjs_require__2(21);
            var newPromiseCapability = __w_pdfjs_require__2(101);
            module2.exports = function(C, x) {
              anObject(C);
              if (isObject(x) && x.constructor === C)
                return x;
              var promiseCapability = newPromiseCapability.f(C);
              var resolve = promiseCapability.resolve;
              resolve(x);
              return promiseCapability.promise;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var aFunction = __w_pdfjs_require__2(79);
            var PromiseCapability = function(C) {
              var resolve, reject;
              this.promise = new C(function($$resolve, $$reject) {
                if (resolve !== void 0 || reject !== void 0)
                  throw TypeError("Bad Promise constructor");
                resolve = $$resolve;
                reject = $$reject;
              });
              this.resolve = aFunction(resolve);
              this.reject = aFunction(reject);
            };
            module2.exports.f = function(C) {
              return new PromiseCapability(C);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            module2.exports = function(a, b) {
              var console2 = global2.console;
              if (console2 && console2.error) {
                arguments.length === 1 ? console2.error(a) : console2.error(a, b);
              }
            };
          },
          (module2) => {
            module2.exports = function(exec) {
              try {
                return {
                  error: false,
                  value: exec()
                };
              } catch (error) {
                return {
                  error: true,
                  value: error
                };
              }
            };
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var aFunction = __w_pdfjs_require__2(79);
            var newPromiseCapabilityModule = __w_pdfjs_require__2(101);
            var perform = __w_pdfjs_require__2(103);
            var iterate = __w_pdfjs_require__2(76);
            $({
              target: "Promise",
              stat: true
            }, {
              allSettled: function allSettled(iterable) {
                var C = this;
                var capability = newPromiseCapabilityModule.f(C);
                var resolve = capability.resolve;
                var reject = capability.reject;
                var result = perform(function() {
                  var promiseResolve = aFunction(C.resolve);
                  var values = [];
                  var counter = 0;
                  var remaining = 1;
                  iterate(iterable, function(promise) {
                    var index = counter++;
                    var alreadyCalled = false;
                    values.push(void 0);
                    remaining++;
                    promiseResolve.call(C, promise).then(function(value) {
                      if (alreadyCalled)
                        return;
                      alreadyCalled = true;
                      values[index] = {
                        status: "fulfilled",
                        value
                      };
                      --remaining || resolve(values);
                    }, function(error) {
                      if (alreadyCalled)
                        return;
                      alreadyCalled = true;
                      values[index] = {
                        status: "rejected",
                        reason: error
                      };
                      --remaining || resolve(values);
                    });
                  });
                  --remaining || resolve(values);
                });
                if (result.error)
                  reject(result.value);
                return capability.promise;
              }
            });
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var aFunction = __w_pdfjs_require__2(79);
            var getBuiltIn = __w_pdfjs_require__2(41);
            var newPromiseCapabilityModule = __w_pdfjs_require__2(101);
            var perform = __w_pdfjs_require__2(103);
            var iterate = __w_pdfjs_require__2(76);
            var PROMISE_ANY_ERROR = "No one promise resolved";
            $({
              target: "Promise",
              stat: true
            }, {
              any: function any(iterable) {
                var C = this;
                var capability = newPromiseCapabilityModule.f(C);
                var resolve = capability.resolve;
                var reject = capability.reject;
                var result = perform(function() {
                  var promiseResolve = aFunction(C.resolve);
                  var errors = [];
                  var counter = 0;
                  var remaining = 1;
                  var alreadyResolved = false;
                  iterate(iterable, function(promise) {
                    var index = counter++;
                    var alreadyRejected = false;
                    errors.push(void 0);
                    remaining++;
                    promiseResolve.call(C, promise).then(function(value) {
                      if (alreadyRejected || alreadyResolved)
                        return;
                      alreadyResolved = true;
                      resolve(value);
                    }, function(error) {
                      if (alreadyRejected || alreadyResolved)
                        return;
                      alreadyRejected = true;
                      errors[index] = error;
                      --remaining || reject(new (getBuiltIn("AggregateError"))(errors, PROMISE_ANY_ERROR));
                    });
                  });
                  --remaining || reject(new (getBuiltIn("AggregateError"))(errors, PROMISE_ANY_ERROR));
                });
                if (result.error)
                  reject(result.value);
                return capability.promise;
              }
            });
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var IS_PURE = __w_pdfjs_require__2(36);
            var NativePromise = __w_pdfjs_require__2(90);
            var fails = __w_pdfjs_require__2(13);
            var getBuiltIn = __w_pdfjs_require__2(41);
            var speciesConstructor = __w_pdfjs_require__2(95);
            var promiseResolve = __w_pdfjs_require__2(100);
            var redefine = __w_pdfjs_require__2(28);
            var NON_GENERIC = !!NativePromise && fails(function() {
              NativePromise.prototype["finally"].call({
                then: function() {
                }
              }, function() {
              });
            });
            $({
              target: "Promise",
              proto: true,
              real: true,
              forced: NON_GENERIC
            }, {
              "finally": function(onFinally) {
                var C = speciesConstructor(this, getBuiltIn("Promise"));
                var isFunction = typeof onFinally == "function";
                return this.then(isFunction ? function(x) {
                  return promiseResolve(C, onFinally()).then(function() {
                    return x;
                  });
                } : onFinally, isFunction ? function(e) {
                  return promiseResolve(C, onFinally()).then(function() {
                    throw e;
                  });
                } : onFinally);
              }
            });
            if (!IS_PURE && typeof NativePromise == "function" && !NativePromise.prototype["finally"]) {
              redefine(NativePromise.prototype, "finally", getBuiltIn("Promise").prototype["finally"]);
            }
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var charAt = __w_pdfjs_require__2(108).charAt;
            var InternalStateModule = __w_pdfjs_require__2(32);
            var defineIterator = __w_pdfjs_require__2(66);
            var STRING_ITERATOR = "String Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
            defineIterator(String, "String", function(iterated) {
              setInternalState(this, {
                type: STRING_ITERATOR,
                string: String(iterated),
                index: 0
              });
            }, function next() {
              var state = getInternalState(this);
              var string = state.string;
              var index = state.index;
              var point;
              if (index >= string.length)
                return {
                  value: void 0,
                  done: true
                };
              point = charAt(string, index);
              state.index += point.length;
              return {
                value: point,
                done: false
              };
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var toInteger = __w_pdfjs_require__2(47);
            var requireObjectCoercible = __w_pdfjs_require__2(19);
            var createMethod = function(CONVERT_TO_STRING) {
              return function($this, pos) {
                var S = String(requireObjectCoercible($this));
                var position = toInteger(pos);
                var size = S.length;
                var first, second;
                if (position < 0 || position >= size)
                  return CONVERT_TO_STRING ? "" : void 0;
                first = S.charCodeAt(position);
                return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
              };
            };
            module2.exports = {
              codeAt: createMethod(false),
              charAt: createMethod(true)
            };
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var DOMIterables = __w_pdfjs_require__2(110);
            var ArrayIteratorMethods = __w_pdfjs_require__2(53);
            var createNonEnumerableProperty = __w_pdfjs_require__2(25);
            var wellKnownSymbol = __w_pdfjs_require__2(55);
            var ITERATOR = wellKnownSymbol("iterator");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var ArrayValues = ArrayIteratorMethods.values;
            for (var COLLECTION_NAME in DOMIterables) {
              var Collection = global2[COLLECTION_NAME];
              var CollectionPrototype = Collection && Collection.prototype;
              if (CollectionPrototype) {
                if (CollectionPrototype[ITERATOR] !== ArrayValues)
                  try {
                    createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                  } catch (error) {
                    CollectionPrototype[ITERATOR] = ArrayValues;
                  }
                if (!CollectionPrototype[TO_STRING_TAG]) {
                  createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                }
                if (DOMIterables[COLLECTION_NAME])
                  for (var METHOD_NAME in ArrayIteratorMethods) {
                    if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                      try {
                        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                      } catch (error) {
                        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                      }
                  }
              }
            }
          },
          (module2) => {
            module2.exports = {
              CSSRuleList: 0,
              CSSStyleDeclaration: 0,
              CSSValueList: 0,
              ClientRectList: 0,
              DOMRectList: 0,
              DOMStringList: 0,
              DOMTokenList: 1,
              DataTransferItemList: 0,
              FileList: 0,
              HTMLAllCollection: 0,
              HTMLCollection: 0,
              HTMLFormElement: 0,
              HTMLSelectElement: 0,
              MediaList: 0,
              MimeTypeArray: 0,
              NamedNodeMap: 0,
              NodeList: 1,
              PaintRequestList: 0,
              Plugin: 0,
              PluginArray: 0,
              SVGLengthList: 0,
              SVGNumberList: 0,
              SVGPathSegList: 0,
              SVGPointList: 0,
              SVGStringList: 0,
              SVGTransformList: 0,
              SourceBufferList: 0,
              StyleSheetList: 0,
              TextTrackCueList: 0,
              TextTrackList: 0,
              TouchList: 0
            };
          },
          function(__unused_webpack_module2, exports2) {
            (function(global2, factory) {
              true ? factory(exports2) : 0;
            })(this, function(exports3) {
              "use strict";
              var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
                return "Symbol(" + description + ")";
              };
              function noop() {
              }
              function getGlobals() {
                if (typeof self !== "undefined") {
                  return self;
                } else if (typeof window !== "undefined") {
                  return window;
                } else if (typeof global !== "undefined") {
                  return global;
                }
                return void 0;
              }
              var globals = getGlobals();
              function typeIsObject(x) {
                return typeof x === "object" && x !== null || typeof x === "function";
              }
              var rethrowAssertionErrorRejection = noop;
              var originalPromise = Promise;
              var originalPromiseThen = Promise.prototype.then;
              var originalPromiseResolve = Promise.resolve.bind(originalPromise);
              var originalPromiseReject = Promise.reject.bind(originalPromise);
              function newPromise(executor) {
                return new originalPromise(executor);
              }
              function promiseResolvedWith(value) {
                return originalPromiseResolve(value);
              }
              function promiseRejectedWith(reason) {
                return originalPromiseReject(reason);
              }
              function PerformPromiseThen(promise, onFulfilled, onRejected) {
                return originalPromiseThen.call(promise, onFulfilled, onRejected);
              }
              function uponPromise(promise, onFulfilled, onRejected) {
                PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
              }
              function uponFulfillment(promise, onFulfilled) {
                uponPromise(promise, onFulfilled);
              }
              function uponRejection(promise, onRejected) {
                uponPromise(promise, void 0, onRejected);
              }
              function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
                return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
              }
              function setPromiseIsHandledToTrue(promise) {
                PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
              }
              var queueMicrotask = function() {
                var globalQueueMicrotask = globals && globals.queueMicrotask;
                if (typeof globalQueueMicrotask === "function") {
                  return globalQueueMicrotask;
                }
                var resolvedPromise = promiseResolvedWith(void 0);
                return function(fn) {
                  return PerformPromiseThen(resolvedPromise, fn);
                };
              }();
              function reflectCall(F, V, args) {
                if (typeof F !== "function") {
                  throw new TypeError("Argument is not a function");
                }
                return Function.prototype.apply.call(F, V, args);
              }
              function promiseCall(F, V, args) {
                try {
                  return promiseResolvedWith(reflectCall(F, V, args));
                } catch (value) {
                  return promiseRejectedWith(value);
                }
              }
              var QUEUE_MAX_ARRAY_SIZE = 16384;
              var SimpleQueue = function() {
                function SimpleQueue2() {
                  this._cursor = 0;
                  this._size = 0;
                  this._front = {
                    _elements: [],
                    _next: void 0
                  };
                  this._back = this._front;
                  this._cursor = 0;
                  this._size = 0;
                }
                Object.defineProperty(SimpleQueue2.prototype, "length", {
                  get: function() {
                    return this._size;
                  },
                  enumerable: false,
                  configurable: true
                });
                SimpleQueue2.prototype.push = function(element) {
                  var oldBack = this._back;
                  var newBack = oldBack;
                  if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                    newBack = {
                      _elements: [],
                      _next: void 0
                    };
                  }
                  oldBack._elements.push(element);
                  if (newBack !== oldBack) {
                    this._back = newBack;
                    oldBack._next = newBack;
                  }
                  ++this._size;
                };
                SimpleQueue2.prototype.shift = function() {
                  var oldFront = this._front;
                  var newFront = oldFront;
                  var oldCursor = this._cursor;
                  var newCursor = oldCursor + 1;
                  var elements = oldFront._elements;
                  var element = elements[oldCursor];
                  if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                    newFront = oldFront._next;
                    newCursor = 0;
                  }
                  --this._size;
                  this._cursor = newCursor;
                  if (oldFront !== newFront) {
                    this._front = newFront;
                  }
                  elements[oldCursor] = void 0;
                  return element;
                };
                SimpleQueue2.prototype.forEach = function(callback) {
                  var i = this._cursor;
                  var node = this._front;
                  var elements = node._elements;
                  while (i !== elements.length || node._next !== void 0) {
                    if (i === elements.length) {
                      node = node._next;
                      elements = node._elements;
                      i = 0;
                      if (elements.length === 0) {
                        break;
                      }
                    }
                    callback(elements[i]);
                    ++i;
                  }
                };
                SimpleQueue2.prototype.peek = function() {
                  var front = this._front;
                  var cursor = this._cursor;
                  return front._elements[cursor];
                };
                return SimpleQueue2;
              }();
              function ReadableStreamReaderGenericInitialize(reader, stream) {
                reader._ownerReadableStream = stream;
                stream._reader = reader;
                if (stream._state === "readable") {
                  defaultReaderClosedPromiseInitialize(reader);
                } else if (stream._state === "closed") {
                  defaultReaderClosedPromiseInitializeAsResolved(reader);
                } else {
                  defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
                }
              }
              function ReadableStreamReaderGenericCancel(reader, reason) {
                var stream = reader._ownerReadableStream;
                return ReadableStreamCancel(stream, reason);
              }
              function ReadableStreamReaderGenericRelease(reader) {
                if (reader._ownerReadableStream._state === "readable") {
                  defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                } else {
                  defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                }
                reader._ownerReadableStream._reader = void 0;
                reader._ownerReadableStream = void 0;
              }
              function readerLockException(name) {
                return new TypeError("Cannot " + name + " a stream using a released reader");
              }
              function defaultReaderClosedPromiseInitialize(reader) {
                reader._closedPromise = newPromise(function(resolve, reject) {
                  reader._closedPromise_resolve = resolve;
                  reader._closedPromise_reject = reject;
                });
              }
              function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
                defaultReaderClosedPromiseInitialize(reader);
                defaultReaderClosedPromiseReject(reader, reason);
              }
              function defaultReaderClosedPromiseInitializeAsResolved(reader) {
                defaultReaderClosedPromiseInitialize(reader);
                defaultReaderClosedPromiseResolve(reader);
              }
              function defaultReaderClosedPromiseReject(reader, reason) {
                if (reader._closedPromise_reject === void 0) {
                  return;
                }
                setPromiseIsHandledToTrue(reader._closedPromise);
                reader._closedPromise_reject(reason);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              function defaultReaderClosedPromiseResetToRejected(reader, reason) {
                defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
              }
              function defaultReaderClosedPromiseResolve(reader) {
                if (reader._closedPromise_resolve === void 0) {
                  return;
                }
                reader._closedPromise_resolve(void 0);
                reader._closedPromise_resolve = void 0;
                reader._closedPromise_reject = void 0;
              }
              var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
              var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
              var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
              var PullSteps = SymbolPolyfill("[[PullSteps]]");
              var NumberIsFinite = Number.isFinite || function(x) {
                return typeof x === "number" && isFinite(x);
              };
              var MathTrunc = Math.trunc || function(v) {
                return v < 0 ? Math.ceil(v) : Math.floor(v);
              };
              function isDictionary(x) {
                return typeof x === "object" || typeof x === "function";
              }
              function assertDictionary(obj, context) {
                if (obj !== void 0 && !isDictionary(obj)) {
                  throw new TypeError(context + " is not an object.");
                }
              }
              function assertFunction(x, context) {
                if (typeof x !== "function") {
                  throw new TypeError(context + " is not a function.");
                }
              }
              function isObject(x) {
                return typeof x === "object" && x !== null || typeof x === "function";
              }
              function assertObject(x, context) {
                if (!isObject(x)) {
                  throw new TypeError(context + " is not an object.");
                }
              }
              function assertRequiredArgument(x, position, context) {
                if (x === void 0) {
                  throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
                }
              }
              function assertRequiredField(x, field, context) {
                if (x === void 0) {
                  throw new TypeError(field + " is required in '" + context + "'.");
                }
              }
              function convertUnrestrictedDouble(value) {
                return Number(value);
              }
              function censorNegativeZero(x) {
                return x === 0 ? 0 : x;
              }
              function integerPart(x) {
                return censorNegativeZero(MathTrunc(x));
              }
              function convertUnsignedLongLongWithEnforceRange(value, context) {
                var lowerBound = 0;
                var upperBound = Number.MAX_SAFE_INTEGER;
                var x = Number(value);
                x = censorNegativeZero(x);
                if (!NumberIsFinite(x)) {
                  throw new TypeError(context + " is not a finite number");
                }
                x = integerPart(x);
                if (x < lowerBound || x > upperBound) {
                  throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
                }
                if (!NumberIsFinite(x) || x === 0) {
                  return 0;
                }
                return x;
              }
              function assertReadableStream(x, context) {
                if (!IsReadableStream(x)) {
                  throw new TypeError(context + " is not a ReadableStream.");
                }
              }
              function AcquireReadableStreamDefaultReader(stream) {
                return new ReadableStreamDefaultReader(stream);
              }
              function ReadableStreamAddReadRequest(stream, readRequest) {
                stream._reader._readRequests.push(readRequest);
              }
              function ReadableStreamFulfillReadRequest(stream, chunk, done) {
                var reader = stream._reader;
                var readRequest = reader._readRequests.shift();
                if (done) {
                  readRequest._closeSteps();
                } else {
                  readRequest._chunkSteps(chunk);
                }
              }
              function ReadableStreamGetNumReadRequests(stream) {
                return stream._reader._readRequests.length;
              }
              function ReadableStreamHasDefaultReader(stream) {
                var reader = stream._reader;
                if (reader === void 0) {
                  return false;
                }
                if (!IsReadableStreamDefaultReader(reader)) {
                  return false;
                }
                return true;
              }
              var ReadableStreamDefaultReader = function() {
                function ReadableStreamDefaultReader2(stream) {
                  assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
                  assertReadableStream(stream, "First parameter");
                  if (IsReadableStreamLocked(stream)) {
                    throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                  }
                  ReadableStreamReaderGenericInitialize(this, stream);
                  this._readRequests = new SimpleQueue();
                }
                Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
                  get: function() {
                    if (!IsReadableStreamDefaultReader(this)) {
                      return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  },
                  enumerable: false,
                  configurable: true
                });
                ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
                  if (reason === void 0) {
                    reason = void 0;
                  }
                  if (!IsReadableStreamDefaultReader(this)) {
                    return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
                  }
                  if (this._ownerReadableStream === void 0) {
                    return promiseRejectedWith(readerLockException("cancel"));
                  }
                  return ReadableStreamReaderGenericCancel(this, reason);
                };
                ReadableStreamDefaultReader2.prototype.read = function() {
                  if (!IsReadableStreamDefaultReader(this)) {
                    return promiseRejectedWith(defaultReaderBrandCheckException("read"));
                  }
                  if (this._ownerReadableStream === void 0) {
                    return promiseRejectedWith(readerLockException("read from"));
                  }
                  var resolvePromise;
                  var rejectPromise;
                  var promise = newPromise(function(resolve, reject) {
                    resolvePromise = resolve;
                    rejectPromise = reject;
                  });
                  var readRequest = {
                    _chunkSteps: function(chunk) {
                      return resolvePromise({
                        value: chunk,
                        done: false
                      });
                    },
                    _closeSteps: function() {
                      return resolvePromise({
                        value: void 0,
                        done: true
                      });
                    },
                    _errorSteps: function(e) {
                      return rejectPromise(e);
                    }
                  };
                  ReadableStreamDefaultReaderRead(this, readRequest);
                  return promise;
                };
                ReadableStreamDefaultReader2.prototype.releaseLock = function() {
                  if (!IsReadableStreamDefaultReader(this)) {
                    throw defaultReaderBrandCheckException("releaseLock");
                  }
                  if (this._ownerReadableStream === void 0) {
                    return;
                  }
                  if (this._readRequests.length > 0) {
                    throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                  }
                  ReadableStreamReaderGenericRelease(this);
                };
                return ReadableStreamDefaultReader2;
              }();
              Object.defineProperties(ReadableStreamDefaultReader.prototype, {
                cancel: { enumerable: true },
                read: { enumerable: true },
                releaseLock: { enumerable: true },
                closed: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
                  value: "ReadableStreamDefaultReader",
                  configurable: true
                });
              }
              function IsReadableStreamDefaultReader(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
                  return false;
                }
                return true;
              }
              function ReadableStreamDefaultReaderRead(reader, readRequest) {
                var stream = reader._ownerReadableStream;
                stream._disturbed = true;
                if (stream._state === "closed") {
                  readRequest._closeSteps();
                } else if (stream._state === "errored") {
                  readRequest._errorSteps(stream._storedError);
                } else {
                  stream._readableStreamController[PullSteps](readRequest);
                }
              }
              function defaultReaderBrandCheckException(name) {
                return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
              }
              var _a;
              var AsyncIteratorPrototype;
              if (typeof SymbolPolyfill.asyncIterator === "symbol") {
                AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function() {
                  return this;
                }, _a);
                Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
              }
              var ReadableStreamAsyncIteratorImpl = function() {
                function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
                  this._ongoingPromise = void 0;
                  this._isFinished = false;
                  this._reader = reader;
                  this._preventCancel = preventCancel;
                }
                ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
                  var _this = this;
                  var nextSteps = function() {
                    return _this._nextSteps();
                  };
                  this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
                  return this._ongoingPromise;
                };
                ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
                  var _this = this;
                  var returnSteps = function() {
                    return _this._returnSteps(value);
                  };
                  return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
                };
                ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
                  var _this = this;
                  if (this._isFinished) {
                    return Promise.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  var reader = this._reader;
                  if (reader._ownerReadableStream === void 0) {
                    return promiseRejectedWith(readerLockException("iterate"));
                  }
                  var resolvePromise;
                  var rejectPromise;
                  var promise = newPromise(function(resolve, reject) {
                    resolvePromise = resolve;
                    rejectPromise = reject;
                  });
                  var readRequest = {
                    _chunkSteps: function(chunk) {
                      _this._ongoingPromise = void 0;
                      queueMicrotask(function() {
                        return resolvePromise({
                          value: chunk,
                          done: false
                        });
                      });
                    },
                    _closeSteps: function() {
                      _this._ongoingPromise = void 0;
                      _this._isFinished = true;
                      ReadableStreamReaderGenericRelease(reader);
                      resolvePromise({
                        value: void 0,
                        done: true
                      });
                    },
                    _errorSteps: function(reason) {
                      _this._ongoingPromise = void 0;
                      _this._isFinished = true;
                      ReadableStreamReaderGenericRelease(reader);
                      rejectPromise(reason);
                    }
                  };
                  ReadableStreamDefaultReaderRead(reader, readRequest);
                  return promise;
                };
                ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
                  if (this._isFinished) {
                    return Promise.resolve({
                      value,
                      done: true
                    });
                  }
                  this._isFinished = true;
                  var reader = this._reader;
                  if (reader._ownerReadableStream === void 0) {
                    return promiseRejectedWith(readerLockException("finish iterating"));
                  }
                  if (!this._preventCancel) {
                    var result = ReadableStreamReaderGenericCancel(reader, value);
                    ReadableStreamReaderGenericRelease(reader);
                    return transformPromiseWith(result, function() {
                      return {
                        value,
                        done: true
                      };
                    });
                  }
                  ReadableStreamReaderGenericRelease(reader);
                  return promiseResolvedWith({
                    value,
                    done: true
                  });
                };
                return ReadableStreamAsyncIteratorImpl2;
              }();
              var ReadableStreamAsyncIteratorPrototype = {
                next: function() {
                  if (!IsReadableStreamAsyncIterator(this)) {
                    return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
                  }
                  return this._asyncIteratorImpl.next();
                },
                return: function(value) {
                  if (!IsReadableStreamAsyncIterator(this)) {
                    return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
                  }
                  return this._asyncIteratorImpl.return(value);
                }
              };
              if (AsyncIteratorPrototype !== void 0) {
                Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
              }
              function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
                var reader = AcquireReadableStreamDefaultReader(stream);
                var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
                var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
                iterator._asyncIteratorImpl = impl;
                return iterator;
              }
              function IsReadableStreamAsyncIterator(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
                  return false;
                }
                return true;
              }
              function streamAsyncIteratorBrandCheckException(name) {
                return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
              }
              var NumberIsNaN = Number.isNaN || function(x) {
                return x !== x;
              };
              function IsFiniteNonNegativeNumber(v) {
                if (!IsNonNegativeNumber(v)) {
                  return false;
                }
                if (v === Infinity) {
                  return false;
                }
                return true;
              }
              function IsNonNegativeNumber(v) {
                if (typeof v !== "number") {
                  return false;
                }
                if (NumberIsNaN(v)) {
                  return false;
                }
                if (v < 0) {
                  return false;
                }
                return true;
              }
              function DequeueValue(container) {
                var pair = container._queue.shift();
                container._queueTotalSize -= pair.size;
                if (container._queueTotalSize < 0) {
                  container._queueTotalSize = 0;
                }
                return pair.value;
              }
              function EnqueueValueWithSize(container, value, size) {
                size = Number(size);
                if (!IsFiniteNonNegativeNumber(size)) {
                  throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
                }
                container._queue.push({
                  value,
                  size
                });
                container._queueTotalSize += size;
              }
              function PeekQueueValue(container) {
                var pair = container._queue.peek();
                return pair.value;
              }
              function ResetQueue(container) {
                container._queue = new SimpleQueue();
                container._queueTotalSize = 0;
              }
              function CreateArrayFromList(elements) {
                return elements.slice();
              }
              function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
                new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
              }
              function TransferArrayBuffer(O) {
                return O;
              }
              function IsDetachedBuffer(O) {
                return false;
              }
              var ReadableStreamBYOBRequest = function() {
                function ReadableStreamBYOBRequest2() {
                  throw new TypeError("Illegal constructor");
                }
                Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
                  get: function() {
                    if (!IsReadableStreamBYOBRequest(this)) {
                      throw byobRequestBrandCheckException("view");
                    }
                    return this._view;
                  },
                  enumerable: false,
                  configurable: true
                });
                ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
                  if (!IsReadableStreamBYOBRequest(this)) {
                    throw byobRequestBrandCheckException("respond");
                  }
                  assertRequiredArgument(bytesWritten, 1, "respond");
                  bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
                  if (this._associatedReadableByteStreamController === void 0) {
                    throw new TypeError("This BYOB request has been invalidated");
                  }
                  if (IsDetachedBuffer(this._view.buffer))
                    ;
                  ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
                };
                ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
                  if (!IsReadableStreamBYOBRequest(this)) {
                    throw byobRequestBrandCheckException("respondWithNewView");
                  }
                  assertRequiredArgument(view, 1, "respondWithNewView");
                  if (!ArrayBuffer.isView(view)) {
                    throw new TypeError("You can only respond with array buffer views");
                  }
                  if (view.byteLength === 0) {
                    throw new TypeError("chunk must have non-zero byteLength");
                  }
                  if (view.buffer.byteLength === 0) {
                    throw new TypeError("chunk's buffer must have non-zero byteLength");
                  }
                  if (this._associatedReadableByteStreamController === void 0) {
                    throw new TypeError("This BYOB request has been invalidated");
                  }
                  ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
                };
                return ReadableStreamBYOBRequest2;
              }();
              Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
                respond: { enumerable: true },
                respondWithNewView: { enumerable: true },
                view: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
                  value: "ReadableStreamBYOBRequest",
                  configurable: true
                });
              }
              var ReadableByteStreamController = function() {
                function ReadableByteStreamController2() {
                  throw new TypeError("Illegal constructor");
                }
                Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
                  get: function() {
                    if (!IsReadableByteStreamController(this)) {
                      throw byteStreamControllerBrandCheckException("byobRequest");
                    }
                    if (this._byobRequest === null && this._pendingPullIntos.length > 0) {
                      var firstDescriptor = this._pendingPullIntos.peek();
                      var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
                      var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
                      SetUpReadableStreamBYOBRequest(byobRequest, this, view);
                      this._byobRequest = byobRequest;
                    }
                    return this._byobRequest;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
                  get: function() {
                    if (!IsReadableByteStreamController(this)) {
                      throw byteStreamControllerBrandCheckException("desiredSize");
                    }
                    return ReadableByteStreamControllerGetDesiredSize(this);
                  },
                  enumerable: false,
                  configurable: true
                });
                ReadableByteStreamController2.prototype.close = function() {
                  if (!IsReadableByteStreamController(this)) {
                    throw byteStreamControllerBrandCheckException("close");
                  }
                  if (this._closeRequested) {
                    throw new TypeError("The stream has already been closed; do not close it again!");
                  }
                  var state = this._controlledReadableByteStream._state;
                  if (state !== "readable") {
                    throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
                  }
                  ReadableByteStreamControllerClose(this);
                };
                ReadableByteStreamController2.prototype.enqueue = function(chunk) {
                  if (!IsReadableByteStreamController(this)) {
                    throw byteStreamControllerBrandCheckException("enqueue");
                  }
                  assertRequiredArgument(chunk, 1, "enqueue");
                  if (!ArrayBuffer.isView(chunk)) {
                    throw new TypeError("chunk must be an array buffer view");
                  }
                  if (chunk.byteLength === 0) {
                    throw new TypeError("chunk must have non-zero byteLength");
                  }
                  if (chunk.buffer.byteLength === 0) {
                    throw new TypeError("chunk's buffer must have non-zero byteLength");
                  }
                  if (this._closeRequested) {
                    throw new TypeError("stream is closed or draining");
                  }
                  var state = this._controlledReadableByteStream._state;
                  if (state !== "readable") {
                    throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
                  }
                  ReadableByteStreamControllerEnqueue(this, chunk);
                };
                ReadableByteStreamController2.prototype.error = function(e) {
                  if (e === void 0) {
                    e = void 0;
                  }
                  if (!IsReadableByteStreamController(this)) {
                    throw byteStreamControllerBrandCheckException("error");
                  }
                  ReadableByteStreamControllerError(this, e);
                };
                ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
                  if (this._pendingPullIntos.length > 0) {
                    var firstDescriptor = this._pendingPullIntos.peek();
                    firstDescriptor.bytesFilled = 0;
                  }
                  ResetQueue(this);
                  var result = this._cancelAlgorithm(reason);
                  ReadableByteStreamControllerClearAlgorithms(this);
                  return result;
                };
                ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
                  var stream = this._controlledReadableByteStream;
                  if (this._queueTotalSize > 0) {
                    var entry = this._queue.shift();
                    this._queueTotalSize -= entry.byteLength;
                    ReadableByteStreamControllerHandleQueueDrain(this);
                    var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                    readRequest._chunkSteps(view);
                    return;
                  }
                  var autoAllocateChunkSize = this._autoAllocateChunkSize;
                  if (autoAllocateChunkSize !== void 0) {
                    var buffer = void 0;
                    try {
                      buffer = new ArrayBuffer(autoAllocateChunkSize);
                    } catch (bufferE) {
                      readRequest._errorSteps(bufferE);
                      return;
                    }
                    var pullIntoDescriptor = {
                      buffer,
                      byteOffset: 0,
                      byteLength: autoAllocateChunkSize,
                      bytesFilled: 0,
                      elementSize: 1,
                      viewConstructor: Uint8Array,
                      readerType: "default"
                    };
                    this._pendingPullIntos.push(pullIntoDescriptor);
                  }
                  ReadableStreamAddReadRequest(stream, readRequest);
                  ReadableByteStreamControllerCallPullIfNeeded(this);
                };
                return ReadableByteStreamController2;
              }();
              Object.defineProperties(ReadableByteStreamController.prototype, {
                close: { enumerable: true },
                enqueue: { enumerable: true },
                error: { enumerable: true },
                byobRequest: { enumerable: true },
                desiredSize: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
                  value: "ReadableByteStreamController",
                  configurable: true
                });
              }
              function IsReadableByteStreamController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamBYOBRequest(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
                  return false;
                }
                return true;
              }
              function ReadableByteStreamControllerCallPullIfNeeded(controller) {
                var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
                if (!shouldPull) {
                  return;
                }
                if (controller._pulling) {
                  controller._pullAgain = true;
                  return;
                }
                controller._pulling = true;
                var pullPromise = controller._pullAlgorithm();
                uponPromise(pullPromise, function() {
                  controller._pulling = false;
                  if (controller._pullAgain) {
                    controller._pullAgain = false;
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                  }
                }, function(e) {
                  ReadableByteStreamControllerError(controller, e);
                });
              }
              function ReadableByteStreamControllerClearPendingPullIntos(controller) {
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                controller._pendingPullIntos = new SimpleQueue();
              }
              function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
                var done = false;
                if (stream._state === "closed") {
                  done = true;
                }
                var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                if (pullIntoDescriptor.readerType === "default") {
                  ReadableStreamFulfillReadRequest(stream, filledView, done);
                } else {
                  ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
                }
              }
              function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
                var bytesFilled = pullIntoDescriptor.bytesFilled;
                var elementSize = pullIntoDescriptor.elementSize;
                return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
              }
              function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
                controller._queue.push({
                  buffer,
                  byteOffset,
                  byteLength
                });
                controller._queueTotalSize += byteLength;
              }
              function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
                var elementSize = pullIntoDescriptor.elementSize;
                var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
                var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
                var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
                var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
                var totalBytesToCopyRemaining = maxBytesToCopy;
                var ready = false;
                if (maxAlignedBytes > currentAlignedBytes) {
                  totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
                  ready = true;
                }
                var queue = controller._queue;
                while (totalBytesToCopyRemaining > 0) {
                  var headOfQueue = queue.peek();
                  var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
                  var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                  CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
                  if (headOfQueue.byteLength === bytesToCopy) {
                    queue.shift();
                  } else {
                    headOfQueue.byteOffset += bytesToCopy;
                    headOfQueue.byteLength -= bytesToCopy;
                  }
                  controller._queueTotalSize -= bytesToCopy;
                  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
                  totalBytesToCopyRemaining -= bytesToCopy;
                }
                return ready;
              }
              function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                pullIntoDescriptor.bytesFilled += size;
              }
              function ReadableByteStreamControllerHandleQueueDrain(controller) {
                if (controller._queueTotalSize === 0 && controller._closeRequested) {
                  ReadableByteStreamControllerClearAlgorithms(controller);
                  ReadableStreamClose(controller._controlledReadableByteStream);
                } else {
                  ReadableByteStreamControllerCallPullIfNeeded(controller);
                }
              }
              function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
                if (controller._byobRequest === null) {
                  return;
                }
                controller._byobRequest._associatedReadableByteStreamController = void 0;
                controller._byobRequest._view = null;
                controller._byobRequest = null;
              }
              function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
                while (controller._pendingPullIntos.length > 0) {
                  if (controller._queueTotalSize === 0) {
                    return;
                  }
                  var pullIntoDescriptor = controller._pendingPullIntos.peek();
                  if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
                  }
                }
              }
              function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
                var stream = controller._controlledReadableByteStream;
                var elementSize = 1;
                if (view.constructor !== DataView) {
                  elementSize = view.constructor.BYTES_PER_ELEMENT;
                }
                var ctor = view.constructor;
                var buffer = TransferArrayBuffer(view.buffer);
                var pullIntoDescriptor = {
                  buffer,
                  byteOffset: view.byteOffset,
                  byteLength: view.byteLength,
                  bytesFilled: 0,
                  elementSize,
                  viewConstructor: ctor,
                  readerType: "byob"
                };
                if (controller._pendingPullIntos.length > 0) {
                  controller._pendingPullIntos.push(pullIntoDescriptor);
                  ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
                  return;
                }
                if (stream._state === "closed") {
                  var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
                  readIntoRequest._closeSteps(emptyView);
                  return;
                }
                if (controller._queueTotalSize > 0) {
                  if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                    ReadableByteStreamControllerHandleQueueDrain(controller);
                    readIntoRequest._chunkSteps(filledView);
                    return;
                  }
                  if (controller._closeRequested) {
                    var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                    ReadableByteStreamControllerError(controller, e);
                    readIntoRequest._errorSteps(e);
                    return;
                  }
                }
                controller._pendingPullIntos.push(pullIntoDescriptor);
                ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
                ReadableByteStreamControllerCallPullIfNeeded(controller);
              }
              function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
                firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
                var stream = controller._controlledReadableByteStream;
                if (ReadableStreamHasBYOBReader(stream)) {
                  while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                    var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
                  }
                }
              }
              function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
                if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
                  throw new RangeError("bytesWritten out of range");
                }
                ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
                if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
                  return;
                }
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
                if (remainderSize > 0) {
                  var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                  var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
                }
                pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                pullIntoDescriptor.bytesFilled -= remainderSize;
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
                ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
              }
              function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
                var firstDescriptor = controller._pendingPullIntos.peek();
                var state = controller._controlledReadableByteStream._state;
                if (state === "closed") {
                  if (bytesWritten !== 0) {
                    throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
                  }
                  ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
                } else {
                  ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
                }
                ReadableByteStreamControllerCallPullIfNeeded(controller);
              }
              function ReadableByteStreamControllerShiftPendingPullInto(controller) {
                var descriptor = controller._pendingPullIntos.shift();
                ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                return descriptor;
              }
              function ReadableByteStreamControllerShouldCallPull(controller) {
                var stream = controller._controlledReadableByteStream;
                if (stream._state !== "readable") {
                  return false;
                }
                if (controller._closeRequested) {
                  return false;
                }
                if (!controller._started) {
                  return false;
                }
                if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
                  return true;
                }
                if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                  return true;
                }
                var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
                if (desiredSize > 0) {
                  return true;
                }
                return false;
              }
              function ReadableByteStreamControllerClearAlgorithms(controller) {
                controller._pullAlgorithm = void 0;
                controller._cancelAlgorithm = void 0;
              }
              function ReadableByteStreamControllerClose(controller) {
                var stream = controller._controlledReadableByteStream;
                if (controller._closeRequested || stream._state !== "readable") {
                  return;
                }
                if (controller._queueTotalSize > 0) {
                  controller._closeRequested = true;
                  return;
                }
                if (controller._pendingPullIntos.length > 0) {
                  var firstPendingPullInto = controller._pendingPullIntos.peek();
                  if (firstPendingPullInto.bytesFilled > 0) {
                    var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                    ReadableByteStreamControllerError(controller, e);
                    throw e;
                  }
                }
                ReadableByteStreamControllerClearAlgorithms(controller);
                ReadableStreamClose(stream);
              }
              function ReadableByteStreamControllerEnqueue(controller, chunk) {
                var stream = controller._controlledReadableByteStream;
                if (controller._closeRequested || stream._state !== "readable") {
                  return;
                }
                var buffer = chunk.buffer;
                var byteOffset = chunk.byteOffset;
                var byteLength = chunk.byteLength;
                var transferredBuffer = TransferArrayBuffer(buffer);
                if (ReadableStreamHasDefaultReader(stream)) {
                  if (ReadableStreamGetNumReadRequests(stream) === 0) {
                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                  } else {
                    var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                    ReadableStreamFulfillReadRequest(stream, transferredView, false);
                  }
                } else if (ReadableStreamHasBYOBReader(stream)) {
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
                } else {
                  ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                }
                ReadableByteStreamControllerCallPullIfNeeded(controller);
              }
              function ReadableByteStreamControllerError(controller, e) {
                var stream = controller._controlledReadableByteStream;
                if (stream._state !== "readable") {
                  return;
                }
                ReadableByteStreamControllerClearPendingPullIntos(controller);
                ResetQueue(controller);
                ReadableByteStreamControllerClearAlgorithms(controller);
                ReadableStreamError(stream, e);
              }
              function ReadableByteStreamControllerGetDesiredSize(controller) {
                var state = controller._controlledReadableByteStream._state;
                if (state === "errored") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return controller._strategyHWM - controller._queueTotalSize;
              }
              function ReadableByteStreamControllerRespond(controller, bytesWritten) {
                bytesWritten = Number(bytesWritten);
                if (!IsFiniteNonNegativeNumber(bytesWritten)) {
                  throw new RangeError("bytesWritten must be a finite");
                }
                ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
              }
              function ReadableByteStreamControllerRespondWithNewView(controller, view) {
                var firstDescriptor = controller._pendingPullIntos.peek();
                if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
                  throw new RangeError("The region specified by view does not match byobRequest");
                }
                if (firstDescriptor.byteLength !== view.byteLength) {
                  throw new RangeError("The buffer of view has different capacity than byobRequest");
                }
                firstDescriptor.buffer = view.buffer;
                ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
              }
              function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
                controller._controlledReadableByteStream = stream;
                controller._pullAgain = false;
                controller._pulling = false;
                controller._byobRequest = null;
                controller._queue = controller._queueTotalSize = void 0;
                ResetQueue(controller);
                controller._closeRequested = false;
                controller._started = false;
                controller._strategyHWM = highWaterMark;
                controller._pullAlgorithm = pullAlgorithm;
                controller._cancelAlgorithm = cancelAlgorithm;
                controller._autoAllocateChunkSize = autoAllocateChunkSize;
                controller._pendingPullIntos = new SimpleQueue();
                stream._readableStreamController = controller;
                var startResult = startAlgorithm();
                uponPromise(promiseResolvedWith(startResult), function() {
                  controller._started = true;
                  ReadableByteStreamControllerCallPullIfNeeded(controller);
                }, function(r) {
                  ReadableByteStreamControllerError(controller, r);
                });
              }
              function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
                var controller = Object.create(ReadableByteStreamController.prototype);
                var startAlgorithm = function() {
                  return void 0;
                };
                var pullAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                var cancelAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                if (underlyingByteSource.start !== void 0) {
                  startAlgorithm = function() {
                    return underlyingByteSource.start(controller);
                  };
                }
                if (underlyingByteSource.pull !== void 0) {
                  pullAlgorithm = function() {
                    return underlyingByteSource.pull(controller);
                  };
                }
                if (underlyingByteSource.cancel !== void 0) {
                  cancelAlgorithm = function(reason) {
                    return underlyingByteSource.cancel(reason);
                  };
                }
                var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
                if (autoAllocateChunkSize === 0) {
                  throw new TypeError("autoAllocateChunkSize must be greater than 0");
                }
                SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
              }
              function SetUpReadableStreamBYOBRequest(request, controller, view) {
                request._associatedReadableByteStreamController = controller;
                request._view = view;
              }
              function byobRequestBrandCheckException(name) {
                return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
              }
              function byteStreamControllerBrandCheckException(name) {
                return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
              }
              function AcquireReadableStreamBYOBReader(stream) {
                return new ReadableStreamBYOBReader(stream);
              }
              function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
                stream._reader._readIntoRequests.push(readIntoRequest);
              }
              function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
                var reader = stream._reader;
                var readIntoRequest = reader._readIntoRequests.shift();
                if (done) {
                  readIntoRequest._closeSteps(chunk);
                } else {
                  readIntoRequest._chunkSteps(chunk);
                }
              }
              function ReadableStreamGetNumReadIntoRequests(stream) {
                return stream._reader._readIntoRequests.length;
              }
              function ReadableStreamHasBYOBReader(stream) {
                var reader = stream._reader;
                if (reader === void 0) {
                  return false;
                }
                if (!IsReadableStreamBYOBReader(reader)) {
                  return false;
                }
                return true;
              }
              var ReadableStreamBYOBReader = function() {
                function ReadableStreamBYOBReader2(stream) {
                  assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
                  assertReadableStream(stream, "First parameter");
                  if (IsReadableStreamLocked(stream)) {
                    throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                  }
                  if (!IsReadableByteStreamController(stream._readableStreamController)) {
                    throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
                  }
                  ReadableStreamReaderGenericInitialize(this, stream);
                  this._readIntoRequests = new SimpleQueue();
                }
                Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
                  get: function() {
                    if (!IsReadableStreamBYOBReader(this)) {
                      return promiseRejectedWith(byobReaderBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  },
                  enumerable: false,
                  configurable: true
                });
                ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
                  if (reason === void 0) {
                    reason = void 0;
                  }
                  if (!IsReadableStreamBYOBReader(this)) {
                    return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
                  }
                  if (this._ownerReadableStream === void 0) {
                    return promiseRejectedWith(readerLockException("cancel"));
                  }
                  return ReadableStreamReaderGenericCancel(this, reason);
                };
                ReadableStreamBYOBReader2.prototype.read = function(view) {
                  if (!IsReadableStreamBYOBReader(this)) {
                    return promiseRejectedWith(byobReaderBrandCheckException("read"));
                  }
                  if (!ArrayBuffer.isView(view)) {
                    return promiseRejectedWith(new TypeError("view must be an array buffer view"));
                  }
                  if (view.byteLength === 0) {
                    return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
                  }
                  if (view.buffer.byteLength === 0) {
                    return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
                  }
                  if (this._ownerReadableStream === void 0) {
                    return promiseRejectedWith(readerLockException("read from"));
                  }
                  var resolvePromise;
                  var rejectPromise;
                  var promise = newPromise(function(resolve, reject) {
                    resolvePromise = resolve;
                    rejectPromise = reject;
                  });
                  var readIntoRequest = {
                    _chunkSteps: function(chunk) {
                      return resolvePromise({
                        value: chunk,
                        done: false
                      });
                    },
                    _closeSteps: function(chunk) {
                      return resolvePromise({
                        value: chunk,
                        done: true
                      });
                    },
                    _errorSteps: function(e) {
                      return rejectPromise(e);
                    }
                  };
                  ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
                  return promise;
                };
                ReadableStreamBYOBReader2.prototype.releaseLock = function() {
                  if (!IsReadableStreamBYOBReader(this)) {
                    throw byobReaderBrandCheckException("releaseLock");
                  }
                  if (this._ownerReadableStream === void 0) {
                    return;
                  }
                  if (this._readIntoRequests.length > 0) {
                    throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                  }
                  ReadableStreamReaderGenericRelease(this);
                };
                return ReadableStreamBYOBReader2;
              }();
              Object.defineProperties(ReadableStreamBYOBReader.prototype, {
                cancel: { enumerable: true },
                read: { enumerable: true },
                releaseLock: { enumerable: true },
                closed: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
                  value: "ReadableStreamBYOBReader",
                  configurable: true
                });
              }
              function IsReadableStreamBYOBReader(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
                  return false;
                }
                return true;
              }
              function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
                var stream = reader._ownerReadableStream;
                stream._disturbed = true;
                if (stream._state === "errored") {
                  readIntoRequest._errorSteps(stream._storedError);
                } else {
                  ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
                }
              }
              function byobReaderBrandCheckException(name) {
                return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
              }
              function ExtractHighWaterMark(strategy, defaultHWM) {
                var highWaterMark = strategy.highWaterMark;
                if (highWaterMark === void 0) {
                  return defaultHWM;
                }
                if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
                  throw new RangeError("Invalid highWaterMark");
                }
                return highWaterMark;
              }
              function ExtractSizeAlgorithm(strategy) {
                var size = strategy.size;
                if (!size) {
                  return function() {
                    return 1;
                  };
                }
                return size;
              }
              function convertQueuingStrategy(init, context) {
                assertDictionary(init, context);
                var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
                var size = init === null || init === void 0 ? void 0 : init.size;
                return {
                  highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
                  size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
                };
              }
              function convertQueuingStrategySize(fn, context) {
                assertFunction(fn, context);
                return function(chunk) {
                  return convertUnrestrictedDouble(fn(chunk));
                };
              }
              function convertUnderlyingSink(original, context) {
                assertDictionary(original, context);
                var abort = original === null || original === void 0 ? void 0 : original.abort;
                var close = original === null || original === void 0 ? void 0 : original.close;
                var start = original === null || original === void 0 ? void 0 : original.start;
                var type = original === null || original === void 0 ? void 0 : original.type;
                var write = original === null || original === void 0 ? void 0 : original.write;
                return {
                  abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
                  close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
                  start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
                  write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
                  type
                };
              }
              function convertUnderlyingSinkAbortCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(reason) {
                  return promiseCall(fn, original, [reason]);
                };
              }
              function convertUnderlyingSinkCloseCallback(fn, original, context) {
                assertFunction(fn, context);
                return function() {
                  return promiseCall(fn, original, []);
                };
              }
              function convertUnderlyingSinkStartCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(controller) {
                  return reflectCall(fn, original, [controller]);
                };
              }
              function convertUnderlyingSinkWriteCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(chunk, controller) {
                  return promiseCall(fn, original, [
                    chunk,
                    controller
                  ]);
                };
              }
              function assertWritableStream(x, context) {
                if (!IsWritableStream(x)) {
                  throw new TypeError(context + " is not a WritableStream.");
                }
              }
              var WritableStream = function() {
                function WritableStream2(rawUnderlyingSink, rawStrategy) {
                  if (rawUnderlyingSink === void 0) {
                    rawUnderlyingSink = {};
                  }
                  if (rawStrategy === void 0) {
                    rawStrategy = {};
                  }
                  if (rawUnderlyingSink === void 0) {
                    rawUnderlyingSink = null;
                  } else {
                    assertObject(rawUnderlyingSink, "First parameter");
                  }
                  var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
                  var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
                  InitializeWritableStream(this);
                  var type = underlyingSink.type;
                  if (type !== void 0) {
                    throw new RangeError("Invalid type is specified");
                  }
                  var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                  var highWaterMark = ExtractHighWaterMark(strategy, 1);
                  SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
                }
                Object.defineProperty(WritableStream2.prototype, "locked", {
                  get: function() {
                    if (!IsWritableStream(this)) {
                      throw streamBrandCheckException("locked");
                    }
                    return IsWritableStreamLocked(this);
                  },
                  enumerable: false,
                  configurable: true
                });
                WritableStream2.prototype.abort = function(reason) {
                  if (reason === void 0) {
                    reason = void 0;
                  }
                  if (!IsWritableStream(this)) {
                    return promiseRejectedWith(streamBrandCheckException("abort"));
                  }
                  if (IsWritableStreamLocked(this)) {
                    return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
                  }
                  return WritableStreamAbort(this, reason);
                };
                WritableStream2.prototype.close = function() {
                  if (!IsWritableStream(this)) {
                    return promiseRejectedWith(streamBrandCheckException("close"));
                  }
                  if (IsWritableStreamLocked(this)) {
                    return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
                  }
                  if (WritableStreamCloseQueuedOrInFlight(this)) {
                    return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
                  }
                  return WritableStreamClose(this);
                };
                WritableStream2.prototype.getWriter = function() {
                  if (!IsWritableStream(this)) {
                    throw streamBrandCheckException("getWriter");
                  }
                  return AcquireWritableStreamDefaultWriter(this);
                };
                return WritableStream2;
              }();
              Object.defineProperties(WritableStream.prototype, {
                abort: { enumerable: true },
                close: { enumerable: true },
                getWriter: { enumerable: true },
                locked: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
                  value: "WritableStream",
                  configurable: true
                });
              }
              function AcquireWritableStreamDefaultWriter(stream) {
                return new WritableStreamDefaultWriter(stream);
              }
              function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
                if (highWaterMark === void 0) {
                  highWaterMark = 1;
                }
                if (sizeAlgorithm === void 0) {
                  sizeAlgorithm = function() {
                    return 1;
                  };
                }
                var stream = Object.create(WritableStream.prototype);
                InitializeWritableStream(stream);
                var controller = Object.create(WritableStreamDefaultController.prototype);
                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
                return stream;
              }
              function InitializeWritableStream(stream) {
                stream._state = "writable";
                stream._storedError = void 0;
                stream._writer = void 0;
                stream._writableStreamController = void 0;
                stream._writeRequests = new SimpleQueue();
                stream._inFlightWriteRequest = void 0;
                stream._closeRequest = void 0;
                stream._inFlightCloseRequest = void 0;
                stream._pendingAbortRequest = void 0;
                stream._backpressure = false;
              }
              function IsWritableStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
                  return false;
                }
                return true;
              }
              function IsWritableStreamLocked(stream) {
                if (stream._writer === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamAbort(stream, reason) {
                var state = stream._state;
                if (state === "closed" || state === "errored") {
                  return promiseResolvedWith(void 0);
                }
                if (stream._pendingAbortRequest !== void 0) {
                  return stream._pendingAbortRequest._promise;
                }
                var wasAlreadyErroring = false;
                if (state === "erroring") {
                  wasAlreadyErroring = true;
                  reason = void 0;
                }
                var promise = newPromise(function(resolve, reject) {
                  stream._pendingAbortRequest = {
                    _promise: void 0,
                    _resolve: resolve,
                    _reject: reject,
                    _reason: reason,
                    _wasAlreadyErroring: wasAlreadyErroring
                  };
                });
                stream._pendingAbortRequest._promise = promise;
                if (!wasAlreadyErroring) {
                  WritableStreamStartErroring(stream, reason);
                }
                return promise;
              }
              function WritableStreamClose(stream) {
                var state = stream._state;
                if (state === "closed" || state === "errored") {
                  return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
                }
                var promise = newPromise(function(resolve, reject) {
                  var closeRequest = {
                    _resolve: resolve,
                    _reject: reject
                  };
                  stream._closeRequest = closeRequest;
                });
                var writer = stream._writer;
                if (writer !== void 0 && stream._backpressure && state === "writable") {
                  defaultWriterReadyPromiseResolve(writer);
                }
                WritableStreamDefaultControllerClose(stream._writableStreamController);
                return promise;
              }
              function WritableStreamAddWriteRequest(stream) {
                var promise = newPromise(function(resolve, reject) {
                  var writeRequest = {
                    _resolve: resolve,
                    _reject: reject
                  };
                  stream._writeRequests.push(writeRequest);
                });
                return promise;
              }
              function WritableStreamDealWithRejection(stream, error) {
                var state = stream._state;
                if (state === "writable") {
                  WritableStreamStartErroring(stream, error);
                  return;
                }
                WritableStreamFinishErroring(stream);
              }
              function WritableStreamStartErroring(stream, reason) {
                var controller = stream._writableStreamController;
                stream._state = "erroring";
                stream._storedError = reason;
                var writer = stream._writer;
                if (writer !== void 0) {
                  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
                }
                if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
                  WritableStreamFinishErroring(stream);
                }
              }
              function WritableStreamFinishErroring(stream) {
                stream._state = "errored";
                stream._writableStreamController[ErrorSteps]();
                var storedError = stream._storedError;
                stream._writeRequests.forEach(function(writeRequest) {
                  writeRequest._reject(storedError);
                });
                stream._writeRequests = new SimpleQueue();
                if (stream._pendingAbortRequest === void 0) {
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                  return;
                }
                var abortRequest = stream._pendingAbortRequest;
                stream._pendingAbortRequest = void 0;
                if (abortRequest._wasAlreadyErroring) {
                  abortRequest._reject(storedError);
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                  return;
                }
                var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
                uponPromise(promise, function() {
                  abortRequest._resolve();
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                }, function(reason) {
                  abortRequest._reject(reason);
                  WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                });
              }
              function WritableStreamFinishInFlightWrite(stream) {
                stream._inFlightWriteRequest._resolve(void 0);
                stream._inFlightWriteRequest = void 0;
              }
              function WritableStreamFinishInFlightWriteWithError(stream, error) {
                stream._inFlightWriteRequest._reject(error);
                stream._inFlightWriteRequest = void 0;
                WritableStreamDealWithRejection(stream, error);
              }
              function WritableStreamFinishInFlightClose(stream) {
                stream._inFlightCloseRequest._resolve(void 0);
                stream._inFlightCloseRequest = void 0;
                var state = stream._state;
                if (state === "erroring") {
                  stream._storedError = void 0;
                  if (stream._pendingAbortRequest !== void 0) {
                    stream._pendingAbortRequest._resolve();
                    stream._pendingAbortRequest = void 0;
                  }
                }
                stream._state = "closed";
                var writer = stream._writer;
                if (writer !== void 0) {
                  defaultWriterClosedPromiseResolve(writer);
                }
              }
              function WritableStreamFinishInFlightCloseWithError(stream, error) {
                stream._inFlightCloseRequest._reject(error);
                stream._inFlightCloseRequest = void 0;
                if (stream._pendingAbortRequest !== void 0) {
                  stream._pendingAbortRequest._reject(error);
                  stream._pendingAbortRequest = void 0;
                }
                WritableStreamDealWithRejection(stream, error);
              }
              function WritableStreamCloseQueuedOrInFlight(stream) {
                if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamHasOperationMarkedInFlight(stream) {
                if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
                  return false;
                }
                return true;
              }
              function WritableStreamMarkCloseRequestInFlight(stream) {
                stream._inFlightCloseRequest = stream._closeRequest;
                stream._closeRequest = void 0;
              }
              function WritableStreamMarkFirstWriteRequestInFlight(stream) {
                stream._inFlightWriteRequest = stream._writeRequests.shift();
              }
              function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
                if (stream._closeRequest !== void 0) {
                  stream._closeRequest._reject(stream._storedError);
                  stream._closeRequest = void 0;
                }
                var writer = stream._writer;
                if (writer !== void 0) {
                  defaultWriterClosedPromiseReject(writer, stream._storedError);
                }
              }
              function WritableStreamUpdateBackpressure(stream, backpressure) {
                var writer = stream._writer;
                if (writer !== void 0 && backpressure !== stream._backpressure) {
                  if (backpressure) {
                    defaultWriterReadyPromiseReset(writer);
                  } else {
                    defaultWriterReadyPromiseResolve(writer);
                  }
                }
                stream._backpressure = backpressure;
              }
              var WritableStreamDefaultWriter = function() {
                function WritableStreamDefaultWriter2(stream) {
                  assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
                  assertWritableStream(stream, "First parameter");
                  if (IsWritableStreamLocked(stream)) {
                    throw new TypeError("This stream has already been locked for exclusive writing by another writer");
                  }
                  this._ownerWritableStream = stream;
                  stream._writer = this;
                  var state = stream._state;
                  if (state === "writable") {
                    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                      defaultWriterReadyPromiseInitialize(this);
                    } else {
                      defaultWriterReadyPromiseInitializeAsResolved(this);
                    }
                    defaultWriterClosedPromiseInitialize(this);
                  } else if (state === "erroring") {
                    defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                    defaultWriterClosedPromiseInitialize(this);
                  } else if (state === "closed") {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                    defaultWriterClosedPromiseInitializeAsResolved(this);
                  } else {
                    var storedError = stream._storedError;
                    defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                    defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
                  }
                }
                Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
                  get: function() {
                    if (!IsWritableStreamDefaultWriter(this)) {
                      return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
                    }
                    return this._closedPromise;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
                  get: function() {
                    if (!IsWritableStreamDefaultWriter(this)) {
                      throw defaultWriterBrandCheckException("desiredSize");
                    }
                    if (this._ownerWritableStream === void 0) {
                      throw defaultWriterLockException("desiredSize");
                    }
                    return WritableStreamDefaultWriterGetDesiredSize(this);
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
                  get: function() {
                    if (!IsWritableStreamDefaultWriter(this)) {
                      return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
                    }
                    return this._readyPromise;
                  },
                  enumerable: false,
                  configurable: true
                });
                WritableStreamDefaultWriter2.prototype.abort = function(reason) {
                  if (reason === void 0) {
                    reason = void 0;
                  }
                  if (!IsWritableStreamDefaultWriter(this)) {
                    return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
                  }
                  if (this._ownerWritableStream === void 0) {
                    return promiseRejectedWith(defaultWriterLockException("abort"));
                  }
                  return WritableStreamDefaultWriterAbort(this, reason);
                };
                WritableStreamDefaultWriter2.prototype.close = function() {
                  if (!IsWritableStreamDefaultWriter(this)) {
                    return promiseRejectedWith(defaultWriterBrandCheckException("close"));
                  }
                  var stream = this._ownerWritableStream;
                  if (stream === void 0) {
                    return promiseRejectedWith(defaultWriterLockException("close"));
                  }
                  if (WritableStreamCloseQueuedOrInFlight(stream)) {
                    return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
                  }
                  return WritableStreamDefaultWriterClose(this);
                };
                WritableStreamDefaultWriter2.prototype.releaseLock = function() {
                  if (!IsWritableStreamDefaultWriter(this)) {
                    throw defaultWriterBrandCheckException("releaseLock");
                  }
                  var stream = this._ownerWritableStream;
                  if (stream === void 0) {
                    return;
                  }
                  WritableStreamDefaultWriterRelease(this);
                };
                WritableStreamDefaultWriter2.prototype.write = function(chunk) {
                  if (chunk === void 0) {
                    chunk = void 0;
                  }
                  if (!IsWritableStreamDefaultWriter(this)) {
                    return promiseRejectedWith(defaultWriterBrandCheckException("write"));
                  }
                  if (this._ownerWritableStream === void 0) {
                    return promiseRejectedWith(defaultWriterLockException("write to"));
                  }
                  return WritableStreamDefaultWriterWrite(this, chunk);
                };
                return WritableStreamDefaultWriter2;
              }();
              Object.defineProperties(WritableStreamDefaultWriter.prototype, {
                abort: { enumerable: true },
                close: { enumerable: true },
                releaseLock: { enumerable: true },
                write: { enumerable: true },
                closed: { enumerable: true },
                desiredSize: { enumerable: true },
                ready: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
                  value: "WritableStreamDefaultWriter",
                  configurable: true
                });
              }
              function IsWritableStreamDefaultWriter(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
                  return false;
                }
                return true;
              }
              function WritableStreamDefaultWriterAbort(writer, reason) {
                var stream = writer._ownerWritableStream;
                return WritableStreamAbort(stream, reason);
              }
              function WritableStreamDefaultWriterClose(writer) {
                var stream = writer._ownerWritableStream;
                return WritableStreamClose(stream);
              }
              function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
                var stream = writer._ownerWritableStream;
                var state = stream._state;
                if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
                  return promiseResolvedWith(void 0);
                }
                if (state === "errored") {
                  return promiseRejectedWith(stream._storedError);
                }
                return WritableStreamDefaultWriterClose(writer);
              }
              function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
                if (writer._closedPromiseState === "pending") {
                  defaultWriterClosedPromiseReject(writer, error);
                } else {
                  defaultWriterClosedPromiseResetToRejected(writer, error);
                }
              }
              function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
                if (writer._readyPromiseState === "pending") {
                  defaultWriterReadyPromiseReject(writer, error);
                } else {
                  defaultWriterReadyPromiseResetToRejected(writer, error);
                }
              }
              function WritableStreamDefaultWriterGetDesiredSize(writer) {
                var stream = writer._ownerWritableStream;
                var state = stream._state;
                if (state === "errored" || state === "erroring") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
              }
              function WritableStreamDefaultWriterRelease(writer) {
                var stream = writer._ownerWritableStream;
                var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
                WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
                WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
                stream._writer = void 0;
                writer._ownerWritableStream = void 0;
              }
              function WritableStreamDefaultWriterWrite(writer, chunk) {
                var stream = writer._ownerWritableStream;
                var controller = stream._writableStreamController;
                var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
                if (stream !== writer._ownerWritableStream) {
                  return promiseRejectedWith(defaultWriterLockException("write to"));
                }
                var state = stream._state;
                if (state === "errored") {
                  return promiseRejectedWith(stream._storedError);
                }
                if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
                  return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
                }
                if (state === "erroring") {
                  return promiseRejectedWith(stream._storedError);
                }
                var promise = WritableStreamAddWriteRequest(stream);
                WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
                return promise;
              }
              var closeSentinel = {};
              var WritableStreamDefaultController = function() {
                function WritableStreamDefaultController2() {
                  throw new TypeError("Illegal constructor");
                }
                WritableStreamDefaultController2.prototype.error = function(e) {
                  if (e === void 0) {
                    e = void 0;
                  }
                  if (!IsWritableStreamDefaultController(this)) {
                    throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
                  }
                  var state = this._controlledWritableStream._state;
                  if (state !== "writable") {
                    return;
                  }
                  WritableStreamDefaultControllerError(this, e);
                };
                WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
                  var result = this._abortAlgorithm(reason);
                  WritableStreamDefaultControllerClearAlgorithms(this);
                  return result;
                };
                WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
                  ResetQueue(this);
                };
                return WritableStreamDefaultController2;
              }();
              Object.defineProperties(WritableStreamDefaultController.prototype, { error: { enumerable: true } });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
                  value: "WritableStreamDefaultController",
                  configurable: true
                });
              }
              function IsWritableStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
                  return false;
                }
                return true;
              }
              function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
                controller._controlledWritableStream = stream;
                stream._writableStreamController = controller;
                controller._queue = void 0;
                controller._queueTotalSize = void 0;
                ResetQueue(controller);
                controller._started = false;
                controller._strategySizeAlgorithm = sizeAlgorithm;
                controller._strategyHWM = highWaterMark;
                controller._writeAlgorithm = writeAlgorithm;
                controller._closeAlgorithm = closeAlgorithm;
                controller._abortAlgorithm = abortAlgorithm;
                var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                WritableStreamUpdateBackpressure(stream, backpressure);
                var startResult = startAlgorithm();
                var startPromise = promiseResolvedWith(startResult);
                uponPromise(startPromise, function() {
                  controller._started = true;
                  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                }, function(r) {
                  controller._started = true;
                  WritableStreamDealWithRejection(stream, r);
                });
              }
              function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
                var controller = Object.create(WritableStreamDefaultController.prototype);
                var startAlgorithm = function() {
                  return void 0;
                };
                var writeAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                var closeAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                var abortAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                if (underlyingSink.start !== void 0) {
                  startAlgorithm = function() {
                    return underlyingSink.start(controller);
                  };
                }
                if (underlyingSink.write !== void 0) {
                  writeAlgorithm = function(chunk) {
                    return underlyingSink.write(chunk, controller);
                  };
                }
                if (underlyingSink.close !== void 0) {
                  closeAlgorithm = function() {
                    return underlyingSink.close();
                  };
                }
                if (underlyingSink.abort !== void 0) {
                  abortAlgorithm = function(reason) {
                    return underlyingSink.abort(reason);
                  };
                }
                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
              }
              function WritableStreamDefaultControllerClearAlgorithms(controller) {
                controller._writeAlgorithm = void 0;
                controller._closeAlgorithm = void 0;
                controller._abortAlgorithm = void 0;
                controller._strategySizeAlgorithm = void 0;
              }
              function WritableStreamDefaultControllerClose(controller) {
                EnqueueValueWithSize(controller, closeSentinel, 0);
                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
              }
              function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
                try {
                  return controller._strategySizeAlgorithm(chunk);
                } catch (chunkSizeE) {
                  WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
                  return 1;
                }
              }
              function WritableStreamDefaultControllerGetDesiredSize(controller) {
                return controller._strategyHWM - controller._queueTotalSize;
              }
              function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
                try {
                  EnqueueValueWithSize(controller, chunk, chunkSize);
                } catch (enqueueE) {
                  WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
                  return;
                }
                var stream = controller._controlledWritableStream;
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
                  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                  WritableStreamUpdateBackpressure(stream, backpressure);
                }
                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
              }
              function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
                var stream = controller._controlledWritableStream;
                if (!controller._started) {
                  return;
                }
                if (stream._inFlightWriteRequest !== void 0) {
                  return;
                }
                var state = stream._state;
                if (state === "erroring") {
                  WritableStreamFinishErroring(stream);
                  return;
                }
                if (controller._queue.length === 0) {
                  return;
                }
                var value = PeekQueueValue(controller);
                if (value === closeSentinel) {
                  WritableStreamDefaultControllerProcessClose(controller);
                } else {
                  WritableStreamDefaultControllerProcessWrite(controller, value);
                }
              }
              function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
                if (controller._controlledWritableStream._state === "writable") {
                  WritableStreamDefaultControllerError(controller, error);
                }
              }
              function WritableStreamDefaultControllerProcessClose(controller) {
                var stream = controller._controlledWritableStream;
                WritableStreamMarkCloseRequestInFlight(stream);
                DequeueValue(controller);
                var sinkClosePromise = controller._closeAlgorithm();
                WritableStreamDefaultControllerClearAlgorithms(controller);
                uponPromise(sinkClosePromise, function() {
                  WritableStreamFinishInFlightClose(stream);
                }, function(reason) {
                  WritableStreamFinishInFlightCloseWithError(stream, reason);
                });
              }
              function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
                var stream = controller._controlledWritableStream;
                WritableStreamMarkFirstWriteRequestInFlight(stream);
                var sinkWritePromise = controller._writeAlgorithm(chunk);
                uponPromise(sinkWritePromise, function() {
                  WritableStreamFinishInFlightWrite(stream);
                  var state = stream._state;
                  DequeueValue(controller);
                  if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
                    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                    WritableStreamUpdateBackpressure(stream, backpressure);
                  }
                  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                }, function(reason) {
                  if (stream._state === "writable") {
                    WritableStreamDefaultControllerClearAlgorithms(controller);
                  }
                  WritableStreamFinishInFlightWriteWithError(stream, reason);
                });
              }
              function WritableStreamDefaultControllerGetBackpressure(controller) {
                var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
                return desiredSize <= 0;
              }
              function WritableStreamDefaultControllerError(controller, error) {
                var stream = controller._controlledWritableStream;
                WritableStreamDefaultControllerClearAlgorithms(controller);
                WritableStreamStartErroring(stream, error);
              }
              function streamBrandCheckException(name) {
                return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
              }
              function defaultWriterBrandCheckException(name) {
                return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
              }
              function defaultWriterLockException(name) {
                return new TypeError("Cannot " + name + " a stream using a released writer");
              }
              function defaultWriterClosedPromiseInitialize(writer) {
                writer._closedPromise = newPromise(function(resolve, reject) {
                  writer._closedPromise_resolve = resolve;
                  writer._closedPromise_reject = reject;
                  writer._closedPromiseState = "pending";
                });
              }
              function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
                defaultWriterClosedPromiseInitialize(writer);
                defaultWriterClosedPromiseReject(writer, reason);
              }
              function defaultWriterClosedPromiseInitializeAsResolved(writer) {
                defaultWriterClosedPromiseInitialize(writer);
                defaultWriterClosedPromiseResolve(writer);
              }
              function defaultWriterClosedPromiseReject(writer, reason) {
                if (writer._closedPromise_reject === void 0) {
                  return;
                }
                setPromiseIsHandledToTrue(writer._closedPromise);
                writer._closedPromise_reject(reason);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "rejected";
              }
              function defaultWriterClosedPromiseResetToRejected(writer, reason) {
                defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
              }
              function defaultWriterClosedPromiseResolve(writer) {
                if (writer._closedPromise_resolve === void 0) {
                  return;
                }
                writer._closedPromise_resolve(void 0);
                writer._closedPromise_resolve = void 0;
                writer._closedPromise_reject = void 0;
                writer._closedPromiseState = "resolved";
              }
              function defaultWriterReadyPromiseInitialize(writer) {
                writer._readyPromise = newPromise(function(resolve, reject) {
                  writer._readyPromise_resolve = resolve;
                  writer._readyPromise_reject = reject;
                });
                writer._readyPromiseState = "pending";
              }
              function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
                defaultWriterReadyPromiseInitialize(writer);
                defaultWriterReadyPromiseReject(writer, reason);
              }
              function defaultWriterReadyPromiseInitializeAsResolved(writer) {
                defaultWriterReadyPromiseInitialize(writer);
                defaultWriterReadyPromiseResolve(writer);
              }
              function defaultWriterReadyPromiseReject(writer, reason) {
                if (writer._readyPromise_reject === void 0) {
                  return;
                }
                setPromiseIsHandledToTrue(writer._readyPromise);
                writer._readyPromise_reject(reason);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "rejected";
              }
              function defaultWriterReadyPromiseReset(writer) {
                defaultWriterReadyPromiseInitialize(writer);
              }
              function defaultWriterReadyPromiseResetToRejected(writer, reason) {
                defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
              }
              function defaultWriterReadyPromiseResolve(writer) {
                if (writer._readyPromise_resolve === void 0) {
                  return;
                }
                writer._readyPromise_resolve(void 0);
                writer._readyPromise_resolve = void 0;
                writer._readyPromise_reject = void 0;
                writer._readyPromiseState = "fulfilled";
              }
              function isAbortSignal(value) {
                if (typeof value !== "object" || value === null) {
                  return false;
                }
                try {
                  return typeof value.aborted === "boolean";
                } catch (_a2) {
                  return false;
                }
              }
              var NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
              function isDOMExceptionConstructor(ctor) {
                if (!(typeof ctor === "function" || typeof ctor === "object")) {
                  return false;
                }
                try {
                  new ctor();
                  return true;
                } catch (_a2) {
                  return false;
                }
              }
              function createDOMExceptionPolyfill() {
                var ctor = function DOMException2(message, name) {
                  this.message = message || "";
                  this.name = name || "Error";
                  if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, this.constructor);
                  }
                };
                ctor.prototype = Object.create(Error.prototype);
                Object.defineProperty(ctor.prototype, "constructor", {
                  value: ctor,
                  writable: true,
                  configurable: true
                });
                return ctor;
              }
              var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
              function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
                var reader = AcquireReadableStreamDefaultReader(source);
                var writer = AcquireWritableStreamDefaultWriter(dest);
                source._disturbed = true;
                var shuttingDown = false;
                var currentWrite = promiseResolvedWith(void 0);
                return newPromise(function(resolve, reject) {
                  var abortAlgorithm;
                  if (signal !== void 0) {
                    abortAlgorithm = function() {
                      var error = new DOMException$1("Aborted", "AbortError");
                      var actions = [];
                      if (!preventAbort) {
                        actions.push(function() {
                          if (dest._state === "writable") {
                            return WritableStreamAbort(dest, error);
                          }
                          return promiseResolvedWith(void 0);
                        });
                      }
                      if (!preventCancel) {
                        actions.push(function() {
                          if (source._state === "readable") {
                            return ReadableStreamCancel(source, error);
                          }
                          return promiseResolvedWith(void 0);
                        });
                      }
                      shutdownWithAction(function() {
                        return Promise.all(actions.map(function(action) {
                          return action();
                        }));
                      }, true, error);
                    };
                    if (signal.aborted) {
                      abortAlgorithm();
                      return;
                    }
                    signal.addEventListener("abort", abortAlgorithm);
                  }
                  function pipeLoop() {
                    return newPromise(function(resolveLoop, rejectLoop) {
                      function next(done) {
                        if (done) {
                          resolveLoop();
                        } else {
                          PerformPromiseThen(pipeStep(), next, rejectLoop);
                        }
                      }
                      next(false);
                    });
                  }
                  function pipeStep() {
                    if (shuttingDown) {
                      return promiseResolvedWith(true);
                    }
                    return PerformPromiseThen(writer._readyPromise, function() {
                      return newPromise(function(resolveRead, rejectRead) {
                        ReadableStreamDefaultReaderRead(reader, {
                          _chunkSteps: function(chunk) {
                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                            resolveRead(false);
                          },
                          _closeSteps: function() {
                            return resolveRead(true);
                          },
                          _errorSteps: rejectRead
                        });
                      });
                    });
                  }
                  isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
                    if (!preventAbort) {
                      shutdownWithAction(function() {
                        return WritableStreamAbort(dest, storedError);
                      }, true, storedError);
                    } else {
                      shutdown(true, storedError);
                    }
                  });
                  isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
                    if (!preventCancel) {
                      shutdownWithAction(function() {
                        return ReadableStreamCancel(source, storedError);
                      }, true, storedError);
                    } else {
                      shutdown(true, storedError);
                    }
                  });
                  isOrBecomesClosed(source, reader._closedPromise, function() {
                    if (!preventClose) {
                      shutdownWithAction(function() {
                        return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
                      });
                    } else {
                      shutdown();
                    }
                  });
                  if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
                    var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
                    if (!preventCancel) {
                      shutdownWithAction(function() {
                        return ReadableStreamCancel(source, destClosed_1);
                      }, true, destClosed_1);
                    } else {
                      shutdown(true, destClosed_1);
                    }
                  }
                  setPromiseIsHandledToTrue(pipeLoop());
                  function waitForWritesToFinish() {
                    var oldCurrentWrite = currentWrite;
                    return PerformPromiseThen(currentWrite, function() {
                      return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
                    });
                  }
                  function isOrBecomesErrored(stream, promise, action) {
                    if (stream._state === "errored") {
                      action(stream._storedError);
                    } else {
                      uponRejection(promise, action);
                    }
                  }
                  function isOrBecomesClosed(stream, promise, action) {
                    if (stream._state === "closed") {
                      action();
                    } else {
                      uponFulfillment(promise, action);
                    }
                  }
                  function shutdownWithAction(action, originalIsError, originalError) {
                    if (shuttingDown) {
                      return;
                    }
                    shuttingDown = true;
                    if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                      uponFulfillment(waitForWritesToFinish(), doTheRest);
                    } else {
                      doTheRest();
                    }
                    function doTheRest() {
                      uponPromise(action(), function() {
                        return finalize(originalIsError, originalError);
                      }, function(newError) {
                        return finalize(true, newError);
                      });
                    }
                  }
                  function shutdown(isError, error) {
                    if (shuttingDown) {
                      return;
                    }
                    shuttingDown = true;
                    if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                      uponFulfillment(waitForWritesToFinish(), function() {
                        return finalize(isError, error);
                      });
                    } else {
                      finalize(isError, error);
                    }
                  }
                  function finalize(isError, error) {
                    WritableStreamDefaultWriterRelease(writer);
                    ReadableStreamReaderGenericRelease(reader);
                    if (signal !== void 0) {
                      signal.removeEventListener("abort", abortAlgorithm);
                    }
                    if (isError) {
                      reject(error);
                    } else {
                      resolve(void 0);
                    }
                  }
                });
              }
              var ReadableStreamDefaultController = function() {
                function ReadableStreamDefaultController2() {
                  throw new TypeError("Illegal constructor");
                }
                Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
                  get: function() {
                    if (!IsReadableStreamDefaultController(this)) {
                      throw defaultControllerBrandCheckException("desiredSize");
                    }
                    return ReadableStreamDefaultControllerGetDesiredSize(this);
                  },
                  enumerable: false,
                  configurable: true
                });
                ReadableStreamDefaultController2.prototype.close = function() {
                  if (!IsReadableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException("close");
                  }
                  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                    throw new TypeError("The stream is not in a state that permits close");
                  }
                  ReadableStreamDefaultControllerClose(this);
                };
                ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
                  if (chunk === void 0) {
                    chunk = void 0;
                  }
                  if (!IsReadableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException("enqueue");
                  }
                  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                    throw new TypeError("The stream is not in a state that permits enqueue");
                  }
                  return ReadableStreamDefaultControllerEnqueue(this, chunk);
                };
                ReadableStreamDefaultController2.prototype.error = function(e) {
                  if (e === void 0) {
                    e = void 0;
                  }
                  if (!IsReadableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException("error");
                  }
                  ReadableStreamDefaultControllerError(this, e);
                };
                ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
                  ResetQueue(this);
                  var result = this._cancelAlgorithm(reason);
                  ReadableStreamDefaultControllerClearAlgorithms(this);
                  return result;
                };
                ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
                  var stream = this._controlledReadableStream;
                  if (this._queue.length > 0) {
                    var chunk = DequeueValue(this);
                    if (this._closeRequested && this._queue.length === 0) {
                      ReadableStreamDefaultControllerClearAlgorithms(this);
                      ReadableStreamClose(stream);
                    } else {
                      ReadableStreamDefaultControllerCallPullIfNeeded(this);
                    }
                    readRequest._chunkSteps(chunk);
                  } else {
                    ReadableStreamAddReadRequest(stream, readRequest);
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                  }
                };
                return ReadableStreamDefaultController2;
              }();
              Object.defineProperties(ReadableStreamDefaultController.prototype, {
                close: { enumerable: true },
                enqueue: { enumerable: true },
                error: { enumerable: true },
                desiredSize: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
                  value: "ReadableStreamDefaultController",
                  configurable: true
                });
              }
              function IsReadableStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
                  return false;
                }
                return true;
              }
              function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
                var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
                if (!shouldPull) {
                  return;
                }
                if (controller._pulling) {
                  controller._pullAgain = true;
                  return;
                }
                controller._pulling = true;
                var pullPromise = controller._pullAlgorithm();
                uponPromise(pullPromise, function() {
                  controller._pulling = false;
                  if (controller._pullAgain) {
                    controller._pullAgain = false;
                    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                  }
                }, function(e) {
                  ReadableStreamDefaultControllerError(controller, e);
                });
              }
              function ReadableStreamDefaultControllerShouldCallPull(controller) {
                var stream = controller._controlledReadableStream;
                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
                  return false;
                }
                if (!controller._started) {
                  return false;
                }
                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
                  return true;
                }
                var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
                if (desiredSize > 0) {
                  return true;
                }
                return false;
              }
              function ReadableStreamDefaultControllerClearAlgorithms(controller) {
                controller._pullAlgorithm = void 0;
                controller._cancelAlgorithm = void 0;
                controller._strategySizeAlgorithm = void 0;
              }
              function ReadableStreamDefaultControllerClose(controller) {
                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
                  return;
                }
                var stream = controller._controlledReadableStream;
                controller._closeRequested = true;
                if (controller._queue.length === 0) {
                  ReadableStreamDefaultControllerClearAlgorithms(controller);
                  ReadableStreamClose(stream);
                }
              }
              function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
                  return;
                }
                var stream = controller._controlledReadableStream;
                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
                  ReadableStreamFulfillReadRequest(stream, chunk, false);
                } else {
                  var chunkSize = void 0;
                  try {
                    chunkSize = controller._strategySizeAlgorithm(chunk);
                  } catch (chunkSizeE) {
                    ReadableStreamDefaultControllerError(controller, chunkSizeE);
                    throw chunkSizeE;
                  }
                  try {
                    EnqueueValueWithSize(controller, chunk, chunkSize);
                  } catch (enqueueE) {
                    ReadableStreamDefaultControllerError(controller, enqueueE);
                    throw enqueueE;
                  }
                }
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
              }
              function ReadableStreamDefaultControllerError(controller, e) {
                var stream = controller._controlledReadableStream;
                if (stream._state !== "readable") {
                  return;
                }
                ResetQueue(controller);
                ReadableStreamDefaultControllerClearAlgorithms(controller);
                ReadableStreamError(stream, e);
              }
              function ReadableStreamDefaultControllerGetDesiredSize(controller) {
                var state = controller._controlledReadableStream._state;
                if (state === "errored") {
                  return null;
                }
                if (state === "closed") {
                  return 0;
                }
                return controller._strategyHWM - controller._queueTotalSize;
              }
              function ReadableStreamDefaultControllerHasBackpressure(controller) {
                if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
                  return false;
                }
                return true;
              }
              function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
                var state = controller._controlledReadableStream._state;
                if (!controller._closeRequested && state === "readable") {
                  return true;
                }
                return false;
              }
              function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
                controller._controlledReadableStream = stream;
                controller._queue = void 0;
                controller._queueTotalSize = void 0;
                ResetQueue(controller);
                controller._started = false;
                controller._closeRequested = false;
                controller._pullAgain = false;
                controller._pulling = false;
                controller._strategySizeAlgorithm = sizeAlgorithm;
                controller._strategyHWM = highWaterMark;
                controller._pullAlgorithm = pullAlgorithm;
                controller._cancelAlgorithm = cancelAlgorithm;
                stream._readableStreamController = controller;
                var startResult = startAlgorithm();
                uponPromise(promiseResolvedWith(startResult), function() {
                  controller._started = true;
                  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                }, function(r) {
                  ReadableStreamDefaultControllerError(controller, r);
                });
              }
              function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
                var controller = Object.create(ReadableStreamDefaultController.prototype);
                var startAlgorithm = function() {
                  return void 0;
                };
                var pullAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                var cancelAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                if (underlyingSource.start !== void 0) {
                  startAlgorithm = function() {
                    return underlyingSource.start(controller);
                  };
                }
                if (underlyingSource.pull !== void 0) {
                  pullAlgorithm = function() {
                    return underlyingSource.pull(controller);
                  };
                }
                if (underlyingSource.cancel !== void 0) {
                  cancelAlgorithm = function(reason) {
                    return underlyingSource.cancel(reason);
                  };
                }
                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
              }
              function defaultControllerBrandCheckException(name) {
                return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
              }
              function ReadableStreamTee(stream, cloneForBranch2) {
                var reader = AcquireReadableStreamDefaultReader(stream);
                var reading = false;
                var canceled1 = false;
                var canceled2 = false;
                var reason1;
                var reason2;
                var branch1;
                var branch2;
                var resolveCancelPromise;
                var cancelPromise = newPromise(function(resolve) {
                  resolveCancelPromise = resolve;
                });
                function pullAlgorithm() {
                  if (reading) {
                    return promiseResolvedWith(void 0);
                  }
                  reading = true;
                  var readRequest = {
                    _chunkSteps: function(value) {
                      queueMicrotask(function() {
                        reading = false;
                        var value1 = value;
                        var value2 = value;
                        if (!canceled1) {
                          ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);
                        }
                        if (!canceled2) {
                          ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);
                        }
                        resolveCancelPromise(void 0);
                      });
                    },
                    _closeSteps: function() {
                      reading = false;
                      if (!canceled1) {
                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                      }
                      if (!canceled2) {
                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                      }
                    },
                    _errorSteps: function() {
                      reading = false;
                    }
                  };
                  ReadableStreamDefaultReaderRead(reader, readRequest);
                  return promiseResolvedWith(void 0);
                }
                function cancel1Algorithm(reason) {
                  canceled1 = true;
                  reason1 = reason;
                  if (canceled2) {
                    var compositeReason = CreateArrayFromList([
                      reason1,
                      reason2
                    ]);
                    var cancelResult = ReadableStreamCancel(stream, compositeReason);
                    resolveCancelPromise(cancelResult);
                  }
                  return cancelPromise;
                }
                function cancel2Algorithm(reason) {
                  canceled2 = true;
                  reason2 = reason;
                  if (canceled1) {
                    var compositeReason = CreateArrayFromList([
                      reason1,
                      reason2
                    ]);
                    var cancelResult = ReadableStreamCancel(stream, compositeReason);
                    resolveCancelPromise(cancelResult);
                  }
                  return cancelPromise;
                }
                function startAlgorithm() {
                }
                branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
                branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
                uponRejection(reader._closedPromise, function(r) {
                  ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
                  ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
                  resolveCancelPromise(void 0);
                });
                return [
                  branch1,
                  branch2
                ];
              }
              function convertUnderlyingDefaultOrByteSource(source, context) {
                assertDictionary(source, context);
                var original = source;
                var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
                var cancel = original === null || original === void 0 ? void 0 : original.cancel;
                var pull = original === null || original === void 0 ? void 0 : original.pull;
                var start = original === null || original === void 0 ? void 0 : original.start;
                var type = original === null || original === void 0 ? void 0 : original.type;
                return {
                  autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
                  cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
                  pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
                  start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
                  type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
                };
              }
              function convertUnderlyingSourceCancelCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(reason) {
                  return promiseCall(fn, original, [reason]);
                };
              }
              function convertUnderlyingSourcePullCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(controller) {
                  return promiseCall(fn, original, [controller]);
                };
              }
              function convertUnderlyingSourceStartCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(controller) {
                  return reflectCall(fn, original, [controller]);
                };
              }
              function convertReadableStreamType(type, context) {
                type = "" + type;
                if (type !== "bytes") {
                  throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
                }
                return type;
              }
              function convertReaderOptions(options, context) {
                assertDictionary(options, context);
                var mode = options === null || options === void 0 ? void 0 : options.mode;
                return { mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that") };
              }
              function convertReadableStreamReaderMode(mode, context) {
                mode = "" + mode;
                if (mode !== "byob") {
                  throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
                }
                return mode;
              }
              function convertIteratorOptions(options, context) {
                assertDictionary(options, context);
                var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
                return { preventCancel: Boolean(preventCancel) };
              }
              function convertPipeOptions(options, context) {
                assertDictionary(options, context);
                var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
                var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
                var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
                var signal = options === null || options === void 0 ? void 0 : options.signal;
                if (signal !== void 0) {
                  assertAbortSignal(signal, context + " has member 'signal' that");
                }
                return {
                  preventAbort: Boolean(preventAbort),
                  preventCancel: Boolean(preventCancel),
                  preventClose: Boolean(preventClose),
                  signal
                };
              }
              function assertAbortSignal(signal, context) {
                if (!isAbortSignal(signal)) {
                  throw new TypeError(context + " is not an AbortSignal.");
                }
              }
              function convertReadableWritablePair(pair, context) {
                assertDictionary(pair, context);
                var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
                assertRequiredField(readable, "readable", "ReadableWritablePair");
                assertReadableStream(readable, context + " has member 'readable' that");
                var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
                assertRequiredField(writable, "writable", "ReadableWritablePair");
                assertWritableStream(writable, context + " has member 'writable' that");
                return {
                  readable,
                  writable
                };
              }
              var ReadableStream2 = function() {
                function ReadableStream3(rawUnderlyingSource, rawStrategy) {
                  if (rawUnderlyingSource === void 0) {
                    rawUnderlyingSource = {};
                  }
                  if (rawStrategy === void 0) {
                    rawStrategy = {};
                  }
                  if (rawUnderlyingSource === void 0) {
                    rawUnderlyingSource = null;
                  } else {
                    assertObject(rawUnderlyingSource, "First parameter");
                  }
                  var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
                  var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
                  InitializeReadableStream(this);
                  if (underlyingSource.type === "bytes") {
                    if (strategy.size !== void 0) {
                      throw new RangeError("The strategy for a byte stream cannot have a size function");
                    }
                    var highWaterMark = ExtractHighWaterMark(strategy, 0);
                    SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
                  } else {
                    var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                    var highWaterMark = ExtractHighWaterMark(strategy, 1);
                    SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
                  }
                }
                Object.defineProperty(ReadableStream3.prototype, "locked", {
                  get: function() {
                    if (!IsReadableStream(this)) {
                      throw streamBrandCheckException$1("locked");
                    }
                    return IsReadableStreamLocked(this);
                  },
                  enumerable: false,
                  configurable: true
                });
                ReadableStream3.prototype.cancel = function(reason) {
                  if (reason === void 0) {
                    reason = void 0;
                  }
                  if (!IsReadableStream(this)) {
                    return promiseRejectedWith(streamBrandCheckException$1("cancel"));
                  }
                  if (IsReadableStreamLocked(this)) {
                    return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
                  }
                  return ReadableStreamCancel(this, reason);
                };
                ReadableStream3.prototype.getReader = function(rawOptions) {
                  if (rawOptions === void 0) {
                    rawOptions = void 0;
                  }
                  if (!IsReadableStream(this)) {
                    throw streamBrandCheckException$1("getReader");
                  }
                  var options = convertReaderOptions(rawOptions, "First parameter");
                  if (options.mode === void 0) {
                    return AcquireReadableStreamDefaultReader(this);
                  }
                  return AcquireReadableStreamBYOBReader(this);
                };
                ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
                  if (rawOptions === void 0) {
                    rawOptions = {};
                  }
                  if (!IsReadableStream(this)) {
                    throw streamBrandCheckException$1("pipeThrough");
                  }
                  assertRequiredArgument(rawTransform, 1, "pipeThrough");
                  var transform = convertReadableWritablePair(rawTransform, "First parameter");
                  var options = convertPipeOptions(rawOptions, "Second parameter");
                  if (IsReadableStreamLocked(this)) {
                    throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
                  }
                  if (IsWritableStreamLocked(transform.writable)) {
                    throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
                  }
                  var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
                  setPromiseIsHandledToTrue(promise);
                  return transform.readable;
                };
                ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
                  if (rawOptions === void 0) {
                    rawOptions = {};
                  }
                  if (!IsReadableStream(this)) {
                    return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
                  }
                  if (destination === void 0) {
                    return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
                  }
                  if (!IsWritableStream(destination)) {
                    return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
                  }
                  var options;
                  try {
                    options = convertPipeOptions(rawOptions, "Second parameter");
                  } catch (e) {
                    return promiseRejectedWith(e);
                  }
                  if (IsReadableStreamLocked(this)) {
                    return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
                  }
                  if (IsWritableStreamLocked(destination)) {
                    return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
                  }
                  return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
                };
                ReadableStream3.prototype.tee = function() {
                  if (!IsReadableStream(this)) {
                    throw streamBrandCheckException$1("tee");
                  }
                  var branches = ReadableStreamTee(this);
                  return CreateArrayFromList(branches);
                };
                ReadableStream3.prototype.values = function(rawOptions) {
                  if (rawOptions === void 0) {
                    rawOptions = void 0;
                  }
                  if (!IsReadableStream(this)) {
                    throw streamBrandCheckException$1("values");
                  }
                  var options = convertIteratorOptions(rawOptions, "First parameter");
                  return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
                };
                return ReadableStream3;
              }();
              Object.defineProperties(ReadableStream2.prototype, {
                cancel: { enumerable: true },
                getReader: { enumerable: true },
                pipeThrough: { enumerable: true },
                pipeTo: { enumerable: true },
                tee: { enumerable: true },
                values: { enumerable: true },
                locked: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
                  value: "ReadableStream",
                  configurable: true
                });
              }
              if (typeof SymbolPolyfill.asyncIterator === "symbol") {
                Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
                  value: ReadableStream2.prototype.values,
                  writable: true,
                  configurable: true
                });
              }
              function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
                if (highWaterMark === void 0) {
                  highWaterMark = 1;
                }
                if (sizeAlgorithm === void 0) {
                  sizeAlgorithm = function() {
                    return 1;
                  };
                }
                var stream = Object.create(ReadableStream2.prototype);
                InitializeReadableStream(stream);
                var controller = Object.create(ReadableStreamDefaultController.prototype);
                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
                return stream;
              }
              function InitializeReadableStream(stream) {
                stream._state = "readable";
                stream._reader = void 0;
                stream._storedError = void 0;
                stream._disturbed = false;
              }
              function IsReadableStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
                  return false;
                }
                return true;
              }
              function IsReadableStreamLocked(stream) {
                if (stream._reader === void 0) {
                  return false;
                }
                return true;
              }
              function ReadableStreamCancel(stream, reason) {
                stream._disturbed = true;
                if (stream._state === "closed") {
                  return promiseResolvedWith(void 0);
                }
                if (stream._state === "errored") {
                  return promiseRejectedWith(stream._storedError);
                }
                ReadableStreamClose(stream);
                var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
                return transformPromiseWith(sourceCancelPromise, noop);
              }
              function ReadableStreamClose(stream) {
                stream._state = "closed";
                var reader = stream._reader;
                if (reader === void 0) {
                  return;
                }
                defaultReaderClosedPromiseResolve(reader);
                if (IsReadableStreamDefaultReader(reader)) {
                  reader._readRequests.forEach(function(readRequest) {
                    readRequest._closeSteps();
                  });
                  reader._readRequests = new SimpleQueue();
                }
              }
              function ReadableStreamError(stream, e) {
                stream._state = "errored";
                stream._storedError = e;
                var reader = stream._reader;
                if (reader === void 0) {
                  return;
                }
                defaultReaderClosedPromiseReject(reader, e);
                if (IsReadableStreamDefaultReader(reader)) {
                  reader._readRequests.forEach(function(readRequest) {
                    readRequest._errorSteps(e);
                  });
                  reader._readRequests = new SimpleQueue();
                } else {
                  reader._readIntoRequests.forEach(function(readIntoRequest) {
                    readIntoRequest._errorSteps(e);
                  });
                  reader._readIntoRequests = new SimpleQueue();
                }
              }
              function streamBrandCheckException$1(name) {
                return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
              }
              function convertQueuingStrategyInit(init, context) {
                assertDictionary(init, context);
                var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
                assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
                return { highWaterMark: convertUnrestrictedDouble(highWaterMark) };
              }
              var byteLengthSizeFunction = function size(chunk) {
                return chunk.byteLength;
              };
              var ByteLengthQueuingStrategy = function() {
                function ByteLengthQueuingStrategy2(options) {
                  assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
                  options = convertQueuingStrategyInit(options, "First parameter");
                  this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
                }
                Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
                  get: function() {
                    if (!IsByteLengthQueuingStrategy(this)) {
                      throw byteLengthBrandCheckException("highWaterMark");
                    }
                    return this._byteLengthQueuingStrategyHighWaterMark;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
                  get: function() {
                    if (!IsByteLengthQueuingStrategy(this)) {
                      throw byteLengthBrandCheckException("size");
                    }
                    return byteLengthSizeFunction;
                  },
                  enumerable: false,
                  configurable: true
                });
                return ByteLengthQueuingStrategy2;
              }();
              Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
                highWaterMark: { enumerable: true },
                size: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
                  value: "ByteLengthQueuingStrategy",
                  configurable: true
                });
              }
              function byteLengthBrandCheckException(name) {
                return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
              }
              function IsByteLengthQueuingStrategy(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
                  return false;
                }
                return true;
              }
              var countSizeFunction = function size() {
                return 1;
              };
              var CountQueuingStrategy = function() {
                function CountQueuingStrategy2(options) {
                  assertRequiredArgument(options, 1, "CountQueuingStrategy");
                  options = convertQueuingStrategyInit(options, "First parameter");
                  this._countQueuingStrategyHighWaterMark = options.highWaterMark;
                }
                Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
                  get: function() {
                    if (!IsCountQueuingStrategy(this)) {
                      throw countBrandCheckException("highWaterMark");
                    }
                    return this._countQueuingStrategyHighWaterMark;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
                  get: function() {
                    if (!IsCountQueuingStrategy(this)) {
                      throw countBrandCheckException("size");
                    }
                    return countSizeFunction;
                  },
                  enumerable: false,
                  configurable: true
                });
                return CountQueuingStrategy2;
              }();
              Object.defineProperties(CountQueuingStrategy.prototype, {
                highWaterMark: { enumerable: true },
                size: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
                  value: "CountQueuingStrategy",
                  configurable: true
                });
              }
              function countBrandCheckException(name) {
                return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
              }
              function IsCountQueuingStrategy(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
                  return false;
                }
                return true;
              }
              function convertTransformer(original, context) {
                assertDictionary(original, context);
                var flush = original === null || original === void 0 ? void 0 : original.flush;
                var readableType = original === null || original === void 0 ? void 0 : original.readableType;
                var start = original === null || original === void 0 ? void 0 : original.start;
                var transform = original === null || original === void 0 ? void 0 : original.transform;
                var writableType = original === null || original === void 0 ? void 0 : original.writableType;
                return {
                  flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
                  readableType,
                  start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
                  transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
                  writableType
                };
              }
              function convertTransformerFlushCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(controller) {
                  return promiseCall(fn, original, [controller]);
                };
              }
              function convertTransformerStartCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(controller) {
                  return reflectCall(fn, original, [controller]);
                };
              }
              function convertTransformerTransformCallback(fn, original, context) {
                assertFunction(fn, context);
                return function(chunk, controller) {
                  return promiseCall(fn, original, [
                    chunk,
                    controller
                  ]);
                };
              }
              var TransformStream = function() {
                function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
                  if (rawTransformer === void 0) {
                    rawTransformer = {};
                  }
                  if (rawWritableStrategy === void 0) {
                    rawWritableStrategy = {};
                  }
                  if (rawReadableStrategy === void 0) {
                    rawReadableStrategy = {};
                  }
                  if (rawTransformer === void 0) {
                    rawTransformer = null;
                  }
                  var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
                  var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
                  var transformer = convertTransformer(rawTransformer, "First parameter");
                  if (transformer.readableType !== void 0) {
                    throw new RangeError("Invalid readableType specified");
                  }
                  if (transformer.writableType !== void 0) {
                    throw new RangeError("Invalid writableType specified");
                  }
                  var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
                  var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
                  var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
                  var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
                  var startPromise_resolve;
                  var startPromise = newPromise(function(resolve) {
                    startPromise_resolve = resolve;
                  });
                  InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
                  SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
                  if (transformer.start !== void 0) {
                    startPromise_resolve(transformer.start(this._transformStreamController));
                  } else {
                    startPromise_resolve(void 0);
                  }
                }
                Object.defineProperty(TransformStream2.prototype, "readable", {
                  get: function() {
                    if (!IsTransformStream(this)) {
                      throw streamBrandCheckException$2("readable");
                    }
                    return this._readable;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(TransformStream2.prototype, "writable", {
                  get: function() {
                    if (!IsTransformStream(this)) {
                      throw streamBrandCheckException$2("writable");
                    }
                    return this._writable;
                  },
                  enumerable: false,
                  configurable: true
                });
                return TransformStream2;
              }();
              Object.defineProperties(TransformStream.prototype, {
                readable: { enumerable: true },
                writable: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
                  value: "TransformStream",
                  configurable: true
                });
              }
              function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
                function startAlgorithm() {
                  return startPromise;
                }
                function writeAlgorithm(chunk) {
                  return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
                }
                function abortAlgorithm(reason) {
                  return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
                }
                function closeAlgorithm() {
                  return TransformStreamDefaultSinkCloseAlgorithm(stream);
                }
                stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
                function pullAlgorithm() {
                  return TransformStreamDefaultSourcePullAlgorithm(stream);
                }
                function cancelAlgorithm(reason) {
                  TransformStreamErrorWritableAndUnblockWrite(stream, reason);
                  return promiseResolvedWith(void 0);
                }
                stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
                stream._backpressure = void 0;
                stream._backpressureChangePromise = void 0;
                stream._backpressureChangePromise_resolve = void 0;
                TransformStreamSetBackpressure(stream, true);
                stream._transformStreamController = void 0;
              }
              function IsTransformStream(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
                  return false;
                }
                return true;
              }
              function TransformStreamError(stream, e) {
                ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
                TransformStreamErrorWritableAndUnblockWrite(stream, e);
              }
              function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
                TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
                WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
                if (stream._backpressure) {
                  TransformStreamSetBackpressure(stream, false);
                }
              }
              function TransformStreamSetBackpressure(stream, backpressure) {
                if (stream._backpressureChangePromise !== void 0) {
                  stream._backpressureChangePromise_resolve();
                }
                stream._backpressureChangePromise = newPromise(function(resolve) {
                  stream._backpressureChangePromise_resolve = resolve;
                });
                stream._backpressure = backpressure;
              }
              var TransformStreamDefaultController = function() {
                function TransformStreamDefaultController2() {
                  throw new TypeError("Illegal constructor");
                }
                Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
                  get: function() {
                    if (!IsTransformStreamDefaultController(this)) {
                      throw defaultControllerBrandCheckException$1("desiredSize");
                    }
                    var readableController = this._controlledTransformStream._readable._readableStreamController;
                    return ReadableStreamDefaultControllerGetDesiredSize(readableController);
                  },
                  enumerable: false,
                  configurable: true
                });
                TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
                  if (chunk === void 0) {
                    chunk = void 0;
                  }
                  if (!IsTransformStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$1("enqueue");
                  }
                  TransformStreamDefaultControllerEnqueue(this, chunk);
                };
                TransformStreamDefaultController2.prototype.error = function(reason) {
                  if (reason === void 0) {
                    reason = void 0;
                  }
                  if (!IsTransformStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$1("error");
                  }
                  TransformStreamDefaultControllerError(this, reason);
                };
                TransformStreamDefaultController2.prototype.terminate = function() {
                  if (!IsTransformStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$1("terminate");
                  }
                  TransformStreamDefaultControllerTerminate(this);
                };
                return TransformStreamDefaultController2;
              }();
              Object.defineProperties(TransformStreamDefaultController.prototype, {
                enqueue: { enumerable: true },
                error: { enumerable: true },
                terminate: { enumerable: true },
                desiredSize: { enumerable: true }
              });
              if (typeof SymbolPolyfill.toStringTag === "symbol") {
                Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
                  value: "TransformStreamDefaultController",
                  configurable: true
                });
              }
              function IsTransformStreamDefaultController(x) {
                if (!typeIsObject(x)) {
                  return false;
                }
                if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
                  return false;
                }
                return true;
              }
              function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
                controller._controlledTransformStream = stream;
                stream._transformStreamController = controller;
                controller._transformAlgorithm = transformAlgorithm;
                controller._flushAlgorithm = flushAlgorithm;
              }
              function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
                var controller = Object.create(TransformStreamDefaultController.prototype);
                var transformAlgorithm = function(chunk) {
                  try {
                    TransformStreamDefaultControllerEnqueue(controller, chunk);
                    return promiseResolvedWith(void 0);
                  } catch (transformResultE) {
                    return promiseRejectedWith(transformResultE);
                  }
                };
                var flushAlgorithm = function() {
                  return promiseResolvedWith(void 0);
                };
                if (transformer.transform !== void 0) {
                  transformAlgorithm = function(chunk) {
                    return transformer.transform(chunk, controller);
                  };
                }
                if (transformer.flush !== void 0) {
                  flushAlgorithm = function() {
                    return transformer.flush(controller);
                  };
                }
                SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
              }
              function TransformStreamDefaultControllerClearAlgorithms(controller) {
                controller._transformAlgorithm = void 0;
                controller._flushAlgorithm = void 0;
              }
              function TransformStreamDefaultControllerEnqueue(controller, chunk) {
                var stream = controller._controlledTransformStream;
                var readableController = stream._readable._readableStreamController;
                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
                  throw new TypeError("Readable side is not in a state that permits enqueue");
                }
                try {
                  ReadableStreamDefaultControllerEnqueue(readableController, chunk);
                } catch (e) {
                  TransformStreamErrorWritableAndUnblockWrite(stream, e);
                  throw stream._readable._storedError;
                }
                var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
                if (backpressure !== stream._backpressure) {
                  TransformStreamSetBackpressure(stream, true);
                }
              }
              function TransformStreamDefaultControllerError(controller, e) {
                TransformStreamError(controller._controlledTransformStream, e);
              }
              function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
                var transformPromise = controller._transformAlgorithm(chunk);
                return transformPromiseWith(transformPromise, void 0, function(r) {
                  TransformStreamError(controller._controlledTransformStream, r);
                  throw r;
                });
              }
              function TransformStreamDefaultControllerTerminate(controller) {
                var stream = controller._controlledTransformStream;
                var readableController = stream._readable._readableStreamController;
                ReadableStreamDefaultControllerClose(readableController);
                var error = new TypeError("TransformStream terminated");
                TransformStreamErrorWritableAndUnblockWrite(stream, error);
              }
              function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
                var controller = stream._transformStreamController;
                if (stream._backpressure) {
                  var backpressureChangePromise = stream._backpressureChangePromise;
                  return transformPromiseWith(backpressureChangePromise, function() {
                    var writable = stream._writable;
                    var state = writable._state;
                    if (state === "erroring") {
                      throw writable._storedError;
                    }
                    return TransformStreamDefaultControllerPerformTransform(controller, chunk);
                  });
                }
                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
              }
              function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
                TransformStreamError(stream, reason);
                return promiseResolvedWith(void 0);
              }
              function TransformStreamDefaultSinkCloseAlgorithm(stream) {
                var readable = stream._readable;
                var controller = stream._transformStreamController;
                var flushPromise = controller._flushAlgorithm();
                TransformStreamDefaultControllerClearAlgorithms(controller);
                return transformPromiseWith(flushPromise, function() {
                  if (readable._state === "errored") {
                    throw readable._storedError;
                  }
                  ReadableStreamDefaultControllerClose(readable._readableStreamController);
                }, function(r) {
                  TransformStreamError(stream, r);
                  throw readable._storedError;
                });
              }
              function TransformStreamDefaultSourcePullAlgorithm(stream) {
                TransformStreamSetBackpressure(stream, false);
                return stream._backpressureChangePromise;
              }
              function defaultControllerBrandCheckException$1(name) {
                return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
              }
              function streamBrandCheckException$2(name) {
                return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
              }
              exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
              exports3.CountQueuingStrategy = CountQueuingStrategy;
              exports3.ReadableByteStreamController = ReadableByteStreamController;
              exports3.ReadableStream = ReadableStream2;
              exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
              exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
              exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
              exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
              exports3.TransformStream = TransformStream;
              exports3.TransformStreamDefaultController = TransformStreamDefaultController;
              exports3.WritableStream = WritableStream;
              exports3.WritableStreamDefaultController = WritableStreamDefaultController;
              exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
              Object.defineProperty(exports3, "__esModule", { value: true });
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            __w_pdfjs_require__2(113);
            var entryUnbind = __w_pdfjs_require__2(117);
            module2.exports = entryUnbind("String", "padStart");
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var $padStart = __w_pdfjs_require__2(114).start;
            var WEBKIT_BUG = __w_pdfjs_require__2(116);
            $({
              target: "String",
              proto: true,
              forced: WEBKIT_BUG
            }, {
              padStart: function padStart(maxLength) {
                return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var toLength = __w_pdfjs_require__2(46);
            var repeat = __w_pdfjs_require__2(115);
            var requireObjectCoercible = __w_pdfjs_require__2(19);
            var ceil = Math.ceil;
            var createMethod = function(IS_END) {
              return function($this, maxLength, fillString) {
                var S = String(requireObjectCoercible($this));
                var stringLength = S.length;
                var fillStr = fillString === void 0 ? " " : String(fillString);
                var intMaxLength = toLength(maxLength);
                var fillLen, stringFiller;
                if (intMaxLength <= stringLength || fillStr == "")
                  return S;
                fillLen = intMaxLength - stringLength;
                stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
                if (stringFiller.length > fillLen)
                  stringFiller = stringFiller.slice(0, fillLen);
                return IS_END ? S + stringFiller : stringFiller + S;
              };
            };
            module2.exports = {
              start: createMethod(false),
              end: createMethod(true)
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var toInteger = __w_pdfjs_require__2(47);
            var requireObjectCoercible = __w_pdfjs_require__2(19);
            module2.exports = function repeat(count) {
              var str = String(requireObjectCoercible(this));
              var result = "";
              var n = toInteger(count);
              if (n < 0 || n == Infinity)
                throw RangeError("Wrong number of repetitions");
              for (; n > 0; (n >>>= 1) && (str += str))
                if (n & 1)
                  result += str;
              return result;
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var userAgent = __w_pdfjs_require__2(59);
            module2.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var global2 = __w_pdfjs_require__2(10);
            var bind = __w_pdfjs_require__2(78);
            var call = Function.call;
            module2.exports = function(CONSTRUCTOR, METHOD, length) {
              return bind(call, global2[CONSTRUCTOR].prototype[METHOD], length);
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            __w_pdfjs_require__2(119);
            var entryUnbind = __w_pdfjs_require__2(117);
            module2.exports = entryUnbind("String", "padEnd");
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            "use strict";
            var $ = __w_pdfjs_require__2(9);
            var $padEnd = __w_pdfjs_require__2(114).end;
            var WEBKIT_BUG = __w_pdfjs_require__2(116);
            $({
              target: "String",
              proto: true,
              forced: WEBKIT_BUG
            }, {
              padEnd: function padEnd(maxLength) {
                return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            __w_pdfjs_require__2(121);
            var path = __w_pdfjs_require__2(42);
            module2.exports = path.Object.values;
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var $ = __w_pdfjs_require__2(9);
            var $values = __w_pdfjs_require__2(122).values;
            $({
              target: "Object",
              stat: true
            }, {
              values: function values(O) {
                return $values(O);
              }
            });
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var DESCRIPTORS = __w_pdfjs_require__2(12);
            var objectKeys = __w_pdfjs_require__2(63);
            var toIndexedObject = __w_pdfjs_require__2(16);
            var propertyIsEnumerable = __w_pdfjs_require__2(14).f;
            var createMethod = function(TO_ENTRIES) {
              return function(it) {
                var O = toIndexedObject(it);
                var keys = objectKeys(O);
                var length = keys.length;
                var i = 0;
                var result = [];
                var key;
                while (length > i) {
                  key = keys[i++];
                  if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
                    result.push(TO_ENTRIES ? [
                      key,
                      O[key]
                    ] : O[key]);
                  }
                }
                return result;
              };
            };
            module2.exports = {
              entries: createMethod(true),
              values: createMethod(false)
            };
          },
          (module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            __w_pdfjs_require__2(124);
            var path = __w_pdfjs_require__2(42);
            module2.exports = path.Object.entries;
          },
          (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
            var $ = __w_pdfjs_require__2(9);
            var $entries = __w_pdfjs_require__2(122).entries;
            $({
              target: "Object",
              stat: true
            }, {
              entries: function entries(O) {
                return $entries(O);
              }
            });
          },
          (__unused_webpack_module, exports, __w_pdfjs_require__) => {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.getDocument = getDocument;
            exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
            exports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;
            var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));
            var _util = __w_pdfjs_require__(4);
            var _display_utils = __w_pdfjs_require__(1);
            var _font_loader = __w_pdfjs_require__(126);
            var _node_utils = __w_pdfjs_require__(127);
            var _annotation_storage = __w_pdfjs_require__(128);
            var _api_compatibility = __w_pdfjs_require__(129);
            var _canvas = __w_pdfjs_require__(130);
            var _worker_options = __w_pdfjs_require__(132);
            var _is_node = __w_pdfjs_require__(6);
            var _message_handler = __w_pdfjs_require__(133);
            var _metadata = __w_pdfjs_require__(134);
            var _optional_content_config = __w_pdfjs_require__(135);
            var _transport_stream = __w_pdfjs_require__(136);
            var _webgl = __w_pdfjs_require__(137);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _toConsumableArray(arr) {
              return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
            }
            function _nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                return Array.from(iter);
            }
            function _arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return _arrayLikeToArray(arr);
            }
            function _createForOfIteratorHelper(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e2) {
                    throw _e2;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e3) {
                didErr = true;
                err = _e3;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function _slicedToArray(arr, i) {
              return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
            }
            function _nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen);
            }
            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _iterableToArrayLimit(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            var DEFAULT_RANGE_CHUNK_SIZE = 65536;
            var RENDERING_CANCELLED_TIMEOUT = 100;
            var DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
            exports.DefaultCanvasFactory = DefaultCanvasFactory;
            var DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
            exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
            var createPDFNetworkStream;
            function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
              createPDFNetworkStream = pdfNetworkStreamFactory;
            }
            function getDocument(src) {
              var task = new PDFDocumentLoadingTask();
              var source;
              if (typeof src === "string" || src instanceof URL) {
                source = {
                  url: src
                };
              } else if ((0, _util.isArrayBuffer)(src)) {
                source = {
                  data: src
                };
              } else if (src instanceof PDFDataRangeTransport) {
                source = {
                  range: src
                };
              } else {
                if (_typeof(src) !== "object") {
                  throw new Error("Invalid parameter in getDocument, need either string, URL, Uint8Array, or parameter object.");
                }
                if (!src.url && !src.data && !src.range) {
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                }
                source = src;
              }
              var params = /* @__PURE__ */ Object.create(null);
              var rangeTransport = null, worker2 = null;
              for (var key in source) {
                var value = source[key];
                switch (key) {
                  case "url":
                    if (typeof window !== "undefined") {
                      try {
                        params[key] = new URL(value, window.location).href;
                        continue;
                      } catch (ex) {
                        (0, _util.warn)('Cannot create valid URL: "'.concat(ex, '".'));
                      }
                    } else if (typeof value === "string" || value instanceof URL) {
                      params[key] = value.toString();
                      continue;
                    }
                    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                  case "range":
                    rangeTransport = value;
                    continue;
                  case "worker":
                    worker2 = value;
                    continue;
                  case "data":
                    if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                      params[key] = new Uint8Array(value);
                    } else if (value instanceof Uint8Array) {
                      break;
                    } else if (typeof value === "string") {
                      params[key] = (0, _util.stringToBytes)(value);
                    } else if (_typeof(value) === "object" && value !== null && !isNaN(value.length)) {
                      params[key] = new Uint8Array(value);
                    } else if ((0, _util.isArrayBuffer)(value)) {
                      params[key] = new Uint8Array(value);
                    } else {
                      throw new Error("Invalid PDF binary data: either typed array, string, or array-like object is expected in the data property.");
                    }
                    continue;
                }
                params[key] = value;
              }
              params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
              params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
              params.ignoreErrors = params.stopAtErrors !== true;
              params.fontExtraProperties = params.fontExtraProperties === true;
              params.pdfBug = params.pdfBug === true;
              params.enableXfa = params.enableXfa === true;
              if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                params.docBaseUrl = null;
              }
              if (!Number.isInteger(params.maxImageSize)) {
                params.maxImageSize = -1;
              }
              if (typeof params.isEvalSupported !== "boolean") {
                params.isEvalSupported = true;
              }
              if (typeof params.disableFontFace !== "boolean") {
                params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
              }
              if (typeof params.ownerDocument === "undefined") {
                params.ownerDocument = globalThis.document;
              }
              if (typeof params.disableRange !== "boolean") {
                params.disableRange = false;
              }
              if (typeof params.disableStream !== "boolean") {
                params.disableStream = false;
              }
              if (typeof params.disableAutoFetch !== "boolean") {
                params.disableAutoFetch = false;
              }
              (0, _util.setVerbosityLevel)(params.verbosity);
              if (!worker2) {
                var workerParams = {
                  verbosity: params.verbosity,
                  port: _worker_options.GlobalWorkerOptions.workerPort
                };
                worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                task._worker = worker2;
              }
              var docId = task.docId;
              worker2.promise.then(function() {
                if (task.destroyed) {
                  throw new Error("Loading aborted");
                }
                var workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                var networkStreamPromise = new Promise(function(resolve) {
                  var networkStream;
                  if (rangeTransport) {
                    networkStream = new _transport_stream.PDFDataTransportStream({
                      length: params.length,
                      initialData: params.initialData,
                      progressiveDone: params.progressiveDone,
                      contentDispositionFilename: params.contentDispositionFilename,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    }, rangeTransport);
                  } else if (!params.data) {
                    networkStream = createPDFNetworkStream({
                      url: params.url,
                      length: params.length,
                      httpHeaders: params.httpHeaders,
                      withCredentials: params.withCredentials,
                      rangeChunkSize: params.rangeChunkSize,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    });
                  }
                  resolve(networkStream);
                });
                return Promise.all([workerIdPromise, networkStreamPromise]).then(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), workerId = _ref2[0], networkStream = _ref2[1];
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                  messageHandler.postMessageTransfers = worker2.postMessageTransfers;
                  var transport = new WorkerTransport(messageHandler, task, networkStream, params);
                  task._transport = transport;
                  messageHandler.send("Ready", null);
                });
              })["catch"](task._capability.reject);
              return task;
            }
            function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
              if (worker2.destroyed) {
                return Promise.reject(new Error("Worker was destroyed"));
              }
              if (pdfDataRangeTransport) {
                source.length = pdfDataRangeTransport.length;
                source.initialData = pdfDataRangeTransport.initialData;
                source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
              }
              return worker2.messageHandler.sendWithPromise("GetDocRequest", {
                docId,
                apiVersion: "2.8.335",
                source: {
                  data: source.data,
                  url: source.url,
                  password: source.password,
                  disableAutoFetch: source.disableAutoFetch,
                  rangeChunkSize: source.rangeChunkSize,
                  length: source.length
                },
                maxImageSize: source.maxImageSize,
                disableFontFace: source.disableFontFace,
                postMessageTransfers: worker2.postMessageTransfers,
                docBaseUrl: source.docBaseUrl,
                ignoreErrors: source.ignoreErrors,
                isEvalSupported: source.isEvalSupported,
                fontExtraProperties: source.fontExtraProperties,
                enableXfa: source.enableXfa
              }).then(function(workerId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              });
            }
            var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
              var nextDocumentId = 0;
              var PDFDocumentLoadingTask2 = /* @__PURE__ */ function() {
                function PDFDocumentLoadingTask3() {
                  _classCallCheck(this, PDFDocumentLoadingTask3);
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = "d" + nextDocumentId++;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                _createClass(PDFDocumentLoadingTask3, [{
                  key: "promise",
                  get: function get() {
                    return this._capability.promise;
                  }
                }, {
                  key: "destroy",
                  value: function destroy() {
                    var _this = this;
                    this.destroyed = true;
                    var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                    return transportDestroyed.then(function() {
                      _this._transport = null;
                      if (_this._worker) {
                        _this._worker.destroy();
                        _this._worker = null;
                      }
                    });
                  }
                }]);
                return PDFDocumentLoadingTask3;
              }();
              return PDFDocumentLoadingTask2;
            }();
            var PDFDataRangeTransport = /* @__PURE__ */ function() {
              function PDFDataRangeTransport2(length, initialData) {
                var progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var contentDispositionFilename = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                _classCallCheck(this, PDFDataRangeTransport2);
                this.length = length;
                this.initialData = initialData;
                this.progressiveDone = progressiveDone;
                this.contentDispositionFilename = contentDispositionFilename;
                this._rangeListeners = [];
                this._progressListeners = [];
                this._progressiveReadListeners = [];
                this._progressiveDoneListeners = [];
                this._readyCapability = (0, _util.createPromiseCapability)();
              }
              _createClass(PDFDataRangeTransport2, [{
                key: "addRangeListener",
                value: function addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                }
              }, {
                key: "addProgressListener",
                value: function addProgressListener(listener) {
                  this._progressListeners.push(listener);
                }
              }, {
                key: "addProgressiveReadListener",
                value: function addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                }
              }, {
                key: "addProgressiveDoneListener",
                value: function addProgressiveDoneListener(listener) {
                  this._progressiveDoneListeners.push(listener);
                }
              }, {
                key: "onDataRange",
                value: function onDataRange(begin, chunk) {
                  var _iterator = _createForOfIteratorHelper(this._rangeListeners), _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var listener = _step.value;
                      listener(begin, chunk);
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                }
              }, {
                key: "onDataProgress",
                value: function onDataProgress(loaded, total) {
                  var _this2 = this;
                  this._readyCapability.promise.then(function() {
                    var _iterator2 = _createForOfIteratorHelper(_this2._progressListeners), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var listener = _step2.value;
                        listener(loaded, total);
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                  });
                }
              }, {
                key: "onDataProgressiveRead",
                value: function onDataProgressiveRead(chunk) {
                  var _this3 = this;
                  this._readyCapability.promise.then(function() {
                    var _iterator3 = _createForOfIteratorHelper(_this3._progressiveReadListeners), _step3;
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                        var listener = _step3.value;
                        listener(chunk);
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                  });
                }
              }, {
                key: "onDataProgressiveDone",
                value: function onDataProgressiveDone() {
                  var _this4 = this;
                  this._readyCapability.promise.then(function() {
                    var _iterator4 = _createForOfIteratorHelper(_this4._progressiveDoneListeners), _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                        var listener = _step4.value;
                        listener();
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                  });
                }
              }, {
                key: "transportReady",
                value: function transportReady() {
                  this._readyCapability.resolve();
                }
              }, {
                key: "requestDataRange",
                value: function requestDataRange(begin, end) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                }
              }, {
                key: "abort",
                value: function abort() {
                }
              }]);
              return PDFDataRangeTransport2;
            }();
            exports.PDFDataRangeTransport = PDFDataRangeTransport;
            var PDFDocumentProxy = /* @__PURE__ */ function() {
              function PDFDocumentProxy2(pdfInfo, transport) {
                _classCallCheck(this, PDFDocumentProxy2);
                this._pdfInfo = pdfInfo;
                this._transport = transport;
              }
              _createClass(PDFDocumentProxy2, [{
                key: "annotationStorage",
                get: function get() {
                  return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                }
              }, {
                key: "numPages",
                get: function get() {
                  return this._pdfInfo.numPages;
                }
              }, {
                key: "fingerprint",
                get: function get() {
                  return this._pdfInfo.fingerprint;
                }
              }, {
                key: "isPureXfa",
                get: function get() {
                  return this._pdfInfo.isPureXfa;
                }
              }, {
                key: "getPage",
                value: function getPage(pageNumber) {
                  return this._transport.getPage(pageNumber);
                }
              }, {
                key: "getPageIndex",
                value: function getPageIndex(ref) {
                  return this._transport.getPageIndex(ref);
                }
              }, {
                key: "getDestinations",
                value: function getDestinations() {
                  return this._transport.getDestinations();
                }
              }, {
                key: "getDestination",
                value: function getDestination(id) {
                  return this._transport.getDestination(id);
                }
              }, {
                key: "getPageLabels",
                value: function getPageLabels() {
                  return this._transport.getPageLabels();
                }
              }, {
                key: "getPageLayout",
                value: function getPageLayout() {
                  return this._transport.getPageLayout();
                }
              }, {
                key: "getPageMode",
                value: function getPageMode() {
                  return this._transport.getPageMode();
                }
              }, {
                key: "getViewerPreferences",
                value: function getViewerPreferences() {
                  return this._transport.getViewerPreferences();
                }
              }, {
                key: "getOpenAction",
                value: function getOpenAction() {
                  return this._transport.getOpenAction();
                }
              }, {
                key: "getAttachments",
                value: function getAttachments() {
                  return this._transport.getAttachments();
                }
              }, {
                key: "getJavaScript",
                value: function getJavaScript() {
                  return this._transport.getJavaScript();
                }
              }, {
                key: "getJSActions",
                value: function getJSActions() {
                  return this._transport.getDocJSActions();
                }
              }, {
                key: "getOutline",
                value: function getOutline() {
                  return this._transport.getOutline();
                }
              }, {
                key: "getOptionalContentConfig",
                value: function getOptionalContentConfig() {
                  return this._transport.getOptionalContentConfig();
                }
              }, {
                key: "getPermissions",
                value: function getPermissions() {
                  return this._transport.getPermissions();
                }
              }, {
                key: "getMetadata",
                value: function getMetadata() {
                  return this._transport.getMetadata();
                }
              }, {
                key: "getMarkInfo",
                value: function getMarkInfo() {
                  return this._transport.getMarkInfo();
                }
              }, {
                key: "getData",
                value: function getData() {
                  return this._transport.getData();
                }
              }, {
                key: "getDownloadInfo",
                value: function getDownloadInfo() {
                  return this._transport.downloadInfoCapability.promise;
                }
              }, {
                key: "getStats",
                value: function getStats() {
                  return this._transport.getStats();
                }
              }, {
                key: "cleanup",
                value: function cleanup() {
                  var keepLoadedFonts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  return this.loadingTask.destroy();
                }
              }, {
                key: "loadingParams",
                get: function get() {
                  return this._transport.loadingParams;
                }
              }, {
                key: "loadingTask",
                get: function get() {
                  return this._transport.loadingTask;
                }
              }, {
                key: "saveDocument",
                value: function saveDocument(annotationStorage) {
                  return this._transport.saveDocument(annotationStorage);
                }
              }, {
                key: "getFieldObjects",
                value: function getFieldObjects() {
                  return this._transport.getFieldObjects();
                }
              }, {
                key: "hasJSActions",
                value: function hasJSActions() {
                  return this._transport.hasJSActions();
                }
              }, {
                key: "getCalculationOrderIds",
                value: function getCalculationOrderIds() {
                  return this._transport.getCalculationOrderIds();
                }
              }]);
              return PDFDocumentProxy2;
            }();
            exports.PDFDocumentProxy = PDFDocumentProxy;
            var PDFPageProxy = /* @__PURE__ */ function() {
              function PDFPageProxy2(pageIndex, pageInfo, transport, ownerDocument) {
                var pdfBug = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                _classCallCheck(this, PDFPageProxy2);
                this._pageIndex = pageIndex;
                this._pageInfo = pageInfo;
                this._ownerDocument = ownerDocument;
                this._transport = transport;
                this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                this._pdfBug = pdfBug;
                this.commonObjs = transport.commonObjs;
                this.objs = new PDFObjects();
                this.cleanupAfterRender = false;
                this.pendingCleanup = false;
                this._intentStates = /* @__PURE__ */ new Map();
                this.destroyed = false;
              }
              _createClass(PDFPageProxy2, [{
                key: "pageNumber",
                get: function get() {
                  return this._pageIndex + 1;
                }
              }, {
                key: "rotate",
                get: function get() {
                  return this._pageInfo.rotate;
                }
              }, {
                key: "ref",
                get: function get() {
                  return this._pageInfo.ref;
                }
              }, {
                key: "userUnit",
                get: function get() {
                  return this._pageInfo.userUnit;
                }
              }, {
                key: "view",
                get: function get() {
                  return this._pageInfo.view;
                }
              }, {
                key: "getViewport",
                value: function getViewport() {
                  var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, scale = _ref3.scale, _ref3$rotation = _ref3.rotation, rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation, _ref3$offsetX = _ref3.offsetX, offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX, _ref3$offsetY = _ref3.offsetY, offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY, _ref3$dontFlip = _ref3.dontFlip, dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;
                  return new _display_utils.PageViewport({
                    viewBox: this.view,
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
              }, {
                key: "getAnnotations",
                value: function getAnnotations() {
                  var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$intent = _ref4.intent, intent = _ref4$intent === void 0 ? null : _ref4$intent;
                  if (!this._annotationsPromise || this._annotationsIntent !== intent) {
                    this._annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
                    this._annotationsIntent = intent;
                  }
                  return this._annotationsPromise;
                }
              }, {
                key: "getJSActions",
                value: function getJSActions() {
                  return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
                }
              }, {
                key: "getXfa",
                value: function getXfa() {
                  return this._xfaPromise || (this._xfaPromise = this._transport.getPageXfa(this._pageIndex));
                }
              }, {
                key: "render",
                value: function render(_ref5) {
                  var _this5 = this, _intentState;
                  var canvasContext = _ref5.canvasContext, viewport = _ref5.viewport, _ref5$intent = _ref5.intent, intent = _ref5$intent === void 0 ? "display" : _ref5$intent, _ref5$enableWebGL = _ref5.enableWebGL, enableWebGL = _ref5$enableWebGL === void 0 ? false : _ref5$enableWebGL, _ref5$renderInteracti = _ref5.renderInteractiveForms, renderInteractiveForms = _ref5$renderInteracti === void 0 ? false : _ref5$renderInteracti, _ref5$transform = _ref5.transform, transform = _ref5$transform === void 0 ? null : _ref5$transform, _ref5$imageLayer = _ref5.imageLayer, imageLayer = _ref5$imageLayer === void 0 ? null : _ref5$imageLayer, _ref5$canvasFactory = _ref5.canvasFactory, canvasFactory = _ref5$canvasFactory === void 0 ? null : _ref5$canvasFactory, _ref5$background = _ref5.background, background = _ref5$background === void 0 ? null : _ref5$background, _ref5$annotationStora = _ref5.annotationStorage, annotationStorage = _ref5$annotationStora === void 0 ? null : _ref5$annotationStora, _ref5$optionalContent = _ref5.optionalContentConfigPromise, optionalContentConfigPromise = _ref5$optionalContent === void 0 ? null : _ref5$optionalContent;
                  if (this._stats) {
                    this._stats.time("Overall");
                  }
                  var renderingIntent = intent === "print" ? "print" : "display";
                  this.pendingCleanup = false;
                  if (!optionalContentConfigPromise) {
                    optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                  }
                  var intentState = this._intentStates.get(renderingIntent);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(renderingIntent, intentState);
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  var canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                    ownerDocument: this._ownerDocument
                  });
                  var webGLContext = new _webgl.WebGLContext({
                    enable: enableWebGL
                  });
                  if (!intentState.displayReadyCapability) {
                    intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList({
                      pageIndex: this._pageIndex,
                      intent: renderingIntent,
                      renderInteractiveForms: renderInteractiveForms === true,
                      annotationStorage: (annotationStorage === null || annotationStorage === void 0 ? void 0 : annotationStorage.serializable) || null
                    });
                  }
                  var complete = function complete2(error) {
                    intentState.renderTasks["delete"](internalRenderTask);
                    if (_this5.cleanupAfterRender || renderingIntent === "print") {
                      _this5.pendingCleanup = true;
                    }
                    _this5._tryCleanup();
                    if (error) {
                      internalRenderTask.capability.reject(error);
                      _this5._abortOperatorList({
                        intentState,
                        reason: error
                      });
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    if (_this5._stats) {
                      _this5._stats.timeEnd("Rendering");
                      _this5._stats.timeEnd("Overall");
                    }
                  };
                  var internalRenderTask = new InternalRenderTask({
                    callback: complete,
                    params: {
                      canvasContext,
                      viewport,
                      transform,
                      imageLayer,
                      background
                    },
                    objs: this.objs,
                    commonObjs: this.commonObjs,
                    operatorList: intentState.operatorList,
                    pageIndex: this._pageIndex,
                    canvasFactory: canvasFactoryInstance,
                    webGLContext,
                    useRequestAnimationFrame: renderingIntent !== "print",
                    pdfBug: this._pdfBug
                  });
                  ((_intentState = intentState).renderTasks || (_intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
                  var renderTask = internalRenderTask.task;
                  Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function(_ref6) {
                    var _ref7 = _slicedToArray(_ref6, 2), transparency = _ref7[0], optionalContentConfig = _ref7[1];
                    if (_this5.pendingCleanup) {
                      complete();
                      return;
                    }
                    if (_this5._stats) {
                      _this5._stats.time("Rendering");
                    }
                    internalRenderTask.initializeGraphics({
                      transparency,
                      optionalContentConfig
                    });
                    internalRenderTask.operatorListChanged();
                  })["catch"](complete);
                  return renderTask;
                }
              }, {
                key: "getOperatorList",
                value: function getOperatorList() {
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      intentState.renderTasks["delete"](opListTask);
                    }
                  }
                  var renderingIntent = "oplist";
                  var intentState = this._intentStates.get(renderingIntent);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(renderingIntent, intentState);
                  }
                  var opListTask;
                  if (!intentState.opListReadCapability) {
                    var _intentState2;
                    opListTask = /* @__PURE__ */ Object.create(null);
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                    ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList({
                      pageIndex: this._pageIndex,
                      intent: renderingIntent
                    });
                  }
                  return intentState.opListReadCapability.promise;
                }
              }, {
                key: "streamTextContent",
                value: function streamTextContent() {
                  var _ref8 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref8$normalizeWhites = _ref8.normalizeWhitespace, normalizeWhitespace = _ref8$normalizeWhites === void 0 ? false : _ref8$normalizeWhites, _ref8$disableCombineT = _ref8.disableCombineTextItems, disableCombineTextItems = _ref8$disableCombineT === void 0 ? false : _ref8$disableCombineT;
                  var TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this._transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this._pageIndex,
                    normalizeWhitespace: normalizeWhitespace === true,
                    combineTextItems: disableCombineTextItems !== true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size: function size(textContent) {
                      return textContent.items.length;
                    }
                  });
                }
              }, {
                key: "getTextContent",
                value: function getTextContent() {
                  var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var readableStream = this.streamTextContent(params);
                  return new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function(_ref9) {
                        var _textContent$items;
                        var value = _ref9.value, done = _ref9.done;
                        if (done) {
                          resolve(textContent);
                          return;
                        }
                        Object.assign(textContent.styles, value.styles);
                        (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));
                        pump();
                      }, reject);
                    }
                    var reader = readableStream.getReader();
                    var textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                }
              }, {
                key: "_destroy",
                value: function _destroy() {
                  this.destroyed = true;
                  this._transport.pageCache[this._pageIndex] = null;
                  var waitOn = [];
                  var _iterator5 = _createForOfIteratorHelper(this._intentStates), _step5;
                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                      var _step5$value = _slicedToArray(_step5.value, 2), intent = _step5$value[0], intentState = _step5$value[1];
                      this._abortOperatorList({
                        intentState,
                        reason: new Error("Page was destroyed."),
                        force: true
                      });
                      if (intent === "oplist") {
                        continue;
                      }
                      var _iterator6 = _createForOfIteratorHelper(intentState.renderTasks), _step6;
                      try {
                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                          var internalRenderTask = _step6.value;
                          waitOn.push(internalRenderTask.completed);
                          internalRenderTask.cancel();
                        }
                      } catch (err) {
                        _iterator6.e(err);
                      } finally {
                        _iterator6.f();
                      }
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                  this.objs.clear();
                  this._annotationsPromise = null;
                  this._jsActionsPromise = null;
                  this._xfaPromise = null;
                  this.pendingCleanup = false;
                  return Promise.all(waitOn);
                }
              }, {
                key: "cleanup",
                value: function cleanup() {
                  var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  this.pendingCleanup = true;
                  return this._tryCleanup(resetStats);
                }
              }, {
                key: "_tryCleanup",
                value: function _tryCleanup() {
                  var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this.pendingCleanup) {
                    return false;
                  }
                  var _iterator7 = _createForOfIteratorHelper(this._intentStates.values()), _step7;
                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                      var _step7$value = _step7.value, renderTasks = _step7$value.renderTasks, operatorList = _step7$value.operatorList;
                      if (renderTasks.size > 0 || !operatorList.lastChunk) {
                        return false;
                      }
                    }
                  } catch (err) {
                    _iterator7.e(err);
                  } finally {
                    _iterator7.f();
                  }
                  this._intentStates.clear();
                  this.objs.clear();
                  this._annotationsPromise = null;
                  this._jsActionsPromise = null;
                  this._xfaPromise = null;
                  if (resetStats && this._stats) {
                    this._stats = new _display_utils.StatTimer();
                  }
                  this.pendingCleanup = false;
                  return true;
                }
              }, {
                key: "_startRenderPage",
                value: function _startRenderPage(transparency, intent) {
                  var intentState = this._intentStates.get(intent);
                  if (!intentState) {
                    return;
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Page Request");
                  }
                  if (intentState.displayReadyCapability) {
                    intentState.displayReadyCapability.resolve(transparency);
                  }
                }
              }, {
                key: "_renderPageChunk",
                value: function _renderPageChunk(operatorListChunk, intentState) {
                  for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  var _iterator8 = _createForOfIteratorHelper(intentState.renderTasks), _step8;
                  try {
                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                      var internalRenderTask = _step8.value;
                      internalRenderTask.operatorListChanged();
                    }
                  } catch (err) {
                    _iterator8.e(err);
                  } finally {
                    _iterator8.f();
                  }
                  if (operatorListChunk.lastChunk) {
                    this._tryCleanup();
                  }
                }
              }, {
                key: "_pumpOperatorList",
                value: function _pumpOperatorList(args) {
                  var _this6 = this;
                  (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');
                  var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);
                  var reader = readableStream.getReader();
                  var intentState = this._intentStates.get(args.intent);
                  intentState.streamReader = reader;
                  var pump = function pump2() {
                    reader.read().then(function(_ref10) {
                      var value = _ref10.value, done = _ref10.done;
                      if (done) {
                        intentState.streamReader = null;
                        return;
                      }
                      if (_this6._transport.destroyed) {
                        return;
                      }
                      _this6._renderPageChunk(value, intentState);
                      pump2();
                    }, function(reason) {
                      intentState.streamReader = null;
                      if (_this6._transport.destroyed) {
                        return;
                      }
                      if (intentState.operatorList) {
                        intentState.operatorList.lastChunk = true;
                        var _iterator9 = _createForOfIteratorHelper(intentState.renderTasks), _step9;
                        try {
                          for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                            var internalRenderTask = _step9.value;
                            internalRenderTask.operatorListChanged();
                          }
                        } catch (err) {
                          _iterator9.e(err);
                        } finally {
                          _iterator9.f();
                        }
                        _this6._tryCleanup();
                      }
                      if (intentState.displayReadyCapability) {
                        intentState.displayReadyCapability.reject(reason);
                      } else if (intentState.opListReadCapability) {
                        intentState.opListReadCapability.reject(reason);
                      } else {
                        throw reason;
                      }
                    });
                  };
                  pump();
                }
              }, {
                key: "_abortOperatorList",
                value: function _abortOperatorList(_ref11) {
                  var _this7 = this;
                  var intentState = _ref11.intentState, reason = _ref11.reason, _ref11$force = _ref11.force, force = _ref11$force === void 0 ? false : _ref11$force;
                  (0, _util.assert)(reason instanceof Error || _typeof(reason) === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');
                  if (!intentState.streamReader) {
                    return;
                  }
                  if (!force) {
                    if (intentState.renderTasks.size > 0) {
                      return;
                    }
                    if (reason instanceof _display_utils.RenderingCancelledException) {
                      intentState.streamReaderCancelTimeout = setTimeout(function() {
                        _this7._abortOperatorList({
                          intentState,
                          reason,
                          force: true
                        });
                        intentState.streamReaderCancelTimeout = null;
                      }, RENDERING_CANCELLED_TIMEOUT);
                      return;
                    }
                  }
                  intentState.streamReader.cancel(new _util.AbortException(reason === null || reason === void 0 ? void 0 : reason.message));
                  intentState.streamReader = null;
                  if (this._transport.destroyed) {
                    return;
                  }
                  var _iterator10 = _createForOfIteratorHelper(this._intentStates), _step10;
                  try {
                    for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                      var _step10$value = _slicedToArray(_step10.value, 2), intent = _step10$value[0], curIntentState = _step10$value[1];
                      if (curIntentState === intentState) {
                        this._intentStates["delete"](intent);
                        break;
                      }
                    }
                  } catch (err) {
                    _iterator10.e(err);
                  } finally {
                    _iterator10.f();
                  }
                  this.cleanup();
                }
              }, {
                key: "stats",
                get: function get() {
                  return this._stats;
                }
              }]);
              return PDFPageProxy2;
            }();
            exports.PDFPageProxy = PDFPageProxy;
            var LoopbackPort = /* @__PURE__ */ function() {
              function LoopbackPort2() {
                _classCallCheck(this, LoopbackPort2);
                this._listeners = [];
                this._deferred = Promise.resolve(void 0);
              }
              _createClass(LoopbackPort2, [{
                key: "postMessage",
                value: function postMessage2(obj, transfers) {
                  var _this8 = this;
                  function cloneValue(value) {
                    if (_typeof(value) !== "object" || value === null) {
                      return value;
                    }
                    if (cloned.has(value)) {
                      return cloned.get(value);
                    }
                    var buffer, result;
                    if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                      if (transfers !== null && transfers !== void 0 && transfers.includes(buffer)) {
                        result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                      } else {
                        result = new value.constructor(value);
                      }
                      cloned.set(value, result);
                      return result;
                    }
                    if (value instanceof Map) {
                      result = /* @__PURE__ */ new Map();
                      cloned.set(value, result);
                      var _iterator11 = _createForOfIteratorHelper(value), _step11;
                      try {
                        for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                          var _step11$value = _slicedToArray(_step11.value, 2), key = _step11$value[0], val = _step11$value[1];
                          result.set(key, cloneValue(val));
                        }
                      } catch (err) {
                        _iterator11.e(err);
                      } finally {
                        _iterator11.f();
                      }
                      return result;
                    }
                    if (value instanceof Set) {
                      result = /* @__PURE__ */ new Set();
                      cloned.set(value, result);
                      var _iterator12 = _createForOfIteratorHelper(value), _step12;
                      try {
                        for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                          var _val = _step12.value;
                          result.add(cloneValue(_val));
                        }
                      } catch (err) {
                        _iterator12.e(err);
                      } finally {
                        _iterator12.f();
                      }
                      return result;
                    }
                    result = Array.isArray(value) ? [] : {};
                    cloned.set(value, result);
                    for (var i in value) {
                      var desc = void 0, p = value;
                      while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
                        p = Object.getPrototypeOf(p);
                      }
                      if (typeof desc.value === "undefined") {
                        continue;
                      }
                      if (typeof desc.value === "function") {
                        var _value$hasOwnProperty;
                        if ((_value$hasOwnProperty = value.hasOwnProperty) !== null && _value$hasOwnProperty !== void 0 && _value$hasOwnProperty.call(value, i)) {
                          throw new Error("LoopbackPort.postMessage - cannot clone: ".concat(value[i]));
                        }
                        continue;
                      }
                      result[i] = cloneValue(desc.value);
                    }
                    return result;
                  }
                  var cloned = /* @__PURE__ */ new WeakMap();
                  var event = {
                    data: cloneValue(obj)
                  };
                  this._deferred.then(function() {
                    var _iterator13 = _createForOfIteratorHelper(_this8._listeners), _step13;
                    try {
                      for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
                        var listener = _step13.value;
                        listener.call(_this8, event);
                      }
                    } catch (err) {
                      _iterator13.e(err);
                    } finally {
                      _iterator13.f();
                    }
                  });
                }
              }, {
                key: "addEventListener",
                value: function addEventListener(name, listener) {
                  this._listeners.push(listener);
                }
              }, {
                key: "removeEventListener",
                value: function removeEventListener(name, listener) {
                  var i = this._listeners.indexOf(listener);
                  this._listeners.splice(i, 1);
                }
              }, {
                key: "terminate",
                value: function terminate() {
                  this._listeners.length = 0;
                }
              }]);
              return LoopbackPort2;
            }();
            exports.LoopbackPort = LoopbackPort;
            var PDFWorker = function PDFWorkerClosure() {
              var pdfWorkerPorts = /* @__PURE__ */ new WeakMap();
              var isWorkerDisabled = false;
              var fallbackWorkerSrc;
              var nextFakeWorkerId = 0;
              var fakeWorkerCapability;
              if (_is_node.isNodeJS && typeof __require === "function") {
                isWorkerDisabled = true;
                fallbackWorkerSrc = "./pdf.worker.js";
              } else if ((typeof document === "undefined" ? "undefined" : _typeof(document)) === "object" && "currentScript" in document) {
                var _document$currentScri;
                var pdfjsFilePath = (_document$currentScri = document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;
                if (pdfjsFilePath) {
                  fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                }
              }
              function _getWorkerSrc() {
                if (_worker_options.GlobalWorkerOptions.workerSrc) {
                  return _worker_options.GlobalWorkerOptions.workerSrc;
                }
                if (typeof fallbackWorkerSrc !== "undefined") {
                  if (!_is_node.isNodeJS) {
                    (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                  return fallbackWorkerSrc;
                }
                throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              function getMainThreadWorkerMessageHandler() {
                var mainWorkerMessageHandler2;
                try {
                  var _globalThis$pdfjsWork;
                  mainWorkerMessageHandler2 = (_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler;
                } catch (ex) {
                }
                return mainWorkerMessageHandler2 || null;
              }
              function setupFakeWorkerGlobal() {
                if (fakeWorkerCapability) {
                  return fakeWorkerCapability.promise;
                }
                fakeWorkerCapability = (0, _util.createPromiseCapability)();
                var loader = /* @__PURE__ */ function() {
                  var _ref12 = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee() {
                    var mainWorkerMessageHandler, worker;
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                            if (!mainWorkerMessageHandler) {
                              _context.next = 3;
                              break;
                            }
                            return _context.abrupt("return", mainWorkerMessageHandler);
                          case 3:
                            if (!(_is_node.isNodeJS && typeof __require === "function")) {
                              _context.next = 6;
                              break;
                            }
                            worker = eval("require")(_getWorkerSrc());
                            return _context.abrupt("return", worker.WorkerMessageHandler);
                          case 6:
                            _context.next = 8;
                            return (0, _display_utils.loadScript)(_getWorkerSrc());
                          case 8:
                            return _context.abrupt("return", window.pdfjsWorker.WorkerMessageHandler);
                          case 9:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));
                  return function loader2() {
                    return _ref12.apply(this, arguments);
                  };
                }();
                loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
                return fakeWorkerCapability.promise;
              }
              function createCDNWrapper(url) {
                var wrapper = "importScripts('" + url + "');";
                return URL.createObjectURL(new Blob([wrapper]));
              }
              var PDFWorker = /* @__PURE__ */ function() {
                function PDFWorker3() {
                  var _ref13 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref13$name = _ref13.name, name = _ref13$name === void 0 ? null : _ref13$name, _ref13$port = _ref13.port, port = _ref13$port === void 0 ? null : _ref13$port, _ref13$verbosity = _ref13.verbosity, verbosity = _ref13$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref13$verbosity;
                  _classCallCheck(this, PDFWorker3);
                  if (port && pdfWorkerPorts.has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.postMessageTransfers = true;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    pdfWorkerPorts.set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                _createClass(PDFWorker3, [{
                  key: "promise",
                  get: function get() {
                    return this._readyCapability.promise;
                  }
                }, {
                  key: "port",
                  get: function get() {
                    return this._port;
                  }
                }, {
                  key: "messageHandler",
                  get: function get() {
                    return this._messageHandler;
                  }
                }, {
                  key: "_initializeFromPort",
                  value: function _initializeFromPort(port) {
                    this._port = port;
                    this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                    this._messageHandler.on("ready", function() {
                    });
                    this._readyCapability.resolve();
                  }
                }, {
                  key: "_initialize",
                  value: function _initialize() {
                    var _this9 = this;
                    if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                      var workerSrc = _getWorkerSrc();
                      try {
                        if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
                          workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
                        }
                        var worker2 = new Worker(workerSrc);
                        var messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                        var terminateEarly = function terminateEarly2() {
                          worker2.removeEventListener("error", onWorkerError);
                          messageHandler.destroy();
                          worker2.terminate();
                          if (_this9.destroyed) {
                            _this9._readyCapability.reject(new Error("Worker was destroyed"));
                          } else {
                            _this9._setupFakeWorker();
                          }
                        };
                        var onWorkerError = function onWorkerError2() {
                          if (!_this9._webWorker) {
                            terminateEarly();
                          }
                        };
                        worker2.addEventListener("error", onWorkerError);
                        messageHandler.on("test", function(data) {
                          worker2.removeEventListener("error", onWorkerError);
                          if (_this9.destroyed) {
                            terminateEarly();
                            return;
                          }
                          if (data) {
                            _this9._messageHandler = messageHandler;
                            _this9._port = worker2;
                            _this9._webWorker = worker2;
                            if (!data.supportTransfers) {
                              _this9.postMessageTransfers = false;
                            }
                            _this9._readyCapability.resolve();
                            messageHandler.send("configure", {
                              verbosity: _this9.verbosity
                            });
                          } else {
                            _this9._setupFakeWorker();
                            messageHandler.destroy();
                            worker2.terminate();
                          }
                        });
                        messageHandler.on("ready", function(data) {
                          worker2.removeEventListener("error", onWorkerError);
                          if (_this9.destroyed) {
                            terminateEarly();
                            return;
                          }
                          try {
                            sendTest();
                          } catch (e) {
                            _this9._setupFakeWorker();
                          }
                        });
                        var sendTest = function sendTest2() {
                          var testObj = new Uint8Array([_this9.postMessageTransfers ? 255 : 0]);
                          try {
                            messageHandler.send("test", testObj, [testObj.buffer]);
                          } catch (ex) {
                            (0, _util.warn)("Cannot use postMessage transfers.");
                            testObj[0] = 0;
                            messageHandler.send("test", testObj);
                          }
                        };
                        sendTest();
                        return;
                      } catch (e) {
                        (0, _util.info)("The worker has been disabled.");
                      }
                    }
                    this._setupFakeWorker();
                  }
                }, {
                  key: "_setupFakeWorker",
                  value: function _setupFakeWorker() {
                    var _this10 = this;
                    if (!isWorkerDisabled) {
                      (0, _util.warn)("Setting up fake worker.");
                      isWorkerDisabled = true;
                    }
                    setupFakeWorkerGlobal().then(function(WorkerMessageHandler) {
                      if (_this10.destroyed) {
                        _this10._readyCapability.reject(new Error("Worker was destroyed"));
                        return;
                      }
                      var port = new LoopbackPort();
                      _this10._port = port;
                      var id = "fake" + nextFakeWorkerId++;
                      var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                      WorkerMessageHandler.setup(workerHandler, port);
                      var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                      _this10._messageHandler = messageHandler;
                      _this10._readyCapability.resolve();
                      messageHandler.send("configure", {
                        verbosity: _this10.verbosity
                      });
                    })["catch"](function(reason) {
                      _this10._readyCapability.reject(new Error('Setting up fake worker failed: "'.concat(reason.message, '".')));
                    });
                  }
                }, {
                  key: "destroy",
                  value: function destroy() {
                    this.destroyed = true;
                    if (this._webWorker) {
                      this._webWorker.terminate();
                      this._webWorker = null;
                    }
                    pdfWorkerPorts["delete"](this._port);
                    this._port = null;
                    if (this._messageHandler) {
                      this._messageHandler.destroy();
                      this._messageHandler = null;
                    }
                  }
                }], [{
                  key: "fromPort",
                  value: function fromPort(params) {
                    if (!params || !params.port) {
                      throw new Error("PDFWorker.fromPort - invalid method signature.");
                    }
                    if (pdfWorkerPorts.has(params.port)) {
                      return pdfWorkerPorts.get(params.port);
                    }
                    return new PDFWorker3(params);
                  }
                }, {
                  key: "getWorkerSrc",
                  value: function getWorkerSrc2() {
                    return _getWorkerSrc();
                  }
                }]);
                return PDFWorker3;
              }();
              return PDFWorker;
            }();
            exports.PDFWorker = PDFWorker;
            var WorkerTransport = /* @__PURE__ */ function() {
              function WorkerTransport2(messageHandler, loadingTask, networkStream, params) {
                _classCallCheck(this, WorkerTransport2);
                this.messageHandler = messageHandler;
                this.loadingTask = loadingTask;
                this.commonObjs = new PDFObjects();
                this.fontLoader = new _font_loader.FontLoader({
                  docId: loadingTask.docId,
                  onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                  ownerDocument: params.ownerDocument
                });
                this._params = params;
                this.CMapReaderFactory = new params.CMapReaderFactory({
                  baseUrl: params.cMapUrl,
                  isCompressed: params.cMapPacked
                });
                this.destroyed = false;
                this.destroyCapability = null;
                this._passwordCapability = null;
                this._networkStream = networkStream;
                this._fullReader = null;
                this._lastProgress = null;
                this.pageCache = [];
                this.pagePromises = [];
                this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                this.setupMessageHandler();
              }
              _createClass(WorkerTransport2, [{
                key: "loadingTaskSettled",
                get: function get() {
                  return this.loadingTask._capability.settled;
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  var _this11 = this;
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = (0, _util.createPromiseCapability)();
                  if (this._passwordCapability) {
                    this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                  }
                  var waitOn = [];
                  this.pageCache.forEach(function(page) {
                    if (page) {
                      waitOn.push(page._destroy());
                    }
                  });
                  this.pageCache.length = 0;
                  this.pagePromises.length = 0;
                  var terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  if (this.loadingTaskSettled) {
                    var annotationStorageResetModified = this.loadingTask.promise.then(function(pdfDocument) {
                      if (pdfDocument.hasOwnProperty("annotationStorage")) {
                        pdfDocument.annotationStorage.resetModified();
                      }
                    })["catch"](function() {
                    });
                    waitOn.push(annotationStorageResetModified);
                  }
                  Promise.all(waitOn).then(function() {
                    _this11.commonObjs.clear();
                    _this11.fontLoader.clear();
                    _this11._hasJSActionsPromise = null;
                    if (_this11._networkStream) {
                      _this11._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                    }
                    if (_this11.messageHandler) {
                      _this11.messageHandler.destroy();
                      _this11.messageHandler = null;
                    }
                    _this11.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                }
              }, {
                key: "setupMessageHandler",
                value: function setupMessageHandler() {
                  var _this12 = this;
                  var messageHandler = this.messageHandler, loadingTask = this.loadingTask;
                  messageHandler.on("GetReader", function(data, sink) {
                    (0, _util.assert)(_this12._networkStream, "GetReader - no `IPDFStream` instance available.");
                    _this12._fullReader = _this12._networkStream.getFullReader();
                    _this12._fullReader.onProgress = function(evt) {
                      _this12._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = function() {
                      _this12._fullReader.read().then(function(_ref14) {
                        var value = _ref14.value, done = _ref14.done;
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      })["catch"](function(reason) {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = function(reason) {
                      _this12._fullReader.cancel(reason);
                      sink.ready["catch"](function(readyReason) {
                        if (_this12.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("ReaderHeadersReady", function(data) {
                    var headersCapability = (0, _util.createPromiseCapability)();
                    var fullReader = _this12._fullReader;
                    fullReader.headersReady.then(function() {
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (_this12._lastProgress && loadingTask.onProgress) {
                          loadingTask.onProgress(_this12._lastProgress);
                        }
                        fullReader.onProgress = function(evt) {
                          if (loadingTask.onProgress) {
                            loadingTask.onProgress({
                              loaded: evt.loaded,
                              total: evt.total
                            });
                          }
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  });
                  messageHandler.on("GetRangeReader", function(data, sink) {
                    (0, _util.assert)(_this12._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                    var rangeReader = _this12._networkStream.getRangeReader(data.begin, data.end);
                    if (!rangeReader) {
                      sink.close();
                      return;
                    }
                    sink.onPull = function() {
                      rangeReader.read().then(function(_ref15) {
                        var value = _ref15.value, done = _ref15.done;
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      })["catch"](function(reason) {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = function(reason) {
                      rangeReader.cancel(reason);
                      sink.ready["catch"](function(readyReason) {
                        if (_this12.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("GetDoc", function(_ref16) {
                    var pdfInfo = _ref16.pdfInfo;
                    _this12._numPages = pdfInfo.numPages;
                    loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this12));
                  });
                  messageHandler.on("DocException", function(ex) {
                    var reason;
                    switch (ex.name) {
                      case "PasswordException":
                        reason = new _util.PasswordException(ex.message, ex.code);
                        break;
                      case "InvalidPDFException":
                        reason = new _util.InvalidPDFException(ex.message);
                        break;
                      case "MissingPDFException":
                        reason = new _util.MissingPDFException(ex.message);
                        break;
                      case "UnexpectedResponseException":
                        reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                        break;
                      case "UnknownErrorException":
                        reason = new _util.UnknownErrorException(ex.message, ex.details);
                        break;
                    }
                    if (!(reason instanceof Error)) {
                      var msg = "DocException - expected a valid Error.";
                      (0, _util.warn)(msg);
                    }
                    loadingTask._capability.reject(reason);
                  });
                  messageHandler.on("PasswordRequest", function(exception) {
                    _this12._passwordCapability = (0, _util.createPromiseCapability)();
                    if (loadingTask.onPassword) {
                      var updatePassword = function updatePassword2(password) {
                        _this12._passwordCapability.resolve({
                          password
                        });
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        _this12._passwordCapability.reject(ex);
                      }
                    } else {
                      _this12._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return _this12._passwordCapability.promise;
                  });
                  messageHandler.on("DataLoaded", function(data) {
                    if (loadingTask.onProgress) {
                      loadingTask.onProgress({
                        loaded: data.length,
                        total: data.length
                      });
                    }
                    _this12.downloadInfoCapability.resolve(data);
                  });
                  messageHandler.on("StartRenderPage", function(data) {
                    if (_this12.destroyed) {
                      return;
                    }
                    var page = _this12.pageCache[data.pageIndex];
                    page._startRenderPage(data.transparency, data.intent);
                  });
                  messageHandler.on("commonobj", function(data) {
                    var _globalThis$FontInspe;
                    if (_this12.destroyed) {
                      return;
                    }
                    var _data = _slicedToArray(data, 3), id = _data[0], type = _data[1], exportedData = _data[2];
                    if (_this12.commonObjs.has(id)) {
                      return;
                    }
                    switch (type) {
                      case "Font":
                        var params = _this12._params;
                        if ("error" in exportedData) {
                          var exportedError = exportedData.error;
                          (0, _util.warn)("Error during font loading: ".concat(exportedError));
                          _this12.commonObjs.resolve(id, exportedError);
                          break;
                        }
                        var fontRegistry = null;
                        if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
                          fontRegistry = {
                            registerFont: function registerFont(font2, url) {
                              globalThis.FontInspector.fontAdded(font2, url);
                            }
                          };
                        }
                        var font = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          ignoreErrors: params.ignoreErrors,
                          onUnsupportedFeature: _this12._onUnsupportedFeature.bind(_this12),
                          fontRegistry
                        });
                        _this12.fontLoader.bind(font)["catch"](function(reason) {
                          return messageHandler.sendWithPromise("FontFallback", {
                            id
                          });
                        })["finally"](function() {
                          if (!params.fontExtraProperties && font.data) {
                            font.data = null;
                          }
                          _this12.commonObjs.resolve(id, font);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                        _this12.commonObjs.resolve(id, exportedData);
                        break;
                      default:
                        throw new Error("Got unknown common object type ".concat(type));
                    }
                  });
                  messageHandler.on("obj", function(data) {
                    var _imageData$data;
                    if (_this12.destroyed) {
                      return void 0;
                    }
                    var _data2 = _slicedToArray(data, 4), id = _data2[0], pageIndex = _data2[1], type = _data2[2], imageData = _data2[3];
                    var pageProxy = _this12.pageCache[pageIndex];
                    if (pageProxy.objs.has(id)) {
                      return void 0;
                    }
                    switch (type) {
                      case "Image":
                        pageProxy.objs.resolve(id, imageData);
                        var MAX_IMAGE_SIZE_TO_STORE = 8e6;
                        if ((imageData === null || imageData === void 0 ? void 0 : (_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) > MAX_IMAGE_SIZE_TO_STORE) {
                          pageProxy.cleanupAfterRender = true;
                        }
                        break;
                      default:
                        throw new Error("Got unknown object type ".concat(type));
                    }
                    return void 0;
                  });
                  messageHandler.on("DocProgress", function(data) {
                    if (_this12.destroyed) {
                      return;
                    }
                    if (loadingTask.onProgress) {
                      loadingTask.onProgress({
                        loaded: data.loaded,
                        total: data.total
                      });
                    }
                  });
                  messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                  messageHandler.on("FetchBuiltInCMap", function(data, sink) {
                    if (_this12.destroyed) {
                      sink.error(new Error("Worker was destroyed"));
                      return;
                    }
                    var fetched = false;
                    sink.onPull = function() {
                      if (fetched) {
                        sink.close();
                        return;
                      }
                      fetched = true;
                      _this12.CMapReaderFactory.fetch(data).then(function(builtInCMap) {
                        sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
                      })["catch"](function(reason) {
                        sink.error(reason);
                      });
                    };
                  });
                }
              }, {
                key: "_onUnsupportedFeature",
                value: function _onUnsupportedFeature(_ref17) {
                  var featureId = _ref17.featureId;
                  if (this.destroyed) {
                    return;
                  }
                  if (this.loadingTask.onUnsupportedFeature) {
                    this.loadingTask.onUnsupportedFeature(featureId);
                  }
                }
              }, {
                key: "getData",
                value: function getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                }
              }, {
                key: "getPage",
                value: function getPage(pageNumber) {
                  var _this13 = this;
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                    return Promise.reject(new Error("Invalid page request"));
                  }
                  var pageIndex = pageNumber - 1;
                  if (pageIndex in this.pagePromises) {
                    return this.pagePromises[pageIndex];
                  }
                  var promise = this.messageHandler.sendWithPromise("GetPage", {
                    pageIndex
                  }).then(function(pageInfo) {
                    if (_this13.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    var page = new PDFPageProxy(pageIndex, pageInfo, _this13, _this13._params.ownerDocument, _this13._params.pdfBug);
                    _this13.pageCache[pageIndex] = page;
                    return page;
                  });
                  this.pagePromises[pageIndex] = promise;
                  return promise;
                }
              }, {
                key: "getPageIndex",
                value: function getPageIndex(ref) {
                  return this.messageHandler.sendWithPromise("GetPageIndex", {
                    ref
                  })["catch"](function(reason) {
                    return Promise.reject(new Error(reason));
                  });
                }
              }, {
                key: "getAnnotations",
                value: function getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                }
              }, {
                key: "saveDocument",
                value: function saveDocument(annotationStorage) {
                  var _this$_fullReader$fil, _this$_fullReader;
                  return this.messageHandler.sendWithPromise("SaveDocument", {
                    numPages: this._numPages,
                    annotationStorage: (annotationStorage === null || annotationStorage === void 0 ? void 0 : annotationStorage.serializable) || null,
                    filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
                  })["finally"](function() {
                    if (annotationStorage) {
                      annotationStorage.resetModified();
                    }
                  });
                }
              }, {
                key: "getFieldObjects",
                value: function getFieldObjects() {
                  return this.messageHandler.sendWithPromise("GetFieldObjects", null);
                }
              }, {
                key: "hasJSActions",
                value: function hasJSActions() {
                  return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
                }
              }, {
                key: "getCalculationOrderIds",
                value: function getCalculationOrderIds() {
                  return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                }
              }, {
                key: "getDestinations",
                value: function getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                }
              }, {
                key: "getDestination",
                value: function getDestination(id) {
                  if (typeof id !== "string") {
                    return Promise.reject(new Error("Invalid destination request."));
                  }
                  return this.messageHandler.sendWithPromise("GetDestination", {
                    id
                  });
                }
              }, {
                key: "getPageLabels",
                value: function getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                }
              }, {
                key: "getPageLayout",
                value: function getPageLayout() {
                  return this.messageHandler.sendWithPromise("GetPageLayout", null);
                }
              }, {
                key: "getPageMode",
                value: function getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                }
              }, {
                key: "getViewerPreferences",
                value: function getViewerPreferences() {
                  return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                }
              }, {
                key: "getOpenAction",
                value: function getOpenAction() {
                  return this.messageHandler.sendWithPromise("GetOpenAction", null);
                }
              }, {
                key: "getAttachments",
                value: function getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                }
              }, {
                key: "getJavaScript",
                value: function getJavaScript() {
                  return this.messageHandler.sendWithPromise("GetJavaScript", null);
                }
              }, {
                key: "getDocJSActions",
                value: function getDocJSActions() {
                  return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                }
              }, {
                key: "getPageJSActions",
                value: function getPageJSActions(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageJSActions", {
                    pageIndex
                  });
                }
              }, {
                key: "getPageXfa",
                value: function getPageXfa(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageXfa", {
                    pageIndex
                  });
                }
              }, {
                key: "getOutline",
                value: function getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                }
              }, {
                key: "getOptionalContentConfig",
                value: function getOptionalContentConfig() {
                  return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(function(results) {
                    return new _optional_content_config.OptionalContentConfig(results);
                  });
                }
              }, {
                key: "getPermissions",
                value: function getPermissions() {
                  return this.messageHandler.sendWithPromise("GetPermissions", null);
                }
              }, {
                key: "getMetadata",
                value: function getMetadata() {
                  var _this14 = this;
                  return this.messageHandler.sendWithPromise("GetMetadata", null).then(function(results) {
                    var _this14$_fullReader$f, _this14$_fullReader, _this14$_fullReader$c, _this14$_fullReader2;
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: (_this14$_fullReader$f = (_this14$_fullReader = _this14._fullReader) === null || _this14$_fullReader === void 0 ? void 0 : _this14$_fullReader.filename) !== null && _this14$_fullReader$f !== void 0 ? _this14$_fullReader$f : null,
                      contentLength: (_this14$_fullReader$c = (_this14$_fullReader2 = _this14._fullReader) === null || _this14$_fullReader2 === void 0 ? void 0 : _this14$_fullReader2.contentLength) !== null && _this14$_fullReader$c !== void 0 ? _this14$_fullReader$c : null
                    };
                  });
                }
              }, {
                key: "getMarkInfo",
                value: function getMarkInfo() {
                  return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                }
              }, {
                key: "getStats",
                value: function getStats() {
                  return this.messageHandler.sendWithPromise("GetStats", null);
                }
              }, {
                key: "startCleanup",
                value: function() {
                  var _startCleanup = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee2() {
                    var keepLoadedFonts, i, ii, page, cleanupSuccessful, _args2 = arguments;
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            keepLoadedFonts = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : false;
                            _context2.next = 3;
                            return this.messageHandler.sendWithPromise("Cleanup", null);
                          case 3:
                            if (!this.destroyed) {
                              _context2.next = 5;
                              break;
                            }
                            return _context2.abrupt("return");
                          case 5:
                            i = 0, ii = this.pageCache.length;
                          case 6:
                            if (!(i < ii)) {
                              _context2.next = 16;
                              break;
                            }
                            page = this.pageCache[i];
                            if (page) {
                              _context2.next = 10;
                              break;
                            }
                            return _context2.abrupt("continue", 13);
                          case 10:
                            cleanupSuccessful = page.cleanup();
                            if (cleanupSuccessful) {
                              _context2.next = 13;
                              break;
                            }
                            throw new Error("startCleanup: Page ".concat(i + 1, " is currently rendering."));
                          case 13:
                            i++;
                            _context2.next = 6;
                            break;
                          case 16:
                            this.commonObjs.clear();
                            if (!keepLoadedFonts) {
                              this.fontLoader.clear();
                            }
                            this._hasJSActionsPromise = null;
                          case 19:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function startCleanup() {
                    return _startCleanup.apply(this, arguments);
                  }
                  return startCleanup;
                }()
              }, {
                key: "loadingParams",
                get: function get() {
                  var params = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableAutoFetch: params.disableAutoFetch,
                    disableFontFace: params.disableFontFace
                  });
                }
              }]);
              return WorkerTransport2;
            }();
            var PDFObjects = /* @__PURE__ */ function() {
              function PDFObjects2() {
                _classCallCheck(this, PDFObjects2);
                this._objs = /* @__PURE__ */ Object.create(null);
              }
              _createClass(PDFObjects2, [{
                key: "_ensureObj",
                value: function _ensureObj(objId) {
                  if (this._objs[objId]) {
                    return this._objs[objId];
                  }
                  return this._objs[objId] = {
                    capability: (0, _util.createPromiseCapability)(),
                    data: null,
                    resolved: false
                  };
                }
              }, {
                key: "get",
                value: function get(objId) {
                  var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  if (callback) {
                    this._ensureObj(objId).capability.promise.then(callback);
                    return null;
                  }
                  var obj = this._objs[objId];
                  if (!obj || !obj.resolved) {
                    throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
                  }
                  return obj.data;
                }
              }, {
                key: "has",
                value: function has(objId) {
                  var obj = this._objs[objId];
                  return (obj === null || obj === void 0 ? void 0 : obj.resolved) || false;
                }
              }, {
                key: "resolve",
                value: function resolve(objId, data) {
                  var obj = this._ensureObj(objId);
                  obj.resolved = true;
                  obj.data = data;
                  obj.capability.resolve(data);
                }
              }, {
                key: "clear",
                value: function clear() {
                  this._objs = /* @__PURE__ */ Object.create(null);
                }
              }]);
              return PDFObjects2;
            }();
            var RenderTask = /* @__PURE__ */ function() {
              function RenderTask2(internalRenderTask) {
                _classCallCheck(this, RenderTask2);
                this._internalRenderTask = internalRenderTask;
                this.onContinue = null;
              }
              _createClass(RenderTask2, [{
                key: "promise",
                get: function get() {
                  return this._internalRenderTask.capability.promise;
                }
              }, {
                key: "cancel",
                value: function cancel() {
                  this._internalRenderTask.cancel();
                }
              }]);
              return RenderTask2;
            }();
            var InternalRenderTask = function InternalRenderTaskClosure() {
              var canvasInRendering = /* @__PURE__ */ new WeakSet();
              var InternalRenderTask2 = /* @__PURE__ */ function() {
                function InternalRenderTask3(_ref18) {
                  var callback = _ref18.callback, params = _ref18.params, objs = _ref18.objs, commonObjs = _ref18.commonObjs, operatorList = _ref18.operatorList, pageIndex = _ref18.pageIndex, canvasFactory = _ref18.canvasFactory, webGLContext = _ref18.webGLContext, _ref18$useRequestAnim = _ref18.useRequestAnimationFrame, useRequestAnimationFrame = _ref18$useRequestAnim === void 0 ? false : _ref18$useRequestAnim, _ref18$pdfBug = _ref18.pdfBug, pdfBug = _ref18$pdfBug === void 0 ? false : _ref18$pdfBug;
                  _classCallCheck(this, InternalRenderTask3);
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this.webGLContext = webGLContext;
                  this._pdfBug = pdfBug;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                _createClass(InternalRenderTask3, [{
                  key: "completed",
                  get: function get() {
                    return this.capability.promise["catch"](function() {
                    });
                  }
                }, {
                  key: "initializeGraphics",
                  value: function initializeGraphics(_ref19) {
                    var _globalThis$StepperMa;
                    var _ref19$transparency = _ref19.transparency, transparency = _ref19$transparency === void 0 ? false : _ref19$transparency, optionalContentConfig = _ref19.optionalContentConfig;
                    if (this.cancelled) {
                      return;
                    }
                    if (this._canvas) {
                      if (canvasInRendering.has(this._canvas)) {
                        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                      }
                      canvasInRendering.add(this._canvas);
                    }
                    if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
                      this.stepper = globalThis.StepperManager.create(this._pageIndex);
                      this.stepper.init(this.operatorList);
                      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                    }
                    var _this$params = this.params, canvasContext = _this$params.canvasContext, viewport = _this$params.viewport, transform = _this$params.transform, imageLayer = _this$params.imageLayer, background = _this$params.background;
                    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);
                    this.gfx.beginDrawing({
                      transform,
                      viewport,
                      transparency,
                      background
                    });
                    this.operatorListIdx = 0;
                    this.graphicsReady = true;
                    if (this.graphicsReadyCallback) {
                      this.graphicsReadyCallback();
                    }
                  }
                }, {
                  key: "cancel",
                  value: function cancel() {
                    var error = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                    this.running = false;
                    this.cancelled = true;
                    if (this.gfx) {
                      this.gfx.endDrawing();
                    }
                    if (this._canvas) {
                      canvasInRendering["delete"](this._canvas);
                    }
                    this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas"));
                  }
                }, {
                  key: "operatorListChanged",
                  value: function operatorListChanged() {
                    if (!this.graphicsReady) {
                      if (!this.graphicsReadyCallback) {
                        this.graphicsReadyCallback = this._continueBound;
                      }
                      return;
                    }
                    if (this.stepper) {
                      this.stepper.updateOperatorList(this.operatorList);
                    }
                    if (this.running) {
                      return;
                    }
                    this._continue();
                  }
                }, {
                  key: "_continue",
                  value: function _continue() {
                    this.running = true;
                    if (this.cancelled) {
                      return;
                    }
                    if (this.task.onContinue) {
                      this.task.onContinue(this._scheduleNextBound);
                    } else {
                      this._scheduleNext();
                    }
                  }
                }, {
                  key: "_scheduleNext",
                  value: function _scheduleNext() {
                    var _this15 = this;
                    if (this._useRequestAnimationFrame) {
                      window.requestAnimationFrame(function() {
                        _this15._nextBound()["catch"](_this15._cancelBound);
                      });
                    } else {
                      Promise.resolve().then(this._nextBound)["catch"](this._cancelBound);
                    }
                  }
                }, {
                  key: "_next",
                  value: function() {
                    var _next2 = _asyncToGenerator(/* @__PURE__ */ _regenerator["default"].mark(function _callee3() {
                      return _regenerator["default"].wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              if (!this.cancelled) {
                                _context3.next = 2;
                                break;
                              }
                              return _context3.abrupt("return");
                            case 2:
                              this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                              if (this.operatorListIdx === this.operatorList.argsArray.length) {
                                this.running = false;
                                if (this.operatorList.lastChunk) {
                                  this.gfx.endDrawing();
                                  if (this._canvas) {
                                    canvasInRendering["delete"](this._canvas);
                                  }
                                  this.callback();
                                }
                              }
                            case 4:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3, this);
                    }));
                    function _next() {
                      return _next2.apply(this, arguments);
                    }
                    return _next;
                  }()
                }]);
                return InternalRenderTask3;
              }();
              return InternalRenderTask2;
            }();
            var version = "2.8.335";
            exports.version = version;
            var build = "228adbf67";
            exports.build = build;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FontLoader = exports2.FontFaceObject = void 0;
            var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(2));
            var _util2 = __w_pdfjs_require__2(4);
            function _interopRequireDefault2(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator2(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var BaseFontLoader = /* @__PURE__ */ function() {
              function BaseFontLoader2(_ref) {
                var docId = _ref.docId, onUnsupportedFeature = _ref.onUnsupportedFeature, _ref$ownerDocument = _ref.ownerDocument, ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;
                _classCallCheck2(this, BaseFontLoader2);
                if (this.constructor === BaseFontLoader2) {
                  (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                }
                this.docId = docId;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this._document = ownerDocument;
                this.nativeFontFaces = [];
                this.styleElement = null;
              }
              _createClass2(BaseFontLoader2, [{
                key: "addNativeFontFace",
                value: function addNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.push(nativeFontFace);
                  this._document.fonts.add(nativeFontFace);
                }
              }, {
                key: "insertRule",
                value: function insertRule(rule) {
                  var styleElement = this.styleElement;
                  if (!styleElement) {
                    styleElement = this.styleElement = this._document.createElement("style");
                    styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);
                    this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                  }
                  var styleSheet = styleElement.sheet;
                  styleSheet.insertRule(rule, styleSheet.cssRules.length);
                }
              }, {
                key: "clear",
                value: function clear() {
                  var _this = this;
                  this.nativeFontFaces.forEach(function(nativeFontFace) {
                    _this._document.fonts["delete"](nativeFontFace);
                  });
                  this.nativeFontFaces.length = 0;
                  if (this.styleElement) {
                    this.styleElement.remove();
                    this.styleElement = null;
                  }
                }
              }, {
                key: "bind",
                value: function() {
                  var _bind = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2(font) {
                    var _this2 = this;
                    var nativeFontFace, rule;
                    return _regenerator2["default"].wrap(function _callee$2(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!(font.attached || font.missingFile)) {
                              _context2.next = 2;
                              break;
                            }
                            return _context2.abrupt("return");
                          case 2:
                            font.attached = true;
                            if (!this.isFontLoadingAPISupported) {
                              _context2.next = 19;
                              break;
                            }
                            nativeFontFace = font.createNativeFontFace();
                            if (!nativeFontFace) {
                              _context2.next = 18;
                              break;
                            }
                            this.addNativeFontFace(nativeFontFace);
                            _context2.prev = 7;
                            _context2.next = 10;
                            return nativeFontFace.loaded;
                          case 10:
                            _context2.next = 18;
                            break;
                          case 12:
                            _context2.prev = 12;
                            _context2.t0 = _context2["catch"](7);
                            this._onUnsupportedFeature({
                              featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                            });
                            (0, _util2.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context2.t0, "'."));
                            font.disableFontFace = true;
                            throw _context2.t0;
                          case 18:
                            return _context2.abrupt("return");
                          case 19:
                            rule = font.createFontFaceRule();
                            if (!rule) {
                              _context2.next = 26;
                              break;
                            }
                            this.insertRule(rule);
                            if (!this.isSyncFontLoadingSupported) {
                              _context2.next = 24;
                              break;
                            }
                            return _context2.abrupt("return");
                          case 24:
                            _context2.next = 26;
                            return new Promise(function(resolve) {
                              var request = _this2._queueLoadingCallback(resolve);
                              _this2._prepareFontLoadEvent([rule], [font], request);
                            });
                          case 26:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this, [[7, 12]]);
                  }));
                  function bind(_x) {
                    return _bind.apply(this, arguments);
                  }
                  return bind;
                }()
              }, {
                key: "_queueLoadingCallback",
                value: function _queueLoadingCallback(callback) {
                  (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                }
              }, {
                key: "isFontLoadingAPISupported",
                get: function get() {
                  var _this$_document;
                  return (0, _util2.shadow)(this, "isFontLoadingAPISupported", !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts));
                }
              }, {
                key: "isSyncFontLoadingSupported",
                get: function get() {
                  (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                }
              }, {
                key: "_loadTestFont",
                get: function get() {
                  (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                }
              }, {
                key: "_prepareFontLoadEvent",
                value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {
                  (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                }
              }]);
              return BaseFontLoader2;
            }();
            var FontLoader;
            exports2.FontLoader = FontLoader;
            {
              exports2.FontLoader = FontLoader = /* @__PURE__ */ function(_BaseFontLoader) {
                _inherits(GenericFontLoader, _BaseFontLoader);
                var _super = _createSuper(GenericFontLoader);
                function GenericFontLoader(params) {
                  var _this3;
                  _classCallCheck2(this, GenericFontLoader);
                  _this3 = _super.call(this, params);
                  _this3.loadingContext = {
                    requests: [],
                    nextRequestId: 0
                  };
                  _this3.loadTestFontId = 0;
                  return _this3;
                }
                _createClass2(GenericFontLoader, [{
                  key: "isSyncFontLoadingSupported",
                  get: function get() {
                    var supported = false;
                    if (typeof navigator === "undefined") {
                      supported = true;
                    } else {
                      var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                      if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
                        supported = true;
                      }
                    }
                    return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                  }
                }, {
                  key: "_queueLoadingCallback",
                  value: function _queueLoadingCallback(callback) {
                    function completeRequest() {
                      (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                      request.done = true;
                      while (context.requests.length > 0 && context.requests[0].done) {
                        var otherRequest = context.requests.shift();
                        setTimeout(otherRequest.callback, 0);
                      }
                    }
                    var context = this.loadingContext;
                    var request = {
                      id: "pdfjs-font-loading-".concat(context.nextRequestId++),
                      done: false,
                      complete: completeRequest,
                      callback
                    };
                    context.requests.push(request);
                    return request;
                  }
                }, {
                  key: "_loadTestFont",
                  get: function get() {
                    var getLoadTestFont = function getLoadTestFont2() {
                      return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                    };
                    return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                  }
                }, {
                  key: "_prepareFontLoadEvent",
                  value: function _prepareFontLoadEvent(rules, fonts, request) {
                    var _this4 = this;
                    function int32(data2, offset) {
                      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                    }
                    function spliceString(s, offset, remove, insert) {
                      var chunk1 = s.substring(0, offset);
                      var chunk2 = s.substring(offset + remove);
                      return chunk1 + insert + chunk2;
                    }
                    var i, ii;
                    var canvas = this._document.createElement("canvas");
                    canvas.width = 1;
                    canvas.height = 1;
                    var ctx = canvas.getContext("2d");
                    var called = 0;
                    function isFontReady(name, callback) {
                      called++;
                      if (called > 30) {
                        (0, _util2.warn)("Load test font never loaded.");
                        callback();
                        return;
                      }
                      ctx.font = "30px " + name;
                      ctx.fillText(".", 0, 20);
                      var imageData = ctx.getImageData(0, 0, 1, 1);
                      if (imageData.data[3] > 0) {
                        callback();
                        return;
                      }
                      setTimeout(isFontReady.bind(null, name, callback));
                    }
                    var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
                    var data = this._loadTestFont;
                    var COMMENT_OFFSET = 976;
                    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                    var CFF_CHECKSUM_OFFSET = 16;
                    var XXXX_VALUE = 1482184792;
                    var checksum = int32(data, CFF_CHECKSUM_OFFSET);
                    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                    }
                    if (i < loadTestFontId.length) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                    }
                    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                    var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
                    var rule = '@font-face {font-family:"'.concat(loadTestFontId, '";src:').concat(url, "}");
                    this.insertRule(rule);
                    var names = [];
                    for (i = 0, ii = fonts.length; i < ii; i++) {
                      names.push(fonts[i].loadedName);
                    }
                    names.push(loadTestFontId);
                    var div = this._document.createElement("div");
                    div.style.visibility = "hidden";
                    div.style.width = div.style.height = "10px";
                    div.style.position = "absolute";
                    div.style.top = div.style.left = "0px";
                    for (i = 0, ii = names.length; i < ii; ++i) {
                      var span = this._document.createElement("span");
                      span.textContent = "Hi";
                      span.style.fontFamily = names[i];
                      div.appendChild(span);
                    }
                    this._document.body.appendChild(div);
                    isFontReady(loadTestFontId, function() {
                      _this4._document.body.removeChild(div);
                      request.complete();
                    });
                  }
                }]);
                return GenericFontLoader;
              }(BaseFontLoader);
            }
            var FontFaceObject = /* @__PURE__ */ function() {
              function FontFaceObject2(translatedData, _ref2) {
                var _ref2$isEvalSupported = _ref2.isEvalSupported, isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported, _ref2$disableFontFace = _ref2.disableFontFace, disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace, _ref2$ignoreErrors = _ref2.ignoreErrors, ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors, onUnsupportedFeature = _ref2.onUnsupportedFeature, _ref2$fontRegistry = _ref2.fontRegistry, fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry;
                _classCallCheck2(this, FontFaceObject2);
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                for (var i in translatedData) {
                  this[i] = translatedData[i];
                }
                this.isEvalSupported = isEvalSupported !== false;
                this.disableFontFace = disableFontFace === true;
                this.ignoreErrors = ignoreErrors === true;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this.fontRegistry = fontRegistry;
              }
              _createClass2(FontFaceObject2, [{
                key: "createNativeFontFace",
                value: function createNativeFontFace() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  var nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this);
                  }
                  return nativeFontFace;
                }
              }, {
                key: "createFontFaceRule",
                value: function createFontFaceRule() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  var data = (0, _util2.bytesToString)(new Uint8Array(this.data));
                  var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
                  var rule = '@font-face {font-family:"'.concat(this.loadedName, '";src:').concat(url, "}");
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this, url);
                  }
                  return rule;
                }
              }, {
                key: "getPathGenerator",
                value: function getPathGenerator(objs, character) {
                  if (this.compiledGlyphs[character] !== void 0) {
                    return this.compiledGlyphs[character];
                  }
                  var cmds, current;
                  try {
                    cmds = objs.get(this.loadedName + "_path_" + character);
                  } catch (ex) {
                    if (!this.ignoreErrors) {
                      throw ex;
                    }
                    this._onUnsupportedFeature({
                      featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                    });
                    (0, _util2.warn)('getPathGenerator - ignoring character: "'.concat(ex, '".'));
                    return this.compiledGlyphs[character] = function(c, size) {
                    };
                  }
                  if (this.isEvalSupported && _util2.IsEvalSupportedCached.value) {
                    var args, js = "";
                    for (var i = 0, ii = cmds.length; i < ii; i++) {
                      current = cmds[i];
                      if (current.args !== void 0) {
                        args = current.args.join(",");
                      } else {
                        args = "";
                      }
                      js += "c." + current.cmd + "(" + args + ");\n";
                    }
                    return this.compiledGlyphs[character] = new Function("c", "size", js);
                  }
                  return this.compiledGlyphs[character] = function(c, size) {
                    for (var _i = 0, _ii = cmds.length; _i < _ii; _i++) {
                      current = cmds[_i];
                      if (current.cmd === "scale") {
                        current.args = [size, -size];
                      }
                      c[current.cmd].apply(c, current.args);
                    }
                  };
                }
              }]);
              return FontFaceObject2;
            }();
            exports2.FontFaceObject = FontFaceObject;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.NodeCMapReaderFactory = exports2.NodeCanvasFactory = void 0;
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _is_node2 = __w_pdfjs_require__2(6);
            var _util2 = __w_pdfjs_require__2(4);
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var NodeCanvasFactory = function NodeCanvasFactory2() {
              _classCallCheck2(this, NodeCanvasFactory2);
              (0, _util2.unreachable)("Not implemented: NodeCanvasFactory");
            };
            exports2.NodeCanvasFactory = NodeCanvasFactory;
            var NodeCMapReaderFactory = function NodeCMapReaderFactory2() {
              _classCallCheck2(this, NodeCMapReaderFactory2);
              (0, _util2.unreachable)("Not implemented: NodeCMapReaderFactory");
            };
            exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
            if (_is_node2.isNodeJS) {
              exports2.NodeCanvasFactory = NodeCanvasFactory = /* @__PURE__ */ function(_BaseCanvasFactory) {
                _inherits(NodeCanvasFactory2, _BaseCanvasFactory);
                var _super = _createSuper(NodeCanvasFactory2);
                function NodeCanvasFactory2() {
                  _classCallCheck2(this, NodeCanvasFactory2);
                  return _super.apply(this, arguments);
                }
                _createClass2(NodeCanvasFactory2, [{
                  key: "create",
                  value: function create(width, height) {
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid canvas size");
                    }
                    var Canvas = require_canvas();
                    var canvas = Canvas.createCanvas(width, height);
                    return {
                      canvas,
                      context: canvas.getContext("2d")
                    };
                  }
                }]);
                return NodeCanvasFactory2;
              }(_display_utils2.BaseCanvasFactory);
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory = /* @__PURE__ */ function(_BaseCMapReaderFactor) {
                _inherits(NodeCMapReaderFactory2, _BaseCMapReaderFactor);
                var _super2 = _createSuper(NodeCMapReaderFactory2);
                function NodeCMapReaderFactory2() {
                  _classCallCheck2(this, NodeCMapReaderFactory2);
                  return _super2.apply(this, arguments);
                }
                _createClass2(NodeCMapReaderFactory2, [{
                  key: "_fetchData",
                  value: function _fetchData(url, compressionType) {
                    return new Promise(function(resolve, reject) {
                      var fs = require_fs();
                      fs.readFile(url, function(error, data) {
                        if (error || !data) {
                          reject(new Error(error));
                          return;
                        }
                        resolve({
                          cMapData: new Uint8Array(data),
                          compressionType
                        });
                      });
                    });
                  }
                }]);
                return NodeCMapReaderFactory2;
              }(_display_utils2.BaseCMapReaderFactory);
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationStorage = void 0;
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _util2 = __w_pdfjs_require__2(4);
            function _slicedToArray2(arr, i) {
              return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
            }
            function _nonIterableRest2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _iterableToArrayLimit2(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles2(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var AnnotationStorage = /* @__PURE__ */ function() {
              function AnnotationStorage2() {
                _classCallCheck2(this, AnnotationStorage2);
                this._storage = /* @__PURE__ */ new Map();
                this._modified = false;
                this.onSetModified = null;
                this.onResetModified = null;
              }
              _createClass2(AnnotationStorage2, [{
                key: "getValue",
                value: function getValue(key, defaultValue) {
                  var obj = this._storage.get(key);
                  return obj !== void 0 ? obj : defaultValue;
                }
              }, {
                key: "getOrCreateValue",
                value: function getOrCreateValue(key, defaultValue) {
                  (0, _display_utils2.deprecated)("Use getValue instead.");
                  if (this._storage.has(key)) {
                    return this._storage.get(key);
                  }
                  this._storage.set(key, defaultValue);
                  return defaultValue;
                }
              }, {
                key: "setValue",
                value: function setValue(key, value) {
                  var obj = this._storage.get(key);
                  var modified = false;
                  if (obj !== void 0) {
                    for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {
                      var _Object$entries$_i = _slicedToArray2(_Object$entries[_i], 2), entry = _Object$entries$_i[0], val = _Object$entries$_i[1];
                      if (obj[entry] !== val) {
                        modified = true;
                        obj[entry] = val;
                      }
                    }
                  } else {
                    this._storage.set(key, value);
                    modified = true;
                  }
                  if (modified) {
                    this._setModified();
                  }
                }
              }, {
                key: "getAll",
                value: function getAll() {
                  return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._storage.size;
                }
              }, {
                key: "_setModified",
                value: function _setModified() {
                  if (!this._modified) {
                    this._modified = true;
                    if (typeof this.onSetModified === "function") {
                      this.onSetModified();
                    }
                  }
                }
              }, {
                key: "resetModified",
                value: function resetModified() {
                  if (this._modified) {
                    this._modified = false;
                    if (typeof this.onResetModified === "function") {
                      this.onResetModified();
                    }
                  }
                }
              }, {
                key: "serializable",
                get: function get() {
                  return this._storage.size > 0 ? this._storage : null;
                }
              }]);
              return AnnotationStorage2;
            }();
            exports2.AnnotationStorage = AnnotationStorage;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.apiCompatibilityParams = void 0;
            var _is_node2 = __w_pdfjs_require__2(6);
            var compatibilityParams = /* @__PURE__ */ Object.create(null);
            {
              (function checkFontFace() {
                if (_is_node2.isNodeJS) {
                  compatibilityParams.disableFontFace = true;
                }
              })();
            }
            var apiCompatibilityParams = Object.freeze(compatibilityParams);
            exports2.apiCompatibilityParams = apiCompatibilityParams;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.CanvasGraphics = void 0;
            var _util2 = __w_pdfjs_require__2(4);
            var _pattern_helper = __w_pdfjs_require__2(131);
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            function _createForOfIteratorHelper2(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e) {
                    throw _e;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e2) {
                didErr = true;
                err = _e2;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var MIN_FONT_SIZE = 16;
            var MAX_FONT_SIZE = 100;
            var MAX_GROUP_SIZE = 4096;
            var COMPILE_TYPE3_GLYPHS = true;
            var MAX_SIZE_TO_COMPILE = 1e3;
            var FULL_CHUNK_HEIGHT = 16;
            var LINEWIDTH_SCALE_FACTOR = 1.000001;
            function addContextCurrentTransform(ctx) {
              if (!ctx.mozCurrentTransform) {
                ctx._originalSave = ctx.save;
                ctx._originalRestore = ctx.restore;
                ctx._originalRotate = ctx.rotate;
                ctx._originalScale = ctx.scale;
                ctx._originalTranslate = ctx.translate;
                ctx._originalTransform = ctx.transform;
                ctx._originalSetTransform = ctx.setTransform;
                ctx._originalResetTransform = ctx.resetTransform;
                ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                ctx._transformStack = [];
                try {
                  var desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
                  ctx._setLineWidth = desc.set;
                  ctx._getLineWidth = desc.get;
                  Object.defineProperty(ctx, "lineWidth", {
                    set: function setLineWidth(width) {
                      this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
                    },
                    get: function getLineWidth() {
                      return this._getLineWidth();
                    }
                  });
                } catch (_) {
                }
                Object.defineProperty(ctx, "mozCurrentTransform", {
                  get: function getCurrentTransform() {
                    return this._transformMatrix;
                  }
                });
                Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                  get: function getCurrentTransformInverse() {
                    var m = this._transformMatrix;
                    var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
                    var ad_bc = a * d - b * c;
                    var bc_ad = b * c - a * d;
                    return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                  }
                });
                ctx.save = function ctxSave() {
                  var old = this._transformMatrix;
                  this._transformStack.push(old);
                  this._transformMatrix = old.slice(0, 6);
                  this._originalSave();
                };
                ctx.restore = function ctxRestore() {
                  var prev = this._transformStack.pop();
                  if (prev) {
                    this._transformMatrix = prev;
                    this._originalRestore();
                  }
                };
                ctx.translate = function ctxTranslate(x, y) {
                  var m = this._transformMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                  this._originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  var m = this._transformMatrix;
                  m[0] = m[0] * x;
                  m[1] = m[1] * x;
                  m[2] = m[2] * y;
                  m[3] = m[3] * y;
                  this._originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                  ctx._originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  this._transformMatrix = [a, b, c, d, e, f];
                  ctx._originalSetTransform(a, b, c, d, e, f);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  this._transformMatrix = [1, 0, 0, 1, 0, 0];
                  ctx._originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle) {
                  var cosValue = Math.cos(angle);
                  var sinValue = Math.sin(angle);
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                  this._originalRotate(angle);
                };
              }
            }
            var CachedCanvases = function CachedCanvasesClosure() {
              function CachedCanvases2(canvasFactory) {
                this.canvasFactory = canvasFactory;
                this.cache = /* @__PURE__ */ Object.create(null);
              }
              CachedCanvases2.prototype = {
                getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                  var canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                    canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  if (trackTransform) {
                    addContextCurrentTransform(canvasEntry.context);
                  }
                  return canvasEntry;
                },
                clear: function clear() {
                  for (var id in this.cache) {
                    var canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              };
              return CachedCanvases2;
            }();
            function compileType3Glyph(imgData) {
              var POINT_TO_PROCESS_LIMIT = 1e3;
              var width = imgData.width, height = imgData.height, width1 = width + 1;
              var i, ii, j, j0;
              var points = new Uint8Array(width1 * (height + 1));
              var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
              var lineSize = width + 7 & ~7, data0 = imgData.data;
              var data = new Uint8Array(lineSize * height);
              var pos = 0;
              for (i = 0, ii = data0.length; i < ii; i++) {
                var elem = data0[i];
                var mask = 128;
                while (mask > 0) {
                  data[pos++] = elem & mask ? 0 : 255;
                  mask >>= 1;
                }
              }
              var count = 0;
              pos = 0;
              if (data[pos] !== 0) {
                points[0] = 1;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j] = data[pos] ? 2 : 1;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j] = 2;
                ++count;
              }
              for (i = 1; i < height; i++) {
                pos = i * lineSize;
                j0 = i * width1;
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0] = data[pos] ? 1 : 8;
                  ++count;
                }
                var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                for (j = 1; j < width; j++) {
                  sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                  if (POINT_TYPES[sum]) {
                    points[j0 + j] = POINT_TYPES[sum];
                    ++count;
                  }
                  pos++;
                }
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0 + j] = data[pos] ? 2 : 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
              }
              pos = lineSize * (height - 1);
              j0 = i * width1;
              if (data[pos] !== 0) {
                points[j0] = 8;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j0 + j] = data[pos] ? 4 : 8;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j0 + j] = 4;
                ++count;
              }
              if (count > POINT_TO_PROCESS_LIMIT) {
                return null;
              }
              var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
              var outlines = [];
              for (i = 0; count && i <= height; i++) {
                var p = i * width1;
                var end = p + width;
                while (p < end && !points[p]) {
                  p++;
                }
                if (p === end) {
                  continue;
                }
                var coords = [p % width1, i];
                var p0 = p;
                var type = points[p];
                do {
                  var step = steps[type];
                  do {
                    p += step;
                  } while (!points[p]);
                  var pp = points[p];
                  if (pp !== 5 && pp !== 10) {
                    type = pp;
                    points[p] = 0;
                  } else {
                    type = pp & 51 * type >> 4;
                    points[p] &= type >> 2 | type << 2;
                  }
                  coords.push(p % width1);
                  coords.push(p / width1 | 0);
                  if (!points[p]) {
                    --count;
                  }
                } while (p0 !== p);
                outlines.push(coords);
                --i;
              }
              var drawOutline = function drawOutline2(c) {
                c.save();
                c.scale(1 / width, -1 / height);
                c.translate(0, -height);
                c.beginPath();
                for (var k = 0, kk = outlines.length; k < kk; k++) {
                  var o = outlines[k];
                  c.moveTo(o[0], o[1]);
                  for (var l = 2, ll = o.length; l < ll; l += 2) {
                    c.lineTo(o[l], o[l + 1]);
                  }
                }
                c.fill();
                c.beginPath();
                c.restore();
              };
              return drawOutline;
            }
            var CanvasExtraState = function CanvasExtraStateClosure() {
              function CanvasExtraState2() {
                this.alphaIsShape = false;
                this.fontSize = 0;
                this.fontSizeScale = 1;
                this.textMatrix = _util2.IDENTITY_MATRIX;
                this.textMatrixScale = 1;
                this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRenderingMode = _util2.TextRenderingMode.FILL;
                this.textRise = 0;
                this.fillColor = "#000000";
                this.strokeColor = "#000000";
                this.patternFill = false;
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.activeSMask = null;
                this.resumeSMaskCtx = null;
                this.transferMaps = null;
              }
              CanvasExtraState2.prototype = {
                clone: function CanvasExtraState_clone() {
                  return Object.create(this);
                },
                setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              };
              return CanvasExtraState2;
            }();
            var CanvasGraphics = function CanvasGraphicsClosure() {
              var EXECUTION_TIME = 15;
              var EXECUTION_STEPS = 10;
              function CanvasGraphics2(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {
                this.ctx = canvasCtx;
                this.current = new CanvasExtraState();
                this.stateStack = [];
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.res = null;
                this.xobjs = null;
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.canvasFactory = canvasFactory;
                this.webGLContext = webGLContext;
                this.imageLayer = imageLayer;
                this.groupStack = [];
                this.processingType3 = null;
                this.baseTransform = null;
                this.baseTransformStack = [];
                this.groupLevel = 0;
                this.smaskStack = [];
                this.smaskCounter = 0;
                this.tempSMask = null;
                this.contentVisible = true;
                this.markedContentStack = [];
                this.optionalContentConfig = optionalContentConfig;
                this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                if (canvasCtx) {
                  addContextCurrentTransform(canvasCtx);
                }
                this._cachedGetSinglePixelWidth = null;
              }
              function putBinaryImageData(ctx, imgData) {
                var transferMaps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0, destPos;
                var src = imgData.data;
                var dest = chunkImgData.data;
                var i, j, thisChunkHeight, elemsInThisChunk;
                var transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                if (transferMaps) {
                  switch (transferMaps.length) {
                    case 1:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[0];
                      transferMapBlue = transferMaps[0];
                      transferMapGray = transferMaps[0];
                      break;
                    case 4:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[1];
                      transferMapBlue = transferMaps[2];
                      transferMapGray = transferMaps[3];
                      break;
                  }
                }
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  var srcLength = src.byteLength;
                  var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  var dest32DataLength = dest32.length;
                  var fullSrcDiff = width + 7 >> 3;
                  var white = 4294967295;
                  var black = _util2.IsLittleEndianCached.value ? 4278190080 : 255;
                  if (transferMapGray) {
                    if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                      var _ref = [black, white];
                      white = _ref[0];
                      black = _ref[1];
                    }
                  }
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      var srcDiff = srcLength - srcPos;
                      var k = 0;
                      var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      var kEndUnrolled = kEnd & ~7;
                      var mask = 0;
                      var srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  var hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    if (hasTransferMaps) {
                      for (var _k = 0; _k < elemsInThisChunk; _k += 4) {
                        if (transferMapRed) {
                          dest[_k + 0] = transferMapRed[dest[_k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[_k + 1] = transferMapGreen[dest[_k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[_k + 2] = transferMapBlue[dest[_k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    if (hasTransferMaps) {
                      for (var _k2 = 0; _k2 < elemsInThisChunk; _k2 += 4) {
                        if (transferMapRed) {
                          dest[_k2 + 0] = transferMapRed[dest[_k2 + 0]];
                        }
                        if (transferMapGreen) {
                          dest[_k2 + 1] = transferMapGreen[dest[_k2 + 1]];
                        }
                        if (transferMapBlue) {
                          dest[_k2 + 2] = transferMapBlue[dest[_k2 + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  var _hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    if (_hasTransferMaps) {
                      for (var _k3 = 0; _k3 < destPos; _k3 += 4) {
                        if (transferMapRed) {
                          dest[_k3 + 0] = transferMapRed[dest[_k3 + 0]];
                        }
                        if (transferMapGreen) {
                          dest[_k3 + 1] = transferMapGreen[dest[_k3 + 1]];
                        }
                        if (transferMapBlue) {
                          dest[_k3 + 2] = transferMapBlue[dest[_k3 + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error("bad image kind: ".concat(imgData.kind));
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0;
                var src = imgData.data;
                var dest = chunkImgData.data;
                for (var i = 0; i < totalChunks; i++) {
                  var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  var destPos = 3;
                  for (var j = 0; j < thisChunkHeight; j++) {
                    var elem = void 0, mask = 0;
                    for (var k = 0; k < width; k++) {
                      if (!mask) {
                        elem = src[srcPos++];
                        mask = 128;
                      }
                      dest[destPos] = elem & mask ? 0 : 255;
                      destPos += 4;
                      mask >>= 1;
                    }
                  }
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (var i = 0, ii = properties.length; i < ii; i++) {
                  var property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx) {
                ctx.strokeStyle = "#000000";
                ctx.fillStyle = "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                var length = bytes.length;
                for (var i = 3; i < length; i += 4) {
                  var alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    var alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                var length = maskData.length;
                var scale = 1 / 255;
                for (var i = 3; i < length; i += 4) {
                  var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                var length = maskData.length;
                for (var i = 3; i < length; i += 4) {
                  var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
                var hasBackdrop = !!backdrop;
                var r0 = hasBackdrop ? backdrop[0] : 0;
                var g0 = hasBackdrop ? backdrop[1] : 0;
                var b0 = hasBackdrop ? backdrop[2] : 0;
                var composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                var PIXELS_TO_PROCESS = 1048576;
                var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (var row = 0; row < height; row += chunkSize) {
                  var chunkHeight = Math.min(chunkSize, height - row);
                  var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                  var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  maskCtx.putImageData(layerData, 0, row);
                }
              }
              function composeSMask(ctx, smask, layerCtx, webGLContext) {
                var mask = smask.canvas;
                var maskCtx = smask.context;
                ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
                var backdrop = smask.backdrop || null;
                if (!smask.transferMap && webGLContext.isEnabled) {
                  var composed = webGLContext.composeSMask({
                    layer: layerCtx.canvas,
                    mask,
                    properties: {
                      subtype: smask.subtype,
                      backdrop
                    }
                  });
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                  return;
                }
                genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
                ctx.drawImage(mask, 0, 0);
              }
              var LINE_CAP_STYLES = ["butt", "round", "square"];
              var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              var NORMAL_CLIP = {};
              var EO_CLIP = {};
              CanvasGraphics2.prototype = {
                beginDrawing: function beginDrawing(_ref2) {
                  var transform = _ref2.transform, viewport = _ref2.viewport, _ref2$transparency = _ref2.transparency, transparency = _ref2$transparency === void 0 ? false : _ref2$transparency, _ref2$background = _ref2.background, background = _ref2$background === void 0 ? null : _ref2$background;
                  var width = this.ctx.canvas.width;
                  var height = this.ctx.canvas.height;
                  this.ctx.save();
                  this.ctx.fillStyle = background || "rgb(255, 255, 255)";
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.restore();
                  if (transparency) {
                    var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx);
                  if (transform) {
                    this.ctx.transform.apply(this.ctx, transform);
                  }
                  this.ctx.transform.apply(this.ctx, viewport.transform);
                  this.baseTransform = this.ctx.mozCurrentTransform.slice();
                  this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);
                  if (this.imageLayer) {
                    this.imageLayer.beginLayout();
                  }
                },
                executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  var argsArray = operatorList.argsArray;
                  var fnArray = operatorList.fnArray;
                  var i = executionStartIdx || 0;
                  var argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  var steps = 0;
                  var commonObjs = this.commonObjs;
                  var objs = this.objs;
                  var fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      var _iterator = _createForOfIteratorHelper2(argsArray[i]), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var depObjId = _step.value;
                          var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                          if (!objsPool.has(depObjId)) {
                            objsPool.get(depObjId, continueCallback);
                            return i;
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                },
                endDrawing: function CanvasGraphics_endDrawing() {
                  while (this.stateStack.length || this.current.activeSMask !== null) {
                    this.restore();
                  }
                  this.ctx.restore();
                  if (this.transparentCanvas) {
                    this.ctx = this.compositeCtx;
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.drawImage(this.transparentCanvas, 0, 0);
                    this.ctx.restore();
                    this.transparentCanvas = null;
                  }
                  this.cachedCanvases.clear();
                  this.webGLContext.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                },
                setLineWidth: function CanvasGraphics_setLineWidth(width) {
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                },
                setLineCap: function CanvasGraphics_setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                },
                setLineJoin: function CanvasGraphics_setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                },
                setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                },
                setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                  var ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                },
                setRenderingIntent: function setRenderingIntent(intent) {
                },
                setFlatness: function setFlatness(flatness) {
                },
                setGState: function CanvasGraphics_setGState(states) {
                  for (var i = 0, ii = states.length; i < ii; i++) {
                    var state = states[i];
                    var key = state[0];
                    var value = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        if (this.current.activeSMask) {
                          if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                            this.suspendSMaskGroup();
                          } else {
                            this.endSMaskGroup();
                          }
                        }
                        this.current.activeSMask = value ? this.tempSMask : null;
                        if (this.current.activeSMask) {
                          this.beginSMaskGroup();
                        }
                        this.tempSMask = null;
                        break;
                      case "TR":
                        this.current.transferMaps = value;
                    }
                  }
                },
                beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                  var activeSMask = this.current.activeSMask;
                  var drawnWidth = activeSMask.canvas.width;
                  var drawnHeight = activeSMask.canvas.height;
                  var cacheId = "smaskGroupAt" + this.groupLevel;
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var currentCtx = this.ctx;
                  var currentTransform = currentCtx.mozCurrentTransform;
                  this.ctx.save();
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                  groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  this.ctx.save();
                  copyCtxState(groupCtx, this.ctx);
                  this.current.resumeSMaskCtx = groupCtx;
                  var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                  groupCtx.save();
                  groupCtx.setTransform(1, 0, 0, 1, 0, 0);
                  groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
                  groupCtx.restore();
                },
                resumeSMaskGroup: function CanvasGraphics_resumeSMaskGroup() {
                  var groupCtx = this.current.resumeSMaskCtx;
                  var currentCtx = this.ctx;
                  this.ctx = groupCtx;
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  copyCtxState(groupCtx, this.ctx);
                  var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                },
                save: function CanvasGraphics_save() {
                  this.ctx.save();
                  var old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                  this.current.resumeSMaskCtx = null;
                },
                restore: function CanvasGraphics_restore() {
                  if (this.current.resumeSMaskCtx) {
                    this.resumeSMaskGroup();
                  }
                  if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                    this.endSMaskGroup();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    this.ctx.restore();
                    this.pendingClip = null;
                    this._cachedGetSinglePixelWidth = null;
                  } else {
                    this.current.activeSMask = null;
                  }
                },
                transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
                  this.ctx.transform(a, b, c, d, e, f);
                  this._cachedGetSinglePixelWidth = null;
                },
                constructPath: function CanvasGraphics_constructPath(ops, args) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var x = current.x, y = current.y;
                  for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        var width = args[j++];
                        var height = args[j++];
                        var xw = x + width;
                        var yh = y + height;
                        ctx.moveTo(x, y);
                        if (width === 0 || height === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x, yh);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        break;
                      case _util2.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  current.setCurrentPoint(x, y);
                },
                closePath: function CanvasGraphics_closePath() {
                  this.ctx.closePath();
                },
                stroke: function CanvasGraphics_stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (_typeof2(strokeColor) === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
                      ctx.save();
                      var transform = ctx.mozCurrentTransform;
                      var scale = _util2.Util.singularValueDecompose2dScale(transform)[0];
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                      var lineWidth = this.getSinglePixelWidth();
                      var scaledLineWidth = this.current.lineWidth * scale;
                      if (lineWidth < 0 && -lineWidth >= scaledLineWidth) {
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                      } else {
                        ctx.lineWidth = Math.max(lineWidth, scaledLineWidth);
                      }
                      ctx.stroke();
                      ctx.restore();
                    } else {
                      var _lineWidth = this.getSinglePixelWidth();
                      if (_lineWidth < 0 && -_lineWidth >= this.current.lineWidth) {
                        ctx.save();
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                        ctx.stroke();
                        ctx.restore();
                      } else {
                        ctx.lineWidth = Math.max(_lineWidth, this.current.lineWidth);
                        ctx.stroke();
                      }
                    }
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                },
                closeStroke: function CanvasGraphics_closeStroke() {
                  this.closePath();
                  this.stroke();
                },
                fill: function CanvasGraphics_fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    if (this.baseTransform) {
                      ctx.setTransform.apply(ctx, this.baseTransform);
                    }
                    ctx.fillStyle = fillColor.getPattern(ctx, this);
                    needRestore = true;
                  }
                  if (this.contentVisible) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                },
                eoFill: function CanvasGraphics_eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                },
                fillStroke: function CanvasGraphics_fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                },
                eoFillStroke: function CanvasGraphics_eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                },
                closeFillStroke: function CanvasGraphics_closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                },
                closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                },
                endPath: function CanvasGraphics_endPath() {
                  this.consumePath();
                },
                clip: function CanvasGraphics_clip() {
                  this.pendingClip = NORMAL_CLIP;
                },
                eoClip: function CanvasGraphics_eoClip() {
                  this.pendingClip = EO_CLIP;
                },
                beginText: function CanvasGraphics_beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                endText: function CanvasGraphics_endText() {
                  var paths = this.pendingTextPaths;
                  var ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (var i = 0; i < paths.length; i++) {
                    var path = paths[i];
                    ctx.setTransform.apply(ctx, path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                },
                setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                },
                setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                },
                setHScale: function CanvasGraphics_setHScale(scale) {
                  this.current.textHScale = scale / 100;
                },
                setLeading: function CanvasGraphics_setLeading(leading) {
                  this.current.leading = -leading;
                },
                setFont: function CanvasGraphics_setFont(fontRefName, size) {
                  var fontObj = this.commonObjs.get(fontRefName);
                  var current = this.current;
                  if (!fontObj) {
                    throw new Error("Can't find font for ".concat(fontRefName));
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  var name = fontObj.loadedName || "sans-serif";
                  var bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  var italic = fontObj.italic ? "italic" : "normal";
                  var typeface = '"'.concat(name, '", ').concat(fontObj.fallbackName);
                  var browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
                },
                setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                },
                setTextRise: function CanvasGraphics_setTextRise(rise) {
                  this.current.textRise = rise;
                },
                moveText: function CanvasGraphics_moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                },
                setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                },
                setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
                  this.current.textMatrix = [a, b, c, d, e, f];
                  this.current.textMatrixScale = Math.hypot(a, b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                nextLine: function CanvasGraphics_nextLine() {
                  this.moveText(0, this.current.leading);
                },
                paintChar: function paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var textRenderingMode = current.textRenderingMode;
                  var fontSize = current.fontSize / current.fontSizeScale;
                  var fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  var isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  var patternFill = current.patternFill && !font.missingFile;
                  var addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform.apply(ctx, patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (resetLineWidthToOne) {
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                      }
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (resetLineWidthToOne) {
                        ctx.save();
                        ctx.moveTo(x, y);
                        ctx.resetTransform();
                        ctx.lineWidth = Math.round(this._combinedScaleFactor);
                        ctx.strokeText(character, 0, 0);
                        ctx.restore();
                      } else {
                        ctx.strokeText(character, x, y);
                      }
                    }
                  }
                  if (isAddToPathSet) {
                    var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: ctx.mozCurrentTransform,
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                },
                get isFontSubpixelAAEnabled() {
                  var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10), ctx = _this$cachedCanvases$.context;
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  var data = ctx.getImageData(0, 0, 10, 10).data;
                  var enabled = false;
                  for (var i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                },
                showText: function CanvasGraphics_showText(glyphs) {
                  var current = this.current;
                  var font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  var fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  var ctx = this.ctx;
                  var fontSizeScale = current.fontSizeScale;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var fontDirection = current.fontDirection;
                  var textHScale = current.textHScale * fontDirection;
                  var glyphsLength = glyphs.length;
                  var vertical = font.vertical;
                  var spacingDir = vertical ? 1 : -1;
                  var defaultVMetrics = font.defaultVMetrics;
                  var widthAdvanceScale = fontSize * current.fontMatrix[0];
                  var simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  var patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    var pattern = current.fillColor.getPattern(ctx, this);
                    patternTransform = ctx.mozCurrentTransform;
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  var lineWidth = current.lineWidth;
                  var resetLineWidthToOne = false;
                  var scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      this._cachedGetSinglePixelWidth = null;
                      lineWidth = this.getSinglePixelWidth();
                      resetLineWidthToOne = lineWidth < 0;
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  var x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    var glyph = glyphs[i];
                    if ((0, _util2.isNum)(glyph)) {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    var restoreNeeded = false;
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var character = glyph.fontChar;
                    var accent = glyph.accent;
                    var scaledX = void 0, scaledY = void 0;
                    var width = glyph.width;
                    if (vertical) {
                      var vmetric = glyph.vmetric || defaultVMetrics;
                      var vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                      var vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      var measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        var characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);
                        if (accent) {
                          var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                          var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
                        }
                      }
                    }
                    var charWidth = void 0;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                },
                showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var fontSize = current.fontSize;
                  var fontDirection = current.fontDirection;
                  var spacingDir = font.vertical ? 1 : -1;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var textHScale = current.textHScale * fontDirection;
                  var fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  var glyphsLength = glyphs.length;
                  var isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  var i, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if ((0, _util2.isNum)(glyph)) {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)('Type3 character "'.concat(glyph.operatorListId, '" is not available.'));
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform.apply(ctx, fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    var transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                },
                setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
                },
                setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.clip();
                  this.endPath();
                },
                getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                  var _this = this;
                  var pattern;
                  if (IR[0] === "TilingPattern") {
                    var color = IR[1];
                    var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                    var canvasGraphicsFactory = {
                      createCanvasGraphics: function createCanvasGraphics(ctx) {
                        return new CanvasGraphics2(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
                  }
                  return pattern;
                },
                setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                },
                setFillColorN: function CanvasGraphics_setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                },
                setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
                  var color = _util2.Util.makeHexColor(r, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                },
                setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
                  var color = _util2.Util.makeHexColor(r, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                },
                shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                  if (!this.contentVisible) {
                    return;
                  }
                  var ctx = this.ctx;
                  this.save();
                  var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
                  ctx.fillStyle = pattern.getPattern(ctx, this, true);
                  var inv = ctx.mozCurrentTransformInverse;
                  if (inv) {
                    var canvas = ctx.canvas;
                    var width = canvas.width;
                    var height = canvas.height;
                    var bl = _util2.Util.applyTransform([0, 0], inv);
                    var br = _util2.Util.applyTransform([0, height], inv);
                    var ul = _util2.Util.applyTransform([width, 0], inv);
                    var ur = _util2.Util.applyTransform([width, height], inv);
                    var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.restore();
                },
                beginInlineImage: function CanvasGraphics_beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                },
                beginImageData: function CanvasGraphics_beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                },
                paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform.apply(this, matrix);
                  }
                  this.baseTransform = this.ctx.mozCurrentTransform;
                  if (bbox) {
                    var width = bbox[2] - bbox[0];
                    var height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                },
                paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                },
                beginGroup: function CanvasGraphics_beginGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  var currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  var currentTransform = currentCtx.mozCurrentTransform;
                  if (group.matrix) {
                    currentCtx.transform.apply(currentCtx, group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  var bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                  var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  var offsetX = Math.floor(bounds[0]);
                  var offsetY = Math.floor(bounds[1]);
                  var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  var scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  var cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                  this.current.activeSMask = null;
                },
                endGroup: function CanvasGraphics_endGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  var groupCtx = this.ctx;
                  this.ctx = this.groupStack.pop();
                  if (this.ctx.imageSmoothingEnabled !== void 0) {
                    this.ctx.imageSmoothingEnabled = false;
                  } else {
                    this.ctx.mozImageSmoothingEnabled = false;
                  }
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                  } else {
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                  }
                  this.restore();
                },
                beginAnnotations: function CanvasGraphics_beginAnnotations() {
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                  }
                },
                endAnnotations: function CanvasGraphics_endAnnotations() {
                  this.restore();
                },
                beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                  this.save();
                  resetCtxToDefault(this.ctx);
                  this.current = new CanvasExtraState();
                  if (Array.isArray(rect) && rect.length === 4) {
                    var width = rect[2] - rect[0];
                    var height = rect[3] - rect[1];
                    this.ctx.rect(rect[0], rect[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                  this.transform.apply(this, transform);
                  this.transform.apply(this, matrix);
                },
                endAnnotation: function CanvasGraphics_endAnnotation() {
                  this.restore();
                },
                paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  var ctx = this.ctx;
                  var width = img.width, height = img.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var glyph = this.processingType3;
                  if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === void 0) {
                    if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                      glyph.compiled = compileType3Glyph({
                        data: img.data,
                        width,
                        height
                      });
                    } else {
                      glyph.compiled = null;
                    }
                  }
                  if (glyph !== null && glyph !== void 0 && glyph.compiled) {
                    glyph.compiled(ctx);
                    return;
                  }
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, img);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  this.paintInlineImageXObject(maskCanvas.canvas);
                },
                paintImageMaskXObjectRepeat: function paintImageMaskXObjectRepeat(imgData, scaleX) {
                  var skewX = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                  var skewY = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                  var scaleY = arguments.length > 4 ? arguments[4] : void 0;
                  var positions = arguments.length > 5 ? arguments[5] : void 0;
                  if (!this.contentVisible) {
                    return;
                  }
                  var width = imgData.width;
                  var height = imgData.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, imgData);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  var ctx = this.ctx;
                  for (var i = 0, ii = positions.length; i < ii; i += 2) {
                    ctx.save();
                    ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  for (var i = 0, ii = images.length; i < ii; i++) {
                    var image = images[i];
                    var width = image.width, height = image.height;
                    var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    var maskCtx = maskCanvas.context;
                    maskCtx.save();
                    putBinaryImageMask(maskCtx, image);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform.apply(ctx, image.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                },
                paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  var width = imgData.width;
                  var height = imgData.height;
                  var map = [];
                  for (var i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                },
                paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  var width = imgData.width;
                  var height = imgData.height;
                  var ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width, -1 / height);
                  var currentTransform = ctx.mozCurrentTransformInverse;
                  var widthScale = Math.max(Math.hypot(currentTransform[0], currentTransform[1]), 1);
                  var heightScale = Math.max(Math.hypot(currentTransform[2], currentTransform[3]), 1);
                  var imgToPaint, tmpCanvas, tmpCtx;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  var paintWidth = width, paintHeight = height;
                  var tmpCanvasId = "prescale1";
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    var newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    imgToPaint = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
                  if (this.imageLayer) {
                    var position = this.getCanvasPosition(0, -height);
                    this.imageLayer.appendImage({
                      imgData,
                      left: position[0],
                      top: position[1],
                      width: width / currentTransform[0],
                      height: height / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  var ctx = this.ctx;
                  var w = imgData.width;
                  var h = imgData.height;
                  var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  var tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                  for (var i = 0, ii = map.length; i < ii; i++) {
                    var entry = map[i];
                    ctx.save();
                    ctx.transform.apply(ctx, entry.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      var position = this.getCanvasPosition(entry.x, entry.y);
                      this.imageLayer.appendImage({
                        imgData,
                        left: position[0],
                        top: position[1],
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                },
                paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                },
                markPoint: function CanvasGraphics_markPoint(tag) {
                },
                markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
                },
                beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
                  this.markedContentStack.push({
                    visible: true
                  });
                },
                beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
                  if (tag === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                },
                endMarkedContent: function CanvasGraphics_endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                },
                beginCompat: function CanvasGraphics_beginCompat() {
                },
                endCompat: function CanvasGraphics_endCompat() {
                },
                consumePath: function CanvasGraphics_consumePath() {
                  var ctx = this.ctx;
                  if (this.pendingClip) {
                    if (this.pendingClip === EO_CLIP) {
                      ctx.clip("evenodd");
                    } else {
                      ctx.clip();
                    }
                    this.pendingClip = null;
                  }
                  ctx.beginPath();
                },
                getSinglePixelWidth: function getSinglePixelWidth() {
                  if (this._cachedGetSinglePixelWidth === null) {
                    var m = this.ctx.mozCurrentTransform;
                    var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                    var sqNorm1 = Math.pow(m[0], 2) + Math.pow(m[2], 2);
                    var sqNorm2 = Math.pow(m[1], 2) + Math.pow(m[3], 2);
                    var pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;
                    if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
                      this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
                    } else if (absDet > Number.EPSILON) {
                      this._cachedGetSinglePixelWidth = pixelHeight;
                    } else {
                      this._cachedGetSinglePixelWidth = 1;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                },
                getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
                  var transform = this.ctx.mozCurrentTransform;
                  return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                },
                isContentVisible: function CanvasGraphics_isContentVisible() {
                  for (var i = this.markedContentStack.length - 1; i >= 0; i--) {
                    if (!this.markedContentStack[i].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              for (var op in _util2.OPS) {
                CanvasGraphics2.prototype[_util2.OPS[op]] = CanvasGraphics2.prototype[op];
              }
              return CanvasGraphics2;
            }();
            exports2.CanvasGraphics = CanvasGraphics;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getShadingPatternFromIR = getShadingPatternFromIR;
            exports2.TilingPattern = void 0;
            var _util2 = __w_pdfjs_require__2(4);
            var ShadingIRs = {};
            function applyBoundingBox(ctx, bbox) {
              if (!bbox || typeof Path2D === "undefined") {
                return;
              }
              var width = bbox[2] - bbox[0];
              var height = bbox[3] - bbox[1];
              var region = new Path2D();
              region.rect(bbox[0], bbox[1], width, height);
              ctx.clip(region);
            }
            ShadingIRs.RadialAxial = {
              fromIR: function RadialAxial_fromIR(raw) {
                var type = raw[1];
                var bbox = raw[2];
                var colorStops = raw[3];
                var p0 = raw[4];
                var p1 = raw[5];
                var r0 = raw[6];
                var r1 = raw[7];
                return {
                  getPattern: function RadialAxial_getPattern(ctx) {
                    applyBoundingBox(ctx, bbox);
                    var grad;
                    if (type === "axial") {
                      grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                    } else if (type === "radial") {
                      grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                    }
                    for (var i = 0, ii = colorStops.length; i < ii; ++i) {
                      var c = colorStops[i];
                      grad.addColorStop(c[0], c[1]);
                    }
                    return grad;
                  }
                };
              }
            };
            var createMeshCanvas = function createMeshCanvasClosure() {
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                var coords = context.coords, colors = context.colors;
                var bytes = data.data, rowSize = data.width * 4;
                var tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                var x1 = (coords[p1] + context.offsetX) * context.scaleX;
                var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                var x2 = (coords[p2] + context.offsetX) * context.scaleX;
                var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                var x3 = (coords[p3] + context.offsetX) * context.scaleX;
                var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                var minY = Math.round(y1), maxY = Math.round(y3);
                var xa, car, cag, cab;
                var xb, cbr, cbg, cbb;
                for (var y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    var _k = void 0;
                    if (y < y1) {
                      _k = 0;
                    } else if (y1 === y2) {
                      _k = 1;
                    } else {
                      _k = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * _k;
                    car = c1r - (c1r - c2r) * _k;
                    cag = c1g - (c1g - c2g) * _k;
                    cab = c1b - (c1b - c2b) * _k;
                  } else {
                    var _k2 = void 0;
                    if (y > y3) {
                      _k2 = 1;
                    } else if (y2 === y3) {
                      _k2 = 0;
                    } else {
                      _k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * _k2;
                    car = c2r - (c2r - c3r) * _k2;
                    cag = c2g - (c2g - c3g) * _k2;
                    cab = c2b - (c2b - c3b) * _k2;
                  }
                  var k = void 0;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  var x1_ = Math.round(Math.min(xa, xb));
                  var x2_ = Math.round(Math.max(xa, xb));
                  var j = rowSize * y + x1_ * 4;
                  for (var x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                var ps = figure.coords;
                var cs = figure.colors;
                var i, ii;
                switch (figure.type) {
                  case "lattice":
                    var verticesPerRow = figure.verticesPerRow;
                    var rows = Math.floor(ps.length / verticesPerRow) - 1;
                    var cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      var q = i * verticesPerRow;
                      for (var j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              function createMeshCanvas2(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
                var EXPECTED_SCALE = 1.1;
                var MAX_PATTERN_SIZE = 3e3;
                var BORDER_SIZE = 2;
                var offsetX = Math.floor(bounds[0]);
                var offsetY = Math.floor(bounds[1]);
                var boundsWidth = Math.ceil(bounds[2]) - offsetX;
                var boundsHeight = Math.ceil(bounds[3]) - offsetY;
                var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var scaleX = boundsWidth / width;
                var scaleY = boundsHeight / height;
                var context = {
                  coords,
                  colors,
                  offsetX: -offsetX,
                  offsetY: -offsetY,
                  scaleX: 1 / scaleX,
                  scaleY: 1 / scaleY
                };
                var paddedWidth = width + BORDER_SIZE * 2;
                var paddedHeight = height + BORDER_SIZE * 2;
                var canvas, tmpCanvas, i, ii;
                if (webGLContext.isEnabled) {
                  canvas = webGLContext.drawFigures({
                    width,
                    height,
                    backgroundColor,
                    figures,
                    context
                  });
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                } else {
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  var tmpCtx = tmpCanvas.context;
                  var data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    var bytes = data.data;
                    for (i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (i = 0; i < figures.length; i++) {
                    drawFigure(data, figures[i], context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                }
                return {
                  canvas,
                  offsetX: offsetX - BORDER_SIZE * scaleX,
                  offsetY: offsetY - BORDER_SIZE * scaleY,
                  scaleX,
                  scaleY
                };
              }
              return createMeshCanvas2;
            }();
            ShadingIRs.Mesh = {
              fromIR: function Mesh_fromIR(raw) {
                var coords = raw[2];
                var colors = raw[3];
                var figures = raw[4];
                var bounds = raw[5];
                var matrix = raw[6];
                var bbox = raw[7];
                var background = raw[8];
                return {
                  getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                    applyBoundingBox(ctx, bbox);
                    var scale;
                    if (shadingFill) {
                      scale = _util2.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (matrix) {
                        var matrixScale = _util2.Util.singularValueDecompose2dScale(matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);
                    if (!shadingFill) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (matrix) {
                        ctx.transform.apply(ctx, matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  }
                };
              }
            };
            ShadingIRs.Dummy = {
              fromIR: function Dummy_fromIR() {
                return {
                  getPattern: function Dummy_fromIR_getPattern() {
                    return "hotpink";
                  }
                };
              }
            };
            function getShadingPatternFromIR(raw) {
              var shadingIR = ShadingIRs[raw[0]];
              if (!shadingIR) {
                throw new Error("Unknown IR type: ".concat(raw[0]));
              }
              return shadingIR.fromIR(raw);
            }
            var TilingPattern = function TilingPatternClosure() {
              var PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              var MAX_PATTERN_SIZE = 3e3;
              function TilingPattern2(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                this.operatorList = IR[2];
                this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                this.bbox = IR[4];
                this.xstep = IR[5];
                this.ystep = IR[6];
                this.paintType = IR[7];
                this.tilingType = IR[8];
                this.color = color;
                this.canvasGraphicsFactory = canvasGraphicsFactory;
                this.baseTransform = baseTransform;
                this.ctx = ctx;
              }
              TilingPattern2.prototype = {
                createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                  var operatorList = this.operatorList;
                  var bbox = this.bbox;
                  var xstep = this.xstep;
                  var ystep = this.ystep;
                  var paintType = this.paintType;
                  var tilingType = this.tilingType;
                  var color = this.color;
                  var canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  var matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  var curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  var tmpCtx = tmpCanvas.context;
                  var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  graphics.transform(1, 0, 0, 1, -x0, -y0);
                  this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                  graphics.executeOperatorList(operatorList);
                  this.ctx.transform(1, 0, 0, 1, x0, y0);
                  this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
                  return tmpCanvas.canvas;
                },
                getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
                  step = Math.abs(step);
                  var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
                  var size = Math.ceil(step * scale);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale = size / step;
                  }
                  return {
                    scale,
                    size
                  };
                },
                clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    var bboxWidth = x1 - x0;
                    var bboxHeight = y1 - y0;
                    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                    graphics.clip();
                    graphics.endPath();
                  }
                },
                setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  var context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      var ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      var cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError("Unsupported paint type: ".concat(paintType));
                  }
                },
                getPattern: function TilingPattern_getPattern(ctx, owner) {
                  ctx = this.ctx;
                  ctx.setTransform.apply(ctx, this.baseTransform);
                  ctx.transform.apply(ctx, this.matrix);
                  var temporaryPatternCanvas = this.createPatternCanvas(owner);
                  return ctx.createPattern(temporaryPatternCanvas, "repeat");
                }
              };
              return TilingPattern2;
            }();
            exports2.TilingPattern = TilingPattern;
          },
          (__unused_webpack_module2, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.GlobalWorkerOptions = void 0;
            var GlobalWorkerOptions2 = /* @__PURE__ */ Object.create(null);
            exports2.GlobalWorkerOptions = GlobalWorkerOptions2;
            GlobalWorkerOptions2.workerPort = GlobalWorkerOptions2.workerPort === void 0 ? null : GlobalWorkerOptions2.workerPort;
            GlobalWorkerOptions2.workerSrc = GlobalWorkerOptions2.workerSrc === void 0 ? "" : GlobalWorkerOptions2.workerSrc;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.MessageHandler = void 0;
            var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(2));
            var _util2 = __w_pdfjs_require__2(4);
            function _interopRequireDefault2(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator2(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            var CallbackKind = {
              UNKNOWN: 0,
              DATA: 1,
              ERROR: 2
            };
            var StreamKind = {
              UNKNOWN: 0,
              CANCEL: 1,
              CANCEL_COMPLETE: 2,
              CLOSE: 3,
              ENQUEUE: 4,
              ERROR: 5,
              PULL: 6,
              PULL_COMPLETE: 7,
              START_COMPLETE: 8
            };
            function wrapReason(reason) {
              if (_typeof2(reason) !== "object" || reason === null) {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util2.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util2.MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new _util2.UnexpectedResponseException(reason.message, reason.status);
                case "UnknownErrorException":
                  return new _util2.UnknownErrorException(reason.message, reason.details);
                default:
                  return new _util2.UnknownErrorException(reason.message, reason.toString());
              }
            }
            var MessageHandler = /* @__PURE__ */ function() {
              function MessageHandler2(sourceName, targetName, comObj) {
                var _this = this;
                _classCallCheck2(this, MessageHandler2);
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackId = 1;
                this.streamId = 1;
                this.postMessageTransfers = true;
                this.streamSinks = /* @__PURE__ */ Object.create(null);
                this.streamControllers = /* @__PURE__ */ Object.create(null);
                this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                this.actionHandler = /* @__PURE__ */ Object.create(null);
                this._onComObjOnMessage = function(event) {
                  var data = event.data;
                  if (data.targetName !== _this.sourceName) {
                    return;
                  }
                  if (data.stream) {
                    _this._processStreamMessage(data);
                    return;
                  }
                  if (data.callback) {
                    var callbackId = data.callbackId;
                    var capability = _this.callbackCapabilities[callbackId];
                    if (!capability) {
                      throw new Error("Cannot resolve callback ".concat(callbackId));
                    }
                    delete _this.callbackCapabilities[callbackId];
                    if (data.callback === CallbackKind.DATA) {
                      capability.resolve(data.data);
                    } else if (data.callback === CallbackKind.ERROR) {
                      capability.reject(wrapReason(data.reason));
                    } else {
                      throw new Error("Unexpected callback case");
                    }
                    return;
                  }
                  var action = _this.actionHandler[data.action];
                  if (!action) {
                    throw new Error("Unknown action from worker: ".concat(data.action));
                  }
                  if (data.callbackId) {
                    var cbSourceName = _this.sourceName;
                    var cbTargetName = data.sourceName;
                    new Promise(function(resolve) {
                      resolve(action(data.data));
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: cbSourceName,
                        targetName: cbTargetName,
                        callback: CallbackKind.DATA,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: cbSourceName,
                        targetName: cbTargetName,
                        callback: CallbackKind.ERROR,
                        callbackId: data.callbackId,
                        reason: wrapReason(reason)
                      });
                    });
                    return;
                  }
                  if (data.streamId) {
                    _this._createStreamSink(data);
                    return;
                  }
                  action(data.data);
                };
                comObj.addEventListener("message", this._onComObjOnMessage);
              }
              _createClass2(MessageHandler2, [{
                key: "on",
                value: function on(actionName, handler) {
                  var ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error('There is already an actionName called "'.concat(actionName, '"'));
                  }
                  ah[actionName] = handler;
                }
              }, {
                key: "send",
                value: function send(actionName, data, transfers) {
                  this._postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
              }, {
                key: "sendWithPromise",
                value: function sendWithPromise(actionName, data, transfers) {
                  var callbackId = this.callbackId++;
                  var capability = (0, _util2.createPromiseCapability)();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this._postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
              }, {
                key: "sendWithStream",
                value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                  var _this2 = this;
                  var streamId = this.streamId++;
                  var sourceName = this.sourceName;
                  var targetName = this.targetName;
                  var comObj = this.comObj;
                  return new ReadableStream({
                    start: function start(controller) {
                      var startCapability = (0, _util2.createPromiseCapability)();
                      _this2.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      _this2._postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: function pull(controller) {
                      var pullCapability = (0, _util2.createPromiseCapability)();
                      _this2.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: function cancel(reason) {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      var cancelCapability = (0, _util2.createPromiseCapability)();
                      _this2.streamControllers[streamId].cancelCall = cancelCapability;
                      _this2.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
              }, {
                key: "_createStreamSink",
                value: function _createStreamSink(data) {
                  var self2 = this;
                  var action = this.actionHandler[data.action];
                  var streamId = data.streamId;
                  var sourceName = this.sourceName;
                  var targetName = data.sourceName;
                  var comObj = this.comObj;
                  var streamSink = {
                    enqueue: function enqueue(chunk) {
                      var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                      var transfers = arguments.length > 2 ? arguments[2] : void 0;
                      if (this.isCancelled) {
                        return;
                      }
                      var lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util2.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      self2._postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ENQUEUE,
                        streamId,
                        chunk
                      }, transfers);
                    },
                    close: function close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CLOSE,
                        streamId
                      });
                      delete self2.streamSinks[streamId];
                    },
                    error: function error(reason) {
                      (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ERROR,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    },
                    sinkCapability: (0, _util2.createPromiseCapability)(),
                    onPull: null,
                    onCancel: null,
                    isCancelled: false,
                    desiredSize: data.desiredSize,
                    ready: null
                  };
                  streamSink.sinkCapability.resolve();
                  streamSink.ready = streamSink.sinkCapability.promise;
                  this.streamSinks[streamId] = streamSink;
                  new Promise(function(resolve) {
                    resolve(action(data.data, streamSink));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                }
              }, {
                key: "_processStreamMessage",
                value: function _processStreamMessage(data) {
                  var streamId = data.streamId;
                  var sourceName = this.sourceName;
                  var targetName = data.sourceName;
                  var comObj = this.comObj;
                  switch (data.stream) {
                    case StreamKind.START_COMPLETE:
                      if (data.success) {
                        this.streamControllers[streamId].startCall.resolve();
                      } else {
                        this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL_COMPLETE:
                      if (data.success) {
                        this.streamControllers[streamId].pullCall.resolve();
                      } else {
                        this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL:
                      if (!this.streamSinks[streamId]) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                        break;
                      }
                      if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                        this.streamSinks[streamId].sinkCapability.resolve();
                      }
                      this.streamSinks[streamId].desiredSize = data.desiredSize;
                      var onPull = this.streamSinks[data.streamId].onPull;
                      new Promise(function(resolve) {
                        resolve(onPull && onPull());
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      break;
                    case StreamKind.ENQUEUE:
                      (0, _util2.assert)(this.streamControllers[streamId], "enqueue should have stream controller");
                      if (this.streamControllers[streamId].isClosed) {
                        break;
                      }
                      this.streamControllers[streamId].controller.enqueue(data.chunk);
                      break;
                    case StreamKind.CLOSE:
                      (0, _util2.assert)(this.streamControllers[streamId], "close should have stream controller");
                      if (this.streamControllers[streamId].isClosed) {
                        break;
                      }
                      this.streamControllers[streamId].isClosed = true;
                      this.streamControllers[streamId].controller.close();
                      this._deleteStreamController(streamId);
                      break;
                    case StreamKind.ERROR:
                      (0, _util2.assert)(this.streamControllers[streamId], "error should have stream controller");
                      this.streamControllers[streamId].controller.error(wrapReason(data.reason));
                      this._deleteStreamController(streamId);
                      break;
                    case StreamKind.CANCEL_COMPLETE:
                      if (data.success) {
                        this.streamControllers[streamId].cancelCall.resolve();
                      } else {
                        this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                      }
                      this._deleteStreamController(streamId);
                      break;
                    case StreamKind.CANCEL:
                      if (!this.streamSinks[streamId]) {
                        break;
                      }
                      var onCancel = this.streamSinks[data.streamId].onCancel;
                      new Promise(function(resolve) {
                        resolve(onCancel && onCancel(wrapReason(data.reason)));
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                      this.streamSinks[streamId].isCancelled = true;
                      delete this.streamSinks[streamId];
                      break;
                    default:
                      throw new Error("Unexpected stream case");
                  }
                }
              }, {
                key: "_deleteStreamController",
                value: function() {
                  var _deleteStreamController2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2(streamId) {
                    return _regenerator2["default"].wrap(function _callee$2(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
                              return capability && capability.promise;
                            }));
                          case 2:
                            delete this.streamControllers[streamId];
                          case 3:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function _deleteStreamController(_x) {
                    return _deleteStreamController2.apply(this, arguments);
                  }
                  return _deleteStreamController;
                }()
              }, {
                key: "_postMessage",
                value: function _postMessage(message, transfers) {
                  if (transfers && this.postMessageTransfers) {
                    this.comObj.postMessage(message, transfers);
                  } else {
                    this.comObj.postMessage(message);
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }]);
              return MessageHandler2;
            }();
            exports2.MessageHandler = MessageHandler;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Metadata = void 0;
            var _util2 = __w_pdfjs_require__2(4);
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var Metadata = /* @__PURE__ */ function() {
              function Metadata2(_ref) {
                var parsedData = _ref.parsedData, rawData = _ref.rawData;
                _classCallCheck2(this, Metadata2);
                this._metadataMap = parsedData;
                this._data = rawData;
              }
              _createClass2(Metadata2, [{
                key: "getRaw",
                value: function getRaw() {
                  return this._data;
                }
              }, {
                key: "get",
                value: function get(name) {
                  var _this$_metadataMap$ge;
                  return (_this$_metadataMap$ge = this._metadataMap.get(name)) !== null && _this$_metadataMap$ge !== void 0 ? _this$_metadataMap$ge : null;
                }
              }, {
                key: "getAll",
                value: function getAll() {
                  return (0, _util2.objectFromMap)(this._metadataMap);
                }
              }, {
                key: "has",
                value: function has(name) {
                  return this._metadataMap.has(name);
                }
              }]);
              return Metadata2;
            }();
            exports2.Metadata = Metadata;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.OptionalContentConfig = void 0;
            var _util2 = __w_pdfjs_require__2(4);
            function _createForOfIteratorHelper2(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e) {
                    throw _e;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e2) {
                didErr = true;
                err = _e2;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var OptionalContentGroup = function OptionalContentGroup2(name, intent) {
              _classCallCheck2(this, OptionalContentGroup2);
              this.visible = true;
              this.name = name;
              this.intent = intent;
            };
            var OptionalContentConfig = /* @__PURE__ */ function() {
              function OptionalContentConfig2(data) {
                _classCallCheck2(this, OptionalContentConfig2);
                this.name = null;
                this.creator = null;
                this._order = null;
                this._groups = /* @__PURE__ */ new Map();
                if (data === null) {
                  return;
                }
                this.name = data.name;
                this.creator = data.creator;
                this._order = data.order;
                var _iterator = _createForOfIteratorHelper2(data.groups), _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var _group = _step.value;
                    this._groups.set(_group.id, new OptionalContentGroup(_group.name, _group.intent));
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                if (data.baseState === "OFF") {
                  var _iterator2 = _createForOfIteratorHelper2(this._groups), _step2;
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var group = _step2.value;
                      group.visible = false;
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                }
                var _iterator3 = _createForOfIteratorHelper2(data.on), _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                    var on = _step3.value;
                    this._groups.get(on).visible = true;
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
                var _iterator4 = _createForOfIteratorHelper2(data.off), _step4;
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                    var off = _step4.value;
                    this._groups.get(off).visible = false;
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
              _createClass2(OptionalContentConfig2, [{
                key: "isVisible",
                value: function isVisible(group) {
                  if (group.type === "OCG") {
                    if (!this._groups.has(group.id)) {
                      (0, _util2.warn)("Optional content group not found: ".concat(group.id));
                      return true;
                    }
                    return this._groups.get(group.id).visible;
                  } else if (group.type === "OCMD") {
                    if (group.expression) {
                      (0, _util2.warn)("Visibility expression not supported yet.");
                    }
                    if (!group.policy || group.policy === "AnyOn") {
                      var _iterator5 = _createForOfIteratorHelper2(group.ids), _step5;
                      try {
                        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                          var id = _step5.value;
                          if (!this._groups.has(id)) {
                            (0, _util2.warn)("Optional content group not found: ".concat(id));
                            return true;
                          }
                          if (this._groups.get(id).visible) {
                            return true;
                          }
                        }
                      } catch (err) {
                        _iterator5.e(err);
                      } finally {
                        _iterator5.f();
                      }
                      return false;
                    } else if (group.policy === "AllOn") {
                      var _iterator6 = _createForOfIteratorHelper2(group.ids), _step6;
                      try {
                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                          var _id = _step6.value;
                          if (!this._groups.has(_id)) {
                            (0, _util2.warn)("Optional content group not found: ".concat(_id));
                            return true;
                          }
                          if (!this._groups.get(_id).visible) {
                            return false;
                          }
                        }
                      } catch (err) {
                        _iterator6.e(err);
                      } finally {
                        _iterator6.f();
                      }
                      return true;
                    } else if (group.policy === "AnyOff") {
                      var _iterator7 = _createForOfIteratorHelper2(group.ids), _step7;
                      try {
                        for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                          var _id2 = _step7.value;
                          if (!this._groups.has(_id2)) {
                            (0, _util2.warn)("Optional content group not found: ".concat(_id2));
                            return true;
                          }
                          if (!this._groups.get(_id2).visible) {
                            return true;
                          }
                        }
                      } catch (err) {
                        _iterator7.e(err);
                      } finally {
                        _iterator7.f();
                      }
                      return false;
                    } else if (group.policy === "AllOff") {
                      var _iterator8 = _createForOfIteratorHelper2(group.ids), _step8;
                      try {
                        for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                          var _id3 = _step8.value;
                          if (!this._groups.has(_id3)) {
                            (0, _util2.warn)("Optional content group not found: ".concat(_id3));
                            return true;
                          }
                          if (this._groups.get(_id3).visible) {
                            return false;
                          }
                        }
                      } catch (err) {
                        _iterator8.e(err);
                      } finally {
                        _iterator8.f();
                      }
                      return true;
                    }
                    (0, _util2.warn)("Unknown optional content policy ".concat(group.policy, "."));
                    return true;
                  }
                  (0, _util2.warn)("Unknown group type ".concat(group.type, "."));
                  return true;
                }
              }, {
                key: "setVisibility",
                value: function setVisibility(id) {
                  var visible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (!this._groups.has(id)) {
                    (0, _util2.warn)("Optional content group not found: ".concat(id));
                    return;
                  }
                  this._groups.get(id).visible = !!visible;
                }
              }, {
                key: "getOrder",
                value: function getOrder() {
                  if (!this._groups.size) {
                    return null;
                  }
                  if (this._order) {
                    return this._order.slice();
                  }
                  return Array.from(this._groups.keys());
                }
              }, {
                key: "getGroups",
                value: function getGroups() {
                  return this._groups.size > 0 ? (0, _util2.objectFromMap)(this._groups) : null;
                }
              }, {
                key: "getGroup",
                value: function getGroup(id) {
                  return this._groups.get(id) || null;
                }
              }]);
              return OptionalContentConfig2;
            }();
            exports2.OptionalContentConfig = OptionalContentConfig;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFDataTransportStream = void 0;
            var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(2));
            var _util2 = __w_pdfjs_require__2(4);
            var _display_utils2 = __w_pdfjs_require__2(1);
            function _interopRequireDefault2(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator2(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _createForOfIteratorHelper2(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e) {
                    throw _e;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e2) {
                didErr = true;
                err = _e2;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var PDFDataTransportStream = /* @__PURE__ */ function() {
              function PDFDataTransportStream2(params, pdfDataRangeTransport) {
                var _this = this;
                _classCallCheck2(this, PDFDataTransportStream2);
                (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                this._queuedChunks = [];
                this._progressiveDone = params.progressiveDone || false;
                this._contentDispositionFilename = params.contentDispositionFilename || null;
                var initialData = params.initialData;
                if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
                  var buffer = new Uint8Array(initialData).buffer;
                  this._queuedChunks.push(buffer);
                }
                this._pdfDataRangeTransport = pdfDataRangeTransport;
                this._isStreamingSupported = !params.disableStream;
                this._isRangeSupported = !params.disableRange;
                this._contentLength = params.length;
                this._fullRequestReader = null;
                this._rangeReaders = [];
                this._pdfDataRangeTransport.addRangeListener(function(begin, chunk) {
                  _this._onReceiveData({
                    begin,
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressListener(function(loaded, total) {
                  _this._onProgress({
                    loaded,
                    total
                  });
                });
                this._pdfDataRangeTransport.addProgressiveReadListener(function(chunk) {
                  _this._onReceiveData({
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressiveDoneListener(function() {
                  _this._onProgressiveDone();
                });
                this._pdfDataRangeTransport.transportReady();
              }
              _createClass2(PDFDataTransportStream2, [{
                key: "_onReceiveData",
                value: function _onReceiveData(args) {
                  var buffer = new Uint8Array(args.chunk).buffer;
                  if (args.begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    var found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== args.begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                  }
                }
              }, {
                key: "_progressiveDataLength",
                get: function get() {
                  var _this$_fullRequestRea, _this$_fullRequestRea2;
                  return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                }
              }, {
                key: "_onProgress",
                value: function _onProgress(evt) {
                  if (evt.total === void 0) {
                    var firstReader = this._rangeReaders[0];
                    if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
                      firstReader.onProgress({
                        loaded: evt.loaded
                      });
                    }
                  } else {
                    var fullReader = this._fullRequestReader;
                    if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
                      fullReader.onProgress({
                        loaded: evt.loaded,
                        total: evt.total
                      });
                    }
                  }
                }
              }, {
                key: "_onProgressiveDone",
                value: function _onProgressiveDone() {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.progressiveDone();
                  }
                  this._progressiveDone = true;
                }
              }, {
                key: "_removeRangeReader",
                value: function _removeRangeReader(reader) {
                  var i = this._rangeReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeReaders.splice(i, 1);
                  }
                }
              }, {
                key: "getFullReader",
                value: function getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                  var queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                }
              }, {
                key: "getRangeReader",
                value: function getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  var reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                  this._pdfDataRangeTransport.requestDataRange(begin, end);
                  this._rangeReaders.push(reader);
                  return reader;
                }
              }, {
                key: "cancelAllRequests",
                value: function cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  var readers = this._rangeReaders.slice(0);
                  readers.forEach(function(rangeReader) {
                    rangeReader.cancel(reason);
                  });
                  this._pdfDataRangeTransport.abort();
                }
              }]);
              return PDFDataTransportStream2;
            }();
            exports2.PDFDataTransportStream = PDFDataTransportStream;
            var PDFDataTransportStreamReader = /* @__PURE__ */ function() {
              function PDFDataTransportStreamReader2(stream, queuedChunks) {
                var progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var contentDispositionFilename = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                _classCallCheck2(this, PDFDataTransportStreamReader2);
                this._stream = stream;
                this._done = progressiveDone || false;
                this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                this._queuedChunks = queuedChunks || [];
                this._loaded = 0;
                var _iterator = _createForOfIteratorHelper2(this._queuedChunks), _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var chunk = _step.value;
                    this._loaded += chunk.byteLength;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                this._requests = [];
                this._headersReady = Promise.resolve();
                stream._fullRequestReader = this;
                this.onProgress = null;
              }
              _createClass2(PDFDataTransportStreamReader2, [{
                key: "_enqueue",
                value: function _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    var requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunks.push(chunk);
                  }
                  this._loaded += chunk.byteLength;
                }
              }, {
                key: "headersReady",
                get: function get() {
                  return this._headersReady;
                }
              }, {
                key: "filename",
                get: function get() {
                  return this._filename;
                }
              }, {
                key: "isRangeSupported",
                get: function get() {
                  return this._stream._isRangeSupported;
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._stream._isStreamingSupported;
                }
              }, {
                key: "contentLength",
                get: function get() {
                  return this._stream._contentLength;
                }
              }, {
                key: "read",
                value: function() {
                  var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var chunk, requestCapability;
                    return _regenerator2["default"].wrap(function _callee$2(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!(this._queuedChunks.length > 0)) {
                              _context2.next = 3;
                              break;
                            }
                            chunk = this._queuedChunks.shift();
                            return _context2.abrupt("return", {
                              value: chunk,
                              done: false
                            });
                          case 3:
                            if (!this._done) {
                              _context2.next = 5;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value: void 0,
                              done: true
                            });
                          case 5:
                            requestCapability = (0, _util2.createPromiseCapability)();
                            this._requests.push(requestCapability);
                            return _context2.abrupt("return", requestCapability.promise);
                          case 8:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  this._done = true;
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                }
              }, {
                key: "progressiveDone",
                value: function progressiveDone() {
                  if (this._done) {
                    return;
                  }
                  this._done = true;
                }
              }]);
              return PDFDataTransportStreamReader2;
            }();
            var PDFDataTransportStreamRangeReader = /* @__PURE__ */ function() {
              function PDFDataTransportStreamRangeReader2(stream, begin, end) {
                _classCallCheck2(this, PDFDataTransportStreamRangeReader2);
                this._stream = stream;
                this._begin = begin;
                this._end = end;
                this._queuedChunk = null;
                this._requests = [];
                this._done = false;
                this.onProgress = null;
              }
              _createClass2(PDFDataTransportStreamRangeReader2, [{
                key: "_enqueue",
                value: function _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    var requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    this._requests.forEach(function(requestCapability) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    });
                    this._requests = [];
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return false;
                }
              }, {
                key: "read",
                value: function() {
                  var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var chunk, requestCapability;
                    return _regenerator2["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!this._queuedChunk) {
                              _context2.next = 4;
                              break;
                            }
                            chunk = this._queuedChunk;
                            this._queuedChunk = null;
                            return _context2.abrupt("return", {
                              value: chunk,
                              done: false
                            });
                          case 4:
                            if (!this._done) {
                              _context2.next = 6;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value: void 0,
                              done: true
                            });
                          case 6:
                            requestCapability = (0, _util2.createPromiseCapability)();
                            this._requests.push(requestCapability);
                            return _context2.abrupt("return", requestCapability.promise);
                          case 9:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read2.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  this._done = true;
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                  this._stream._removeRangeReader(this);
                }
              }]);
              return PDFDataTransportStreamRangeReader2;
            }();
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.WebGLContext = void 0;
            var _util2 = __w_pdfjs_require__2(4);
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var WebGLContext = /* @__PURE__ */ function() {
              function WebGLContext2(_ref) {
                var _ref$enable = _ref.enable, enable = _ref$enable === void 0 ? false : _ref$enable;
                _classCallCheck2(this, WebGLContext2);
                this._enabled = enable === true;
              }
              _createClass2(WebGLContext2, [{
                key: "isEnabled",
                get: function get() {
                  var enabled = this._enabled;
                  if (enabled) {
                    enabled = WebGLUtils.tryInitGL();
                  }
                  return (0, _util2.shadow)(this, "isEnabled", enabled);
                }
              }, {
                key: "composeSMask",
                value: function composeSMask(_ref2) {
                  var layer = _ref2.layer, mask = _ref2.mask, properties = _ref2.properties;
                  return WebGLUtils.composeSMask(layer, mask, properties);
                }
              }, {
                key: "drawFigures",
                value: function drawFigures(_ref3) {
                  var width = _ref3.width, height = _ref3.height, backgroundColor = _ref3.backgroundColor, figures = _ref3.figures, context = _ref3.context;
                  return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
                }
              }, {
                key: "clear",
                value: function clear() {
                  WebGLUtils.cleanup();
                }
              }]);
              return WebGLContext2;
            }();
            exports2.WebGLContext = WebGLContext;
            var WebGLUtils = function WebGLUtilsClosure() {
              function loadShader(gl, code, shaderType) {
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!compiled) {
                  var errorMsg = gl.getShaderInfoLog(shader);
                  throw new Error("Error during shader compilation: " + errorMsg);
                }
                return shader;
              }
              function createVertexShader(gl, code) {
                return loadShader(gl, code, gl.VERTEX_SHADER);
              }
              function createFragmentShader(gl, code) {
                return loadShader(gl, code, gl.FRAGMENT_SHADER);
              }
              function createProgram(gl, shaders) {
                var program = gl.createProgram();
                for (var i = 0, ii = shaders.length; i < ii; ++i) {
                  gl.attachShader(program, shaders[i]);
                }
                gl.linkProgram(program);
                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                  var errorMsg = gl.getProgramInfoLog(program);
                  throw new Error("Error during program linking: " + errorMsg);
                }
                return program;
              }
              function createTexture(gl, image, textureId) {
                gl.activeTexture(textureId);
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
              }
              var currentGL, currentCanvas;
              function generateGL() {
                if (currentGL) {
                  return;
                }
                currentCanvas = document.createElement("canvas");
                currentGL = currentCanvas.getContext("webgl", {
                  premultipliedalpha: false
                });
              }
              var smaskVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ";
              var smaskFragmentShaderCode = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ";
              var smaskCache = null;
              function initSmaskGL() {
                generateGL();
                var canvas = currentCanvas;
                currentCanvas = null;
                var gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
                cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
                var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                var texLayerLocation = gl.getUniformLocation(program, "u_image");
                var texMaskLocation = gl.getUniformLocation(program, "u_mask");
                var texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(texCoordLocation);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform1i(texLayerLocation, 0);
                gl.uniform1i(texMaskLocation, 1);
                smaskCache = cache;
              }
              function composeSMask(layer, mask, properties) {
                var width = layer.width, height = layer.height;
                if (!smaskCache) {
                  initSmaskGL();
                }
                var cache = smaskCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                if (properties.backdrop) {
                  gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
                } else {
                  gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
                }
                gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
                var texture = createTexture(gl, layer, gl.TEXTURE0);
                var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.flush();
                gl.deleteTexture(texture);
                gl.deleteTexture(maskTexture);
                gl.deleteBuffer(buffer);
                return canvas;
              }
              var figuresVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ";
              var figuresFragmentShaderCode = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ";
              var figuresCache = null;
              function initFiguresGL() {
                generateGL();
                var canvas = currentCanvas;
                currentCanvas = null;
                var gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
                cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.colorLocation = gl.getAttribLocation(program, "a_color");
                figuresCache = cache;
              }
              function drawFigures(width, height, backgroundColor, figures, context) {
                if (!figuresCache) {
                  initFiguresGL();
                }
                var cache = figuresCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                var count = 0;
                for (var i = 0, ii = figures.length; i < ii; i++) {
                  switch (figures[i].type) {
                    case "lattice":
                      var rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
                      count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
                      break;
                    case "triangles":
                      count += figures[i].coords.length;
                      break;
                  }
                }
                var coords = new Float32Array(count * 2);
                var colors = new Uint8Array(count * 3);
                var coordsMap = context.coords, colorsMap = context.colors;
                var pIndex = 0, cIndex = 0;
                for (var _i = 0, _ii = figures.length; _i < _ii; _i++) {
                  var figure = figures[_i], ps = figure.coords, cs = figure.colors;
                  switch (figure.type) {
                    case "lattice":
                      var cols = figure.verticesPerRow;
                      var _rows = ps.length / cols | 0;
                      for (var row = 1; row < _rows; row++) {
                        var offset = row * cols + 1;
                        for (var col = 1; col < cols; col++, offset++) {
                          coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                          coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                          coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                          coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                          coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                          coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                          colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                          colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                          colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                          colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                          colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                          colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                          colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                          colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                          colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                          coords[pIndex + 6] = coords[pIndex + 2];
                          coords[pIndex + 7] = coords[pIndex + 3];
                          coords[pIndex + 8] = coords[pIndex + 4];
                          coords[pIndex + 9] = coords[pIndex + 5];
                          coords[pIndex + 10] = coordsMap[ps[offset]];
                          coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                          colors[cIndex + 9] = colors[cIndex + 3];
                          colors[cIndex + 10] = colors[cIndex + 4];
                          colors[cIndex + 11] = colors[cIndex + 5];
                          colors[cIndex + 12] = colors[cIndex + 6];
                          colors[cIndex + 13] = colors[cIndex + 7];
                          colors[cIndex + 14] = colors[cIndex + 8];
                          colors[cIndex + 15] = colorsMap[cs[offset]];
                          colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                          colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                          pIndex += 12;
                          cIndex += 18;
                        }
                      }
                      break;
                    case "triangles":
                      for (var j = 0, jj = ps.length; j < jj; j++) {
                        coords[pIndex] = coordsMap[ps[j]];
                        coords[pIndex + 1] = coordsMap[ps[j] + 1];
                        colors[cIndex] = colorsMap[cs[j]];
                        colors[cIndex + 1] = colorsMap[cs[j] + 1];
                        colors[cIndex + 2] = colorsMap[cs[j] + 2];
                        pIndex += 2;
                        cIndex += 3;
                      }
                      break;
                  }
                }
                if (backgroundColor) {
                  gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1);
                } else {
                  gl.clearColor(0, 0, 0, 0);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                var coordsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                var colorsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.colorLocation);
                gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
                gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
                gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
                gl.drawArrays(gl.TRIANGLES, 0, count);
                gl.flush();
                gl.deleteBuffer(coordsBuffer);
                gl.deleteBuffer(colorsBuffer);
                return canvas;
              }
              return {
                tryInitGL: function tryInitGL() {
                  try {
                    generateGL();
                    return !!currentGL;
                  } catch (ex) {
                  }
                  return false;
                },
                composeSMask,
                drawFigures,
                cleanup: function cleanup() {
                  var _smaskCache, _figuresCache;
                  if ((_smaskCache = smaskCache) !== null && _smaskCache !== void 0 && _smaskCache.canvas) {
                    smaskCache.canvas.width = 0;
                    smaskCache.canvas.height = 0;
                  }
                  if ((_figuresCache = figuresCache) !== null && _figuresCache !== void 0 && _figuresCache.canvas) {
                    figuresCache.canvas.width = 0;
                    figuresCache.canvas.height = 0;
                  }
                  smaskCache = null;
                  figuresCache = null;
                }
              };
            }();
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationLayer = void 0;
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _util2 = __w_pdfjs_require__2(4);
            var _annotation_storage2 = __w_pdfjs_require__2(128);
            var _scripting_utils = __w_pdfjs_require__2(139);
            function _get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                _get = Reflect.get;
              } else {
                _get = function _get2(target2, property2, receiver2) {
                  var base = _superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return _get(target, property, receiver || target);
            }
            function _superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = _getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function _slicedToArray2(arr, i) {
              return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
            }
            function _nonIterableRest2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _iterableToArrayLimit2(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles2(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            function _createForOfIteratorHelper2(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e2) {
                    throw _e2;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e3) {
                didErr = true;
                err = _e3;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var AnnotationElementFactory = /* @__PURE__ */ function() {
              function AnnotationElementFactory2() {
                _classCallCheck2(this, AnnotationElementFactory2);
              }
              _createClass2(AnnotationElementFactory2, null, [{
                key: "create",
                value: function create(parameters) {
                  var subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util2.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util2.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util2.AnnotationType.WIDGET:
                      var fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util2.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util2.AnnotationType.FREETEXT:
                      return new FreeTextAnnotationElement(parameters);
                    case _util2.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util2.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util2.AnnotationType.CARET:
                      return new CaretAnnotationElement(parameters);
                    case _util2.AnnotationType.INK:
                      return new InkAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util2.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util2.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util2.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util2.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util2.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }]);
              return AnnotationElementFactory2;
            }();
            var AnnotationElement = /* @__PURE__ */ function() {
              function AnnotationElement2(parameters) {
                var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$isRenderable = _ref.isRenderable, isRenderable = _ref$isRenderable === void 0 ? false : _ref$isRenderable, _ref$ignoreBorder = _ref.ignoreBorder, ignoreBorder = _ref$ignoreBorder === void 0 ? false : _ref$ignoreBorder, _ref$createQuadrilate = _ref.createQuadrilaterals, createQuadrilaterals = _ref$createQuadrilate === void 0 ? false : _ref$createQuadrilate;
                _classCallCheck2(this, AnnotationElement2);
                this.isRenderable = isRenderable;
                this.data = parameters.data;
                this.layer = parameters.layer;
                this.page = parameters.page;
                this.viewport = parameters.viewport;
                this.linkService = parameters.linkService;
                this.downloadManager = parameters.downloadManager;
                this.imageResourcesPath = parameters.imageResourcesPath;
                this.renderInteractiveForms = parameters.renderInteractiveForms;
                this.svgFactory = parameters.svgFactory;
                this.annotationStorage = parameters.annotationStorage;
                this.enableScripting = parameters.enableScripting;
                this.hasJSActions = parameters.hasJSActions;
                this._mouseState = parameters.mouseState;
                if (isRenderable) {
                  this.container = this._createContainer(ignoreBorder);
                }
                if (createQuadrilaterals) {
                  this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                }
              }
              _createClass2(AnnotationElement2, [{
                key: "_createContainer",
                value: function _createContainer() {
                  var ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  var data = this.data, page = this.page, viewport = this.viewport;
                  var container = document.createElement("section");
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  container.setAttribute("data-annotation-id", data.id);
                  var rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  container.style.transform = "matrix(".concat(viewport.transform.join(","), ")");
                  container.style.transformOrigin = "".concat(-rect[0], "px ").concat(-rect[1], "px");
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = "".concat(data.borderStyle.width, "px");
                    if (data.borderStyle.style !== _util2.AnnotationBorderStyleType.UNDERLINE) {
                      width = width - 2 * data.borderStyle.width;
                      height = height - 2 * data.borderStyle.width;
                    }
                    var horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    var verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px");
                      container.style.borderRadius = radius;
                    }
                    switch (data.borderStyle.style) {
                      case _util2.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util2.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util2.AnnotationBorderStyleType.BEVELED:
                        (0, _util2.warn)("Unimplemented border style: beveled");
                        break;
                      case _util2.AnnotationBorderStyleType.INSET:
                        (0, _util2.warn)("Unimplemented border style: inset");
                        break;
                      case _util2.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    if (data.color) {
                      container.style.borderColor = _util2.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = "".concat(rect[0], "px");
                  container.style.top = "".concat(rect[1], "px");
                  container.style.width = "".concat(width, "px");
                  container.style.height = "".concat(height, "px");
                  return container;
                }
              }, {
                key: "_createQuadrilaterals",
                value: function _createQuadrilaterals() {
                  var ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (!this.data.quadPoints) {
                    return null;
                  }
                  var quadrilaterals = [];
                  var savedRect = this.data.rect;
                  var _iterator = _createForOfIteratorHelper2(this.data.quadPoints), _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var quadPoint = _step.value;
                      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                      quadrilaterals.push(this._createContainer(ignoreBorder));
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  this.data.rect = savedRect;
                  return quadrilaterals;
                }
              }, {
                key: "_createPopup",
                value: function _createPopup(trigger, data) {
                  var container = this.container;
                  if (this.quadrilaterals) {
                    trigger = trigger || this.quadrilaterals;
                    container = this.quadrilaterals[0];
                  }
                  if (!trigger) {
                    trigger = document.createElement("div");
                    trigger.style.height = container.style.height;
                    trigger.style.width = container.style.width;
                    container.appendChild(trigger);
                  }
                  var popupElement = new PopupElement({
                    container,
                    trigger,
                    color: data.color,
                    title: data.title,
                    modificationDate: data.modificationDate,
                    contents: data.contents,
                    hideWrapper: true
                  });
                  var popup = popupElement.render();
                  popup.style.left = container.style.width;
                  container.appendChild(popup);
                }
              }, {
                key: "_renderQuadrilaterals",
                value: function _renderQuadrilaterals(className) {
                  this.quadrilaterals.forEach(function(quadrilateral) {
                    quadrilateral.className = className;
                  });
                  return this.quadrilaterals;
                }
              }, {
                key: "render",
                value: function render() {
                  (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                }
              }]);
              return AnnotationElement2;
            }();
            var LinkAnnotationElement = /* @__PURE__ */ function(_AnnotationElement) {
              _inherits(LinkAnnotationElement2, _AnnotationElement);
              var _super = _createSuper(LinkAnnotationElement2);
              function LinkAnnotationElement2(parameters) {
                _classCallCheck2(this, LinkAnnotationElement2);
                var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
                return _super.call(this, parameters, {
                  isRenderable,
                  createQuadrilaterals: true
                });
              }
              _createClass2(LinkAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var data = this.data, linkService = this.linkService;
                  var link = document.createElement("a");
                  if (data.url) {
                    (0, _display_utils2.addLinkAttributes)(link, {
                      url: data.url,
                      target: data.newWindow ? _display_utils2.LinkTarget.BLANK : linkService.externalLinkTarget,
                      rel: linkService.externalLinkRel,
                      enabled: linkService.externalLinkEnabled
                    });
                  } else if (data.action) {
                    this._bindNamedAction(link, data.action);
                  } else if (data.dest) {
                    this._bindLink(link, data.dest);
                  } else if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                    this._bindJSAction(link, data);
                  } else {
                    this._bindLink(link, "");
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("linkAnnotation").map(function(quadrilateral, index) {
                      var linkElement = index === 0 ? link : link.cloneNode();
                      quadrilateral.appendChild(linkElement);
                      return quadrilateral;
                    });
                  }
                  this.container.className = "linkAnnotation";
                  this.container.appendChild(link);
                  return this.container;
                }
              }, {
                key: "_bindLink",
                value: function _bindLink(link, destination) {
                  var _this = this;
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = function() {
                    if (destination) {
                      _this.linkService.goToDestination(destination);
                    }
                    return false;
                  };
                  if (destination || destination === "") {
                    link.className = "internalLink";
                  }
                }
              }, {
                key: "_bindNamedAction",
                value: function _bindNamedAction(link, action) {
                  var _this2 = this;
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = function() {
                    _this2.linkService.executeNamedAction(action);
                    return false;
                  };
                  link.className = "internalLink";
                }
              }, {
                key: "_bindJSAction",
                value: function _bindJSAction(link, data) {
                  var _this3 = this;
                  link.href = this.linkService.getAnchorUrl("");
                  var map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                  var _loop = function _loop2() {
                    var name = _Object$keys[_i];
                    var jsName = map.get(name);
                    if (!jsName) {
                      return "continue";
                    }
                    link[jsName] = function() {
                      var _this3$linkService$ev;
                      (_this3$linkService$ev = _this3.linkService.eventBus) === null || _this3$linkService$ev === void 0 ? void 0 : _this3$linkService$ev.dispatch("dispatcheventinsandbox", {
                        source: _this3,
                        detail: {
                          id: data.id,
                          name
                        }
                      });
                      return false;
                    };
                  };
                  for (var _i = 0, _Object$keys = Object.keys(data.actions); _i < _Object$keys.length; _i++) {
                    var _ret = _loop();
                    if (_ret === "continue")
                      continue;
                  }
                  link.className = "internalLink";
                }
              }]);
              return LinkAnnotationElement2;
            }(AnnotationElement);
            var TextAnnotationElement = /* @__PURE__ */ function(_AnnotationElement2) {
              _inherits(TextAnnotationElement2, _AnnotationElement2);
              var _super2 = _createSuper(TextAnnotationElement2);
              function TextAnnotationElement2(parameters) {
                _classCallCheck2(this, TextAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super2.call(this, parameters, {
                  isRenderable
                });
              }
              _createClass2(TextAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "textAnnotation";
                  var image = document.createElement("img");
                  image.style.height = this.container.style.height;
                  image.style.width = this.container.style.width;
                  image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image.alt = "[{{type}} Annotation]";
                  image.dataset.l10nId = "text_annotation_type";
                  image.dataset.l10nArgs = JSON.stringify({
                    type: this.data.name
                  });
                  if (!this.data.hasPopup) {
                    this._createPopup(image, this.data);
                  }
                  this.container.appendChild(image);
                  return this.container;
                }
              }]);
              return TextAnnotationElement2;
            }(AnnotationElement);
            var WidgetAnnotationElement = /* @__PURE__ */ function(_AnnotationElement3) {
              _inherits(WidgetAnnotationElement2, _AnnotationElement3);
              var _super3 = _createSuper(WidgetAnnotationElement2);
              function WidgetAnnotationElement2() {
                _classCallCheck2(this, WidgetAnnotationElement2);
                return _super3.apply(this, arguments);
              }
              _createClass2(WidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  if (this.data.alternativeText) {
                    this.container.title = this.data.alternativeText;
                  }
                  return this.container;
                }
              }, {
                key: "_getKeyModifier",
                value: function _getKeyModifier(event) {
                  return navigator.platform.includes("Win") && event.ctrlKey || navigator.platform.includes("Mac") && event.metaKey;
                }
              }, {
                key: "_setEventListener",
                value: function _setEventListener(element, baseName, eventName, valueGetter) {
                  var _this4 = this;
                  if (baseName.includes("mouse")) {
                    element.addEventListener(baseName, function(event) {
                      var _this4$linkService$ev;
                      (_this4$linkService$ev = _this4.linkService.eventBus) === null || _this4$linkService$ev === void 0 ? void 0 : _this4$linkService$ev.dispatch("dispatcheventinsandbox", {
                        source: _this4,
                        detail: {
                          id: _this4.data.id,
                          name: eventName,
                          value: valueGetter(event),
                          shift: event.shiftKey,
                          modifier: _this4._getKeyModifier(event)
                        }
                      });
                    });
                  } else {
                    element.addEventListener(baseName, function(event) {
                      var _this4$linkService$ev2;
                      (_this4$linkService$ev2 = _this4.linkService.eventBus) === null || _this4$linkService$ev2 === void 0 ? void 0 : _this4$linkService$ev2.dispatch("dispatcheventinsandbox", {
                        source: _this4,
                        detail: {
                          id: _this4.data.id,
                          name: eventName,
                          value: event.target.checked
                        }
                      });
                    });
                  }
                }
              }, {
                key: "_setEventListeners",
                value: function _setEventListeners(element, names, getter) {
                  var _iterator2 = _createForOfIteratorHelper2(names), _step2;
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var _this$data$actions;
                      var _step2$value = _slicedToArray2(_step2.value, 2), baseName = _step2$value[0], eventName = _step2$value[1];
                      if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
                        this._setEventListener(element, baseName, eventName, getter);
                      }
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                }
              }, {
                key: "_setColor",
                value: function _setColor(event) {
                  var detail = event.detail, target = event.target;
                  var style = target.style;
                  for (var _i2 = 0, _arr2 = ["bgColor", "fillColor", "fgColor", "textColor", "borderColor", "strokeColor"]; _i2 < _arr2.length; _i2++) {
                    var name = _arr2[_i2];
                    var color = detail[name];
                    if (!color) {
                      continue;
                    }
                    color = _scripting_utils.ColorConverters["".concat(color[0], "_HTML")](color.slice(1));
                    switch (name) {
                      case "bgColor":
                      case "fillColor":
                        style.backgroundColor = color;
                        break;
                      case "fgColor":
                      case "textColor":
                        style.color = color;
                        break;
                      case "borderColor":
                      case "strokeColor":
                        style.borderColor = color;
                        break;
                    }
                  }
                }
              }]);
              return WidgetAnnotationElement2;
            }(AnnotationElement);
            var TextWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem) {
              _inherits(TextWidgetAnnotationElement2, _WidgetAnnotationElem);
              var _super4 = _createSuper(TextWidgetAnnotationElement2);
              function TextWidgetAnnotationElement2(parameters) {
                _classCallCheck2(this, TextWidgetAnnotationElement2);
                var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                return _super4.call(this, parameters, {
                  isRenderable
                });
              }
              _createClass2(TextWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var _this5 = this;
                  var storage = this.annotationStorage;
                  var id = this.data.id;
                  this.container.className = "textWidgetAnnotation";
                  var element = null;
                  if (this.renderInteractiveForms) {
                    var storedData = storage.getValue(id, {
                      value: this.data.fieldValue,
                      valueAsString: this.data.fieldValue
                    });
                    var textContent = storedData.valueAsString || storedData.value || "";
                    var elementData = {
                      userValue: null,
                      formattedValue: null,
                      beforeInputSelectionRange: null,
                      beforeInputValue: null
                    };
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = textContent;
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", textContent);
                    }
                    elementData.userValue = textContent;
                    element.setAttribute("id", id);
                    element.addEventListener("input", function(event) {
                      storage.setValue(id, {
                        value: event.target.value
                      });
                    });
                    var blurListener = function blurListener2(event) {
                      if (elementData.formattedValue) {
                        event.target.value = elementData.formattedValue;
                      }
                      event.target.setSelectionRange(0, 0);
                      elementData.beforeInputSelectionRange = null;
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      var _this$data$actions2;
                      element.addEventListener("focus", function(event) {
                        if (elementData.userValue) {
                          event.target.value = elementData.userValue;
                        }
                      });
                      element.addEventListener("updatefromsandbox", function(event) {
                        var detail = event.detail;
                        var actions = {
                          value: function value() {
                            elementData.userValue = detail.value || "";
                            storage.setValue(id, {
                              value: elementData.userValue.toString()
                            });
                            if (!elementData.formattedValue) {
                              event.target.value = elementData.userValue;
                            }
                          },
                          valueAsString: function valueAsString() {
                            elementData.formattedValue = detail.valueAsString || "";
                            if (event.target !== document.activeElement) {
                              event.target.value = elementData.formattedValue;
                            }
                            storage.setValue(id, {
                              formattedValue: elementData.formattedValue
                            });
                          },
                          focus: function focus() {
                            setTimeout(function() {
                              return event.target.focus({
                                preventScroll: false
                              });
                            }, 0);
                          },
                          userName: function userName() {
                            event.target.title = detail.userName;
                          },
                          hidden: function hidden() {
                            event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                            storage.setValue(id, {
                              hidden: detail.hidden
                            });
                          },
                          editable: function editable() {
                            event.target.disabled = !detail.editable;
                          },
                          selRange: function selRange() {
                            var _detail$selRange = _slicedToArray2(detail.selRange, 2), selStart = _detail$selRange[0], selEnd = _detail$selRange[1];
                            if (selStart >= 0 && selEnd < event.target.value.length) {
                              event.target.setSelectionRange(selStart, selEnd);
                            }
                          }
                        };
                        Object.keys(detail).filter(function(name) {
                          return name in actions;
                        }).forEach(function(name) {
                          return actions[name]();
                        });
                        _this5._setColor(event);
                      });
                      element.addEventListener("keydown", function(event) {
                        var _this5$linkService$ev;
                        elementData.beforeInputValue = event.target.value;
                        var commitKey = -1;
                        if (event.key === "Escape") {
                          commitKey = 0;
                        } else if (event.key === "Enter") {
                          commitKey = 2;
                        } else if (event.key === "Tab") {
                          commitKey = 3;
                        }
                        if (commitKey === -1) {
                          return;
                        }
                        elementData.userValue = event.target.value;
                        (_this5$linkService$ev = _this5.linkService.eventBus) === null || _this5$linkService$ev === void 0 ? void 0 : _this5$linkService$ev.dispatch("dispatcheventinsandbox", {
                          source: _this5,
                          detail: {
                            id,
                            name: "Keystroke",
                            value: event.target.value,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      });
                      var _blurListener = blurListener;
                      blurListener = null;
                      element.addEventListener("blur", function(event) {
                        if (_this5._mouseState.isDown) {
                          var _this5$linkService$ev2;
                          elementData.userValue = event.target.value;
                          (_this5$linkService$ev2 = _this5.linkService.eventBus) === null || _this5$linkService$ev2 === void 0 ? void 0 : _this5$linkService$ev2.dispatch("dispatcheventinsandbox", {
                            source: _this5,
                            detail: {
                              id,
                              name: "Keystroke",
                              value: event.target.value,
                              willCommit: true,
                              commitKey: 1,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        }
                        _blurListener(event);
                      });
                      element.addEventListener("mousedown", function(event) {
                        elementData.beforeInputValue = event.target.value;
                        elementData.beforeInputSelectionRange = null;
                      });
                      element.addEventListener("keyup", function(event) {
                        if (event.target.selectionStart === event.target.selectionEnd) {
                          elementData.beforeInputSelectionRange = null;
                        }
                      });
                      element.addEventListener("select", function(event) {
                        elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
                      });
                      if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
                        element.addEventListener("input", function(event) {
                          var _this5$linkService$ev3;
                          var selStart = -1;
                          var selEnd = -1;
                          if (elementData.beforeInputSelectionRange) {
                            var _elementData$beforeIn = _slicedToArray2(elementData.beforeInputSelectionRange, 2);
                            selStart = _elementData$beforeIn[0];
                            selEnd = _elementData$beforeIn[1];
                          }
                          (_this5$linkService$ev3 = _this5.linkService.eventBus) === null || _this5$linkService$ev3 === void 0 ? void 0 : _this5$linkService$ev3.dispatch("dispatcheventinsandbox", {
                            source: _this5,
                            detail: {
                              id,
                              name: "Keystroke",
                              value: elementData.beforeInputValue,
                              change: event.data,
                              willCommit: false,
                              selStart,
                              selEnd
                            }
                          });
                        });
                      }
                      this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function(event) {
                        return event.target.value;
                      });
                    }
                    if (blurListener) {
                      element.addEventListener("blur", blurListener);
                    }
                    element.disabled = this.data.readOnly;
                    element.name = this.data.fieldName;
                    if (this.data.maxLen !== null) {
                      element.maxLength = this.data.maxLen;
                    }
                    if (this.data.comb) {
                      var fieldWidth = this.data.rect[2] - this.data.rect[0];
                      var combWidth = fieldWidth / this.data.maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)");
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                  }
                  this._setTextStyle(element);
                  this.container.appendChild(element);
                  return this.container;
                }
              }, {
                key: "_setTextStyle",
                value: function _setTextStyle(element) {
                  var TEXT_ALIGNMENT = ["left", "center", "right"];
                  var _this$data$defaultApp = this.data.defaultAppearanceData, fontSize = _this$data$defaultApp.fontSize, fontColor = _this$data$defaultApp.fontColor;
                  var style = element.style;
                  if (fontSize) {
                    style.fontSize = "".concat(fontSize, "px");
                  }
                  style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                  if (this.data.textAlignment !== null) {
                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                }
              }]);
              return TextWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var CheckboxWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem2) {
              _inherits(CheckboxWidgetAnnotationElement2, _WidgetAnnotationElem2);
              var _super5 = _createSuper(CheckboxWidgetAnnotationElement2);
              function CheckboxWidgetAnnotationElement2(parameters) {
                _classCallCheck2(this, CheckboxWidgetAnnotationElement2);
                return _super5.call(this, parameters, {
                  isRenderable: parameters.renderInteractiveForms
                });
              }
              _createClass2(CheckboxWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var _this6 = this;
                  var storage = this.annotationStorage;
                  var data = this.data;
                  var id = data.id;
                  var value = storage.getValue(id, {
                    value: data.fieldValue && (data.exportValue && data.exportValue === data.fieldValue || !data.exportValue && data.fieldValue !== "Off")
                  }).value;
                  this.container.className = "buttonWidgetAnnotation checkBox";
                  var element = document.createElement("input");
                  element.disabled = data.readOnly;
                  element.type = "checkbox";
                  element.name = this.data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("id", id);
                  element.addEventListener("change", function(event) {
                    var name = event.target.name;
                    var _iterator3 = _createForOfIteratorHelper2(document.getElementsByName(name)), _step3;
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                        var checkbox = _step3.value;
                        if (checkbox !== event.target) {
                          checkbox.checked = false;
                          storage.setValue(checkbox.parentNode.getAttribute("data-annotation-id"), {
                            value: false
                          });
                        }
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                    storage.setValue(id, {
                      value: event.target.checked
                    });
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("updatefromsandbox", function(event) {
                      var detail = event.detail;
                      var actions = {
                        value: function value2() {
                          event.target.checked = detail.value !== "Off";
                          storage.setValue(id, {
                            value: event.target.checked
                          });
                        },
                        focus: function focus() {
                          setTimeout(function() {
                            return event.target.focus({
                              preventScroll: false
                            });
                          }, 0);
                        },
                        hidden: function hidden() {
                          event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                          storage.setValue(id, {
                            hidden: detail.hidden
                          });
                        },
                        editable: function editable() {
                          event.target.disabled = !detail.editable;
                        }
                      };
                      Object.keys(detail).filter(function(name) {
                        return name in actions;
                      }).forEach(function(name) {
                        return actions[name]();
                      });
                      _this6._setColor(event);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function(event) {
                      return event.target.checked;
                    });
                  }
                  this.container.appendChild(element);
                  return this.container;
                }
              }]);
              return CheckboxWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var RadioButtonWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem3) {
              _inherits(RadioButtonWidgetAnnotationElement2, _WidgetAnnotationElem3);
              var _super6 = _createSuper(RadioButtonWidgetAnnotationElement2);
              function RadioButtonWidgetAnnotationElement2(parameters) {
                _classCallCheck2(this, RadioButtonWidgetAnnotationElement2);
                return _super6.call(this, parameters, {
                  isRenderable: parameters.renderInteractiveForms
                });
              }
              _createClass2(RadioButtonWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var _this7 = this;
                  this.container.className = "buttonWidgetAnnotation radioButton";
                  var storage = this.annotationStorage;
                  var data = this.data;
                  var id = data.id;
                  var value = storage.getValue(id, {
                    value: data.fieldValue === data.buttonValue
                  }).value;
                  var element = document.createElement("input");
                  element.disabled = data.readOnly;
                  element.type = "radio";
                  element.name = data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("id", id);
                  element.addEventListener("change", function(event) {
                    var target = event.target;
                    var _iterator4 = _createForOfIteratorHelper2(document.getElementsByName(target.name)), _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                        var radio = _step4.value;
                        if (radio !== target) {
                          storage.setValue(radio.getAttribute("id"), {
                            value: false
                          });
                        }
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    storage.setValue(id, {
                      value: target.checked
                    });
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    var pdfButtonValue = data.buttonValue;
                    element.addEventListener("updatefromsandbox", function(event) {
                      var detail = event.detail;
                      var actions = {
                        value: function value2() {
                          var checked = pdfButtonValue === detail.value;
                          var _iterator5 = _createForOfIteratorHelper2(document.getElementsByName(event.target.name)), _step5;
                          try {
                            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                              var radio = _step5.value;
                              var radioId = radio.getAttribute("id");
                              radio.checked = radioId === id && checked;
                              storage.setValue(radioId, {
                                value: radio.checked
                              });
                            }
                          } catch (err) {
                            _iterator5.e(err);
                          } finally {
                            _iterator5.f();
                          }
                        },
                        focus: function focus() {
                          setTimeout(function() {
                            return event.target.focus({
                              preventScroll: false
                            });
                          }, 0);
                        },
                        hidden: function hidden() {
                          event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                          storage.setValue(id, {
                            hidden: detail.hidden
                          });
                        },
                        editable: function editable() {
                          event.target.disabled = !detail.editable;
                        }
                      };
                      Object.keys(detail).filter(function(name) {
                        return name in actions;
                      }).forEach(function(name) {
                        return actions[name]();
                      });
                      _this7._setColor(event);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function(event) {
                      return event.target.checked;
                    });
                  }
                  this.container.appendChild(element);
                  return this.container;
                }
              }]);
              return RadioButtonWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var PushButtonWidgetAnnotationElement = /* @__PURE__ */ function(_LinkAnnotationElemen) {
              _inherits(PushButtonWidgetAnnotationElement2, _LinkAnnotationElemen);
              var _super7 = _createSuper(PushButtonWidgetAnnotationElement2);
              function PushButtonWidgetAnnotationElement2() {
                _classCallCheck2(this, PushButtonWidgetAnnotationElement2);
                return _super7.apply(this, arguments);
              }
              _createClass2(PushButtonWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement2.prototype), "render", this).call(this);
                  container.className = "buttonWidgetAnnotation pushButton";
                  if (this.data.alternativeText) {
                    container.title = this.data.alternativeText;
                  }
                  return container;
                }
              }]);
              return PushButtonWidgetAnnotationElement2;
            }(LinkAnnotationElement);
            var ChoiceWidgetAnnotationElement = /* @__PURE__ */ function(_WidgetAnnotationElem4) {
              _inherits(ChoiceWidgetAnnotationElement2, _WidgetAnnotationElem4);
              var _super8 = _createSuper(ChoiceWidgetAnnotationElement2);
              function ChoiceWidgetAnnotationElement2(parameters) {
                _classCallCheck2(this, ChoiceWidgetAnnotationElement2);
                return _super8.call(this, parameters, {
                  isRenderable: parameters.renderInteractiveForms
                });
              }
              _createClass2(ChoiceWidgetAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var _this8 = this;
                  this.container.className = "choiceWidgetAnnotation";
                  var storage = this.annotationStorage;
                  var id = this.data.id;
                  storage.getValue(id, {
                    value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : void 0
                  });
                  var selectElement = document.createElement("select");
                  selectElement.disabled = this.data.readOnly;
                  selectElement.name = this.data.fieldName;
                  selectElement.setAttribute("id", id);
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  var _iterator6 = _createForOfIteratorHelper2(this.data.options), _step6;
                  try {
                    for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                      var option = _step6.value;
                      var optionElement = document.createElement("option");
                      optionElement.textContent = option.displayValue;
                      optionElement.value = option.exportValue;
                      if (this.data.fieldValue.includes(option.exportValue)) {
                        optionElement.setAttribute("selected", true);
                      }
                      selectElement.appendChild(optionElement);
                    }
                  } catch (err) {
                    _iterator6.e(err);
                  } finally {
                    _iterator6.f();
                  }
                  var getValue = function getValue2(event, isExport) {
                    var name = isExport ? "value" : "textContent";
                    var options = event.target.options;
                    if (!event.target.multiple) {
                      return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                    }
                    return Array.prototype.filter.call(options, function(option2) {
                      return option2.selected;
                    }).map(function(option2) {
                      return option2[name];
                    });
                  };
                  var getItems = function getItems2(event) {
                    var options = event.target.options;
                    return Array.prototype.map.call(options, function(option2) {
                      return {
                        displayValue: option2.textContent,
                        exportValue: option2.value
                      };
                    });
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    selectElement.addEventListener("updatefromsandbox", function(event) {
                      var detail = event.detail;
                      var actions = {
                        value: function value() {
                          var options = selectElement.options;
                          var value2 = detail.value;
                          var values = new Set(Array.isArray(value2) ? value2 : [value2]);
                          Array.prototype.forEach.call(options, function(option2) {
                            option2.selected = values.has(option2.value);
                          });
                          storage.setValue(id, {
                            value: getValue(event, true)
                          });
                        },
                        multipleSelection: function multipleSelection() {
                          selectElement.multiple = true;
                        },
                        remove: function remove() {
                          var options = selectElement.options;
                          var index = detail.remove;
                          options[index].selected = false;
                          selectElement.remove(index);
                          if (options.length > 0) {
                            var i = Array.prototype.findIndex.call(options, function(option2) {
                              return option2.selected;
                            });
                            if (i === -1) {
                              options[0].selected = true;
                            }
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        clear: function clear() {
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          storage.setValue(id, {
                            value: null,
                            items: []
                          });
                        },
                        insert: function insert() {
                          var _detail$insert = detail.insert, index = _detail$insert.index, displayValue = _detail$insert.displayValue, exportValue = _detail$insert.exportValue;
                          var optionElement2 = document.createElement("option");
                          optionElement2.textContent = displayValue;
                          optionElement2.value = exportValue;
                          selectElement.insertBefore(optionElement2, selectElement.children[index]);
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        items: function items() {
                          var items2 = detail.items;
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          var _iterator7 = _createForOfIteratorHelper2(items2), _step7;
                          try {
                            for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                              var item = _step7.value;
                              var displayValue = item.displayValue, exportValue = item.exportValue;
                              var optionElement2 = document.createElement("option");
                              optionElement2.textContent = displayValue;
                              optionElement2.value = exportValue;
                              selectElement.appendChild(optionElement2);
                            }
                          } catch (err) {
                            _iterator7.e(err);
                          } finally {
                            _iterator7.f();
                          }
                          if (selectElement.options.length > 0) {
                            selectElement.options[0].selected = true;
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        indices: function indices() {
                          var indices2 = new Set(detail.indices);
                          var options = event.target.options;
                          Array.prototype.forEach.call(options, function(option2, i) {
                            option2.selected = indices2.has(i);
                          });
                          storage.setValue(id, {
                            value: getValue(event, true)
                          });
                        },
                        focus: function focus() {
                          setTimeout(function() {
                            return event.target.focus({
                              preventScroll: false
                            });
                          }, 0);
                        },
                        hidden: function hidden() {
                          event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                          storage.setValue(id, {
                            hidden: detail.hidden
                          });
                        },
                        editable: function editable() {
                          event.target.disabled = !detail.editable;
                        }
                      };
                      Object.keys(detail).filter(function(name) {
                        return name in actions;
                      }).forEach(function(name) {
                        return actions[name]();
                      });
                      _this8._setColor(event);
                    });
                    selectElement.addEventListener("input", function(event) {
                      var _this8$linkService$ev;
                      var exportValue = getValue(event, true);
                      var value = getValue(event, false);
                      storage.setValue(id, {
                        value: exportValue
                      });
                      (_this8$linkService$ev = _this8.linkService.eventBus) === null || _this8$linkService$ev === void 0 ? void 0 : _this8$linkService$ev.dispatch("dispatcheventinsandbox", {
                        source: _this8,
                        detail: {
                          id,
                          name: "Keystroke",
                          value,
                          changeEx: exportValue,
                          willCommit: true,
                          commitKey: 1,
                          keyDown: false
                        }
                      });
                    });
                    this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], function(event) {
                      return event.target.checked;
                    });
                  } else {
                    selectElement.addEventListener("input", function(event) {
                      storage.setValue(id, {
                        value: getValue(event)
                      });
                    });
                  }
                  this.container.appendChild(selectElement);
                  return this.container;
                }
              }]);
              return ChoiceWidgetAnnotationElement2;
            }(WidgetAnnotationElement);
            var PopupAnnotationElement = /* @__PURE__ */ function(_AnnotationElement4) {
              _inherits(PopupAnnotationElement2, _AnnotationElement4);
              var _super9 = _createSuper(PopupAnnotationElement2);
              function PopupAnnotationElement2(parameters) {
                _classCallCheck2(this, PopupAnnotationElement2);
                var isRenderable = !!(parameters.data.title || parameters.data.contents);
                return _super9.call(this, parameters, {
                  isRenderable
                });
              }
              _createClass2(PopupAnnotationElement2, [{
                key: "render",
                value: function render() {
                  var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                  this.container.className = "popupAnnotation";
                  if (IGNORE_TYPES.includes(this.data.parentType)) {
                    return this.container;
                  }
                  var selector = '[data-annotation-id="'.concat(this.data.parentId, '"]');
                  var parentElements = this.layer.querySelectorAll(selector);
                  if (parentElements.length === 0) {
                    return this.container;
                  }
                  var popup = new PopupElement({
                    container: this.container,
                    trigger: Array.from(parentElements),
                    color: this.data.color,
                    title: this.data.title,
                    modificationDate: this.data.modificationDate,
                    contents: this.data.contents
                  });
                  var page = this.page;
                  var rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                  var popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                  var popupTop = rect[1];
                  this.container.style.transformOrigin = "".concat(-popupLeft, "px ").concat(-popupTop, "px");
                  this.container.style.left = "".concat(popupLeft, "px");
                  this.container.style.top = "".concat(popupTop, "px");
                  this.container.appendChild(popup.render());
                  return this.container;
                }
              }]);
              return PopupAnnotationElement2;
            }(AnnotationElement);
            var PopupElement = /* @__PURE__ */ function() {
              function PopupElement2(parameters) {
                _classCallCheck2(this, PopupElement2);
                this.container = parameters.container;
                this.trigger = parameters.trigger;
                this.color = parameters.color;
                this.title = parameters.title;
                this.modificationDate = parameters.modificationDate;
                this.contents = parameters.contents;
                this.hideWrapper = parameters.hideWrapper || false;
                this.pinned = false;
              }
              _createClass2(PopupElement2, [{
                key: "render",
                value: function render() {
                  var _this9 = this;
                  var BACKGROUND_ENLIGHT = 0.7;
                  var wrapper = document.createElement("div");
                  wrapper.className = "popupWrapper";
                  this.hideElement = this.hideWrapper ? wrapper : this.container;
                  this.hideElement.hidden = true;
                  var popup = document.createElement("div");
                  popup.className = "popup";
                  var color = this.color;
                  if (color) {
                    var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                    var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                    var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                    popup.style.backgroundColor = _util2.Util.makeHexColor(r | 0, g | 0, b | 0);
                  }
                  var title = document.createElement("h1");
                  title.textContent = this.title;
                  popup.appendChild(title);
                  var dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                  if (dateObject) {
                    var modificationDate = document.createElement("span");
                    modificationDate.textContent = "{{date}}, {{time}}";
                    modificationDate.dataset.l10nId = "annotation_date_string";
                    modificationDate.dataset.l10nArgs = JSON.stringify({
                      date: dateObject.toLocaleDateString(),
                      time: dateObject.toLocaleTimeString()
                    });
                    popup.appendChild(modificationDate);
                  }
                  var contents = this._formatContents(this.contents);
                  popup.appendChild(contents);
                  if (!Array.isArray(this.trigger)) {
                    this.trigger = [this.trigger];
                  }
                  this.trigger.forEach(function(element) {
                    element.addEventListener("click", _this9._toggle.bind(_this9));
                    element.addEventListener("mouseover", _this9._show.bind(_this9, false));
                    element.addEventListener("mouseout", _this9._hide.bind(_this9, false));
                  });
                  popup.addEventListener("click", this._hide.bind(this, true));
                  wrapper.appendChild(popup);
                  return wrapper;
                }
              }, {
                key: "_formatContents",
                value: function _formatContents(contents) {
                  var p = document.createElement("p");
                  var lines = contents.split(/(?:\r\n?|\n)/);
                  for (var i = 0, ii = lines.length; i < ii; ++i) {
                    var line = lines[i];
                    p.appendChild(document.createTextNode(line));
                    if (i < ii - 1) {
                      p.appendChild(document.createElement("br"));
                    }
                  }
                  return p;
                }
              }, {
                key: "_toggle",
                value: function _toggle() {
                  if (this.pinned) {
                    this._hide(true);
                  } else {
                    this._show(true);
                  }
                }
              }, {
                key: "_show",
                value: function _show() {
                  var pin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (pin) {
                    this.pinned = true;
                  }
                  if (this.hideElement.hidden) {
                    this.hideElement.hidden = false;
                    this.container.style.zIndex += 1;
                  }
                }
              }, {
                key: "_hide",
                value: function _hide() {
                  var unpin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  if (unpin) {
                    this.pinned = false;
                  }
                  if (!this.hideElement.hidden && !this.pinned) {
                    this.hideElement.hidden = true;
                    this.container.style.zIndex -= 1;
                  }
                }
              }]);
              return PopupElement2;
            }();
            var FreeTextAnnotationElement = /* @__PURE__ */ function(_AnnotationElement5) {
              _inherits(FreeTextAnnotationElement2, _AnnotationElement5);
              var _super10 = _createSuper(FreeTextAnnotationElement2);
              function FreeTextAnnotationElement2(parameters) {
                _classCallCheck2(this, FreeTextAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super10.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              _createClass2(FreeTextAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "freeTextAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }]);
              return FreeTextAnnotationElement2;
            }(AnnotationElement);
            var LineAnnotationElement = /* @__PURE__ */ function(_AnnotationElement6) {
              _inherits(LineAnnotationElement2, _AnnotationElement6);
              var _super11 = _createSuper(LineAnnotationElement2);
              function LineAnnotationElement2(parameters) {
                _classCallCheck2(this, LineAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super11.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              _createClass2(LineAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "lineAnnotation";
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var line = this.svgFactory.createElement("svg:line");
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width || 1);
                  line.setAttribute("stroke", "transparent");
                  svg.appendChild(line);
                  this.container.append(svg);
                  this._createPopup(line, data);
                  return this.container;
                }
              }]);
              return LineAnnotationElement2;
            }(AnnotationElement);
            var SquareAnnotationElement = /* @__PURE__ */ function(_AnnotationElement7) {
              _inherits(SquareAnnotationElement2, _AnnotationElement7);
              var _super12 = _createSuper(SquareAnnotationElement2);
              function SquareAnnotationElement2(parameters) {
                _classCallCheck2(this, SquareAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super12.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              _createClass2(SquareAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "squareAnnotation";
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var borderWidth = data.borderStyle.width;
                  var square = this.svgFactory.createElement("svg:rect");
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width - borderWidth);
                  square.setAttribute("height", height - borderWidth);
                  square.setAttribute("stroke-width", borderWidth || 1);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "none");
                  svg.appendChild(square);
                  this.container.append(svg);
                  this._createPopup(square, data);
                  return this.container;
                }
              }]);
              return SquareAnnotationElement2;
            }(AnnotationElement);
            var CircleAnnotationElement = /* @__PURE__ */ function(_AnnotationElement8) {
              _inherits(CircleAnnotationElement2, _AnnotationElement8);
              var _super13 = _createSuper(CircleAnnotationElement2);
              function CircleAnnotationElement2(parameters) {
                _classCallCheck2(this, CircleAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super13.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              _createClass2(CircleAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "circleAnnotation";
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var borderWidth = data.borderStyle.width;
                  var circle = this.svgFactory.createElement("svg:ellipse");
                  circle.setAttribute("cx", width / 2);
                  circle.setAttribute("cy", height / 2);
                  circle.setAttribute("rx", width / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth || 1);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "none");
                  svg.appendChild(circle);
                  this.container.append(svg);
                  this._createPopup(circle, data);
                  return this.container;
                }
              }]);
              return CircleAnnotationElement2;
            }(AnnotationElement);
            var PolylineAnnotationElement = /* @__PURE__ */ function(_AnnotationElement9) {
              _inherits(PolylineAnnotationElement2, _AnnotationElement9);
              var _super14 = _createSuper(PolylineAnnotationElement2);
              function PolylineAnnotationElement2(parameters) {
                var _this10;
                _classCallCheck2(this, PolylineAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                _this10 = _super14.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
                _this10.containerClassName = "polylineAnnotation";
                _this10.svgElementName = "svg:polyline";
                return _this10;
              }
              _createClass2(PolylineAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = this.containerClassName;
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var points = [];
                  var _iterator8 = _createForOfIteratorHelper2(data.vertices), _step8;
                  try {
                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                      var coordinate = _step8.value;
                      var x = coordinate.x - data.rect[0];
                      var y = data.rect[3] - coordinate.y;
                      points.push(x + "," + y);
                    }
                  } catch (err) {
                    _iterator8.e(err);
                  } finally {
                    _iterator8.f();
                  }
                  points = points.join(" ");
                  var polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "none");
                  svg.appendChild(polyline);
                  this.container.append(svg);
                  this._createPopup(polyline, data);
                  return this.container;
                }
              }]);
              return PolylineAnnotationElement2;
            }(AnnotationElement);
            var PolygonAnnotationElement = /* @__PURE__ */ function(_PolylineAnnotationEl) {
              _inherits(PolygonAnnotationElement2, _PolylineAnnotationEl);
              var _super15 = _createSuper(PolygonAnnotationElement2);
              function PolygonAnnotationElement2(parameters) {
                var _this11;
                _classCallCheck2(this, PolygonAnnotationElement2);
                _this11 = _super15.call(this, parameters);
                _this11.containerClassName = "polygonAnnotation";
                _this11.svgElementName = "svg:polygon";
                return _this11;
              }
              return PolygonAnnotationElement2;
            }(PolylineAnnotationElement);
            var CaretAnnotationElement = /* @__PURE__ */ function(_AnnotationElement10) {
              _inherits(CaretAnnotationElement2, _AnnotationElement10);
              var _super16 = _createSuper(CaretAnnotationElement2);
              function CaretAnnotationElement2(parameters) {
                _classCallCheck2(this, CaretAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super16.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              _createClass2(CaretAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "caretAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }]);
              return CaretAnnotationElement2;
            }(AnnotationElement);
            var InkAnnotationElement = /* @__PURE__ */ function(_AnnotationElement11) {
              _inherits(InkAnnotationElement2, _AnnotationElement11);
              var _super17 = _createSuper(InkAnnotationElement2);
              function InkAnnotationElement2(parameters) {
                var _this12;
                _classCallCheck2(this, InkAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                _this12 = _super17.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
                _this12.containerClassName = "inkAnnotation";
                _this12.svgElementName = "svg:polyline";
                return _this12;
              }
              _createClass2(InkAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = this.containerClassName;
                  var data = this.data;
                  var width = data.rect[2] - data.rect[0];
                  var height = data.rect[3] - data.rect[1];
                  var svg = this.svgFactory.create(width, height);
                  var _iterator9 = _createForOfIteratorHelper2(data.inkLists), _step9;
                  try {
                    for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                      var inkList = _step9.value;
                      var points = [];
                      var _iterator10 = _createForOfIteratorHelper2(inkList), _step10;
                      try {
                        for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                          var coordinate = _step10.value;
                          var x = coordinate.x - data.rect[0];
                          var y = data.rect[3] - coordinate.y;
                          points.push("".concat(x, ",").concat(y));
                        }
                      } catch (err) {
                        _iterator10.e(err);
                      } finally {
                        _iterator10.f();
                      }
                      points = points.join(" ");
                      var polyline = this.svgFactory.createElement(this.svgElementName);
                      polyline.setAttribute("points", points);
                      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                      polyline.setAttribute("stroke", "transparent");
                      polyline.setAttribute("fill", "none");
                      this._createPopup(polyline, data);
                      svg.appendChild(polyline);
                    }
                  } catch (err) {
                    _iterator9.e(err);
                  } finally {
                    _iterator9.f();
                  }
                  this.container.append(svg);
                  return this.container;
                }
              }]);
              return InkAnnotationElement2;
            }(AnnotationElement);
            var HighlightAnnotationElement = /* @__PURE__ */ function(_AnnotationElement12) {
              _inherits(HighlightAnnotationElement2, _AnnotationElement12);
              var _super18 = _createSuper(HighlightAnnotationElement2);
              function HighlightAnnotationElement2(parameters) {
                _classCallCheck2(this, HighlightAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super18.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              _createClass2(HighlightAnnotationElement2, [{
                key: "render",
                value: function render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("highlightAnnotation");
                  }
                  this.container.className = "highlightAnnotation";
                  return this.container;
                }
              }]);
              return HighlightAnnotationElement2;
            }(AnnotationElement);
            var UnderlineAnnotationElement = /* @__PURE__ */ function(_AnnotationElement13) {
              _inherits(UnderlineAnnotationElement2, _AnnotationElement13);
              var _super19 = _createSuper(UnderlineAnnotationElement2);
              function UnderlineAnnotationElement2(parameters) {
                _classCallCheck2(this, UnderlineAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super19.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              _createClass2(UnderlineAnnotationElement2, [{
                key: "render",
                value: function render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("underlineAnnotation");
                  }
                  this.container.className = "underlineAnnotation";
                  return this.container;
                }
              }]);
              return UnderlineAnnotationElement2;
            }(AnnotationElement);
            var SquigglyAnnotationElement = /* @__PURE__ */ function(_AnnotationElement14) {
              _inherits(SquigglyAnnotationElement2, _AnnotationElement14);
              var _super20 = _createSuper(SquigglyAnnotationElement2);
              function SquigglyAnnotationElement2(parameters) {
                _classCallCheck2(this, SquigglyAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super20.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              _createClass2(SquigglyAnnotationElement2, [{
                key: "render",
                value: function render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("squigglyAnnotation");
                  }
                  this.container.className = "squigglyAnnotation";
                  return this.container;
                }
              }]);
              return SquigglyAnnotationElement2;
            }(AnnotationElement);
            var StrikeOutAnnotationElement = /* @__PURE__ */ function(_AnnotationElement15) {
              _inherits(StrikeOutAnnotationElement2, _AnnotationElement15);
              var _super21 = _createSuper(StrikeOutAnnotationElement2);
              function StrikeOutAnnotationElement2(parameters) {
                _classCallCheck2(this, StrikeOutAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super21.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              _createClass2(StrikeOutAnnotationElement2, [{
                key: "render",
                value: function render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("strikeoutAnnotation");
                  }
                  this.container.className = "strikeoutAnnotation";
                  return this.container;
                }
              }]);
              return StrikeOutAnnotationElement2;
            }(AnnotationElement);
            var StampAnnotationElement = /* @__PURE__ */ function(_AnnotationElement16) {
              _inherits(StampAnnotationElement2, _AnnotationElement16);
              var _super22 = _createSuper(StampAnnotationElement2);
              function StampAnnotationElement2(parameters) {
                _classCallCheck2(this, StampAnnotationElement2);
                var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                return _super22.call(this, parameters, {
                  isRenderable,
                  ignoreBorder: true
                });
              }
              _createClass2(StampAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "stampAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }]);
              return StampAnnotationElement2;
            }(AnnotationElement);
            var FileAttachmentAnnotationElement = /* @__PURE__ */ function(_AnnotationElement17) {
              _inherits(FileAttachmentAnnotationElement2, _AnnotationElement17);
              var _super23 = _createSuper(FileAttachmentAnnotationElement2);
              function FileAttachmentAnnotationElement2(parameters) {
                var _this13$linkService$e;
                var _this13;
                _classCallCheck2(this, FileAttachmentAnnotationElement2);
                _this13 = _super23.call(this, parameters, {
                  isRenderable: true
                });
                var _this13$data$file = _this13.data.file, filename = _this13$data$file.filename, content = _this13$data$file.content;
                _this13.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                _this13.content = content;
                (_this13$linkService$e = _this13.linkService.eventBus) === null || _this13$linkService$e === void 0 ? void 0 : _this13$linkService$e.dispatch("fileattachmentannotation", {
                  source: _assertThisInitialized(_this13),
                  id: (0, _util2.stringToPDFString)(filename),
                  filename,
                  content
                });
                return _this13;
              }
              _createClass2(FileAttachmentAnnotationElement2, [{
                key: "render",
                value: function render() {
                  this.container.className = "fileAttachmentAnnotation";
                  var trigger = document.createElement("div");
                  trigger.style.height = this.container.style.height;
                  trigger.style.width = this.container.style.width;
                  trigger.addEventListener("dblclick", this._download.bind(this));
                  if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
                    this._createPopup(trigger, this.data);
                  }
                  this.container.appendChild(trigger);
                  return this.container;
                }
              }, {
                key: "_download",
                value: function _download() {
                  var _this$downloadManager;
                  (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
                }
              }]);
              return FileAttachmentAnnotationElement2;
            }(AnnotationElement);
            var AnnotationLayer = /* @__PURE__ */ function() {
              function AnnotationLayer2() {
                _classCallCheck2(this, AnnotationLayer2);
              }
              _createClass2(AnnotationLayer2, null, [{
                key: "render",
                value: function render(parameters) {
                  var sortedAnnotations = [], popupAnnotations = [];
                  var _iterator11 = _createForOfIteratorHelper2(parameters.annotations), _step11;
                  try {
                    for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                      var _data = _step11.value;
                      if (!_data) {
                        continue;
                      }
                      if (_data.annotationType === _util2.AnnotationType.POPUP) {
                        popupAnnotations.push(_data);
                        continue;
                      }
                      sortedAnnotations.push(_data);
                    }
                  } catch (err) {
                    _iterator11.e(err);
                  } finally {
                    _iterator11.f();
                  }
                  if (popupAnnotations.length) {
                    sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);
                  }
                  for (var _i3 = 0, _sortedAnnotations = sortedAnnotations; _i3 < _sortedAnnotations.length; _i3++) {
                    var data = _sortedAnnotations[_i3];
                    var element = AnnotationElementFactory.create({
                      data,
                      layer: parameters.div,
                      page: parameters.page,
                      viewport: parameters.viewport,
                      linkService: parameters.linkService,
                      downloadManager: parameters.downloadManager,
                      imageResourcesPath: parameters.imageResourcesPath || "",
                      renderInteractiveForms: parameters.renderInteractiveForms !== false,
                      svgFactory: new _display_utils2.DOMSVGFactory(),
                      annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                      enableScripting: parameters.enableScripting,
                      hasJSActions: parameters.hasJSActions,
                      mouseState: parameters.mouseState || {
                        isDown: false
                      }
                    });
                    if (element.isRenderable) {
                      var rendered = element.render();
                      if (data.hidden) {
                        rendered.style.visibility = "hidden";
                      }
                      if (Array.isArray(rendered)) {
                        var _iterator12 = _createForOfIteratorHelper2(rendered), _step12;
                        try {
                          for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                            var renderedElement = _step12.value;
                            parameters.div.appendChild(renderedElement);
                          }
                        } catch (err) {
                          _iterator12.e(err);
                        } finally {
                          _iterator12.f();
                        }
                      } else {
                        if (element instanceof PopupAnnotationElement) {
                          parameters.div.prepend(rendered);
                        } else {
                          parameters.div.appendChild(rendered);
                        }
                      }
                    }
                  }
                }
              }, {
                key: "update",
                value: function update(parameters) {
                  var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
                  var _iterator13 = _createForOfIteratorHelper2(parameters.annotations), _step13;
                  try {
                    for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
                      var data = _step13.value;
                      var elements = parameters.div.querySelectorAll('[data-annotation-id="'.concat(data.id, '"]'));
                      if (elements) {
                        elements.forEach(function(element) {
                          element.style.transform = transform;
                        });
                      }
                    }
                  } catch (err) {
                    _iterator13.e(err);
                  } finally {
                    _iterator13.f();
                  }
                  parameters.div.hidden = false;
                }
              }]);
              return AnnotationLayer2;
            }();
            exports2.AnnotationLayer = AnnotationLayer;
          },
          (__unused_webpack_module2, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ColorConverters = void 0;
            function _slicedToArray2(arr, i) {
              return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
            }
            function _nonIterableRest2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _iterableToArrayLimit2(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles2(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            function makeColorComp(n) {
              return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
            }
            var ColorConverters = /* @__PURE__ */ function() {
              function ColorConverters2() {
                _classCallCheck2(this, ColorConverters2);
              }
              _createClass2(ColorConverters2, null, [{
                key: "CMYK_G",
                value: function CMYK_G(_ref) {
                  var _ref2 = _slicedToArray2(_ref, 4), c = _ref2[0], y = _ref2[1], m = _ref2[2], k = _ref2[3];
                  return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                }
              }, {
                key: "G_CMYK",
                value: function G_CMYK(_ref3) {
                  var _ref4 = _slicedToArray2(_ref3, 1), g = _ref4[0];
                  return ["CMYK", 0, 0, 0, 1 - g];
                }
              }, {
                key: "G_RGB",
                value: function G_RGB(_ref5) {
                  var _ref6 = _slicedToArray2(_ref5, 1), g = _ref6[0];
                  return ["RGB", g, g, g];
                }
              }, {
                key: "G_HTML",
                value: function G_HTML(_ref7) {
                  var _ref8 = _slicedToArray2(_ref7, 1), g = _ref8[0];
                  var G = makeColorComp(g);
                  return "#".concat(G).concat(G).concat(G);
                }
              }, {
                key: "RGB_G",
                value: function RGB_G(_ref9) {
                  var _ref10 = _slicedToArray2(_ref9, 3), r = _ref10[0], g = _ref10[1], b = _ref10[2];
                  return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
                }
              }, {
                key: "RGB_HTML",
                value: function RGB_HTML(_ref11) {
                  var _ref122 = _slicedToArray2(_ref11, 3), r = _ref122[0], g = _ref122[1], b = _ref122[2];
                  var R = makeColorComp(r);
                  var G = makeColorComp(g);
                  var B = makeColorComp(b);
                  return "#".concat(R).concat(G).concat(B);
                }
              }, {
                key: "T_HTML",
                value: function T_HTML() {
                  return "#00000000";
                }
              }, {
                key: "CMYK_RGB",
                value: function CMYK_RGB(_ref13) {
                  var _ref14 = _slicedToArray2(_ref13, 4), c = _ref14[0], y = _ref14[1], m = _ref14[2], k = _ref14[3];
                  return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                }
              }, {
                key: "CMYK_HTML",
                value: function CMYK_HTML(components) {
                  return this.RGB_HTML(this.CMYK_RGB(components));
                }
              }, {
                key: "RGB_CMYK",
                value: function RGB_CMYK(_ref15) {
                  var _ref16 = _slicedToArray2(_ref15, 3), r = _ref16[0], g = _ref16[1], b = _ref16[2];
                  var c = 1 - r;
                  var m = 1 - g;
                  var y = 1 - b;
                  var k = Math.min(c, m, y);
                  return ["CMYK", c, m, y, k];
                }
              }]);
              return ColorConverters2;
            }();
            exports2.ColorConverters = ColorConverters;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.renderTextLayer = void 0;
            var _util2 = __w_pdfjs_require__2(4);
            var renderTextLayer = function renderTextLayerClosure() {
              var MAX_TEXT_DIVS_TO_RENDER = 1e5;
              var DEFAULT_FONT_SIZE = 30;
              var DEFAULT_FONT_ASCENT = 0.8;
              var ascentCache = /* @__PURE__ */ new Map();
              var NonWhitespaceRegexp = /\S/;
              function isAllWhitespace(str) {
                return !NonWhitespaceRegexp.test(str);
              }
              function getAscent(fontFamily, ctx) {
                var cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                ctx.save();
                ctx.font = "".concat(DEFAULT_FONT_SIZE, "px ").concat(fontFamily);
                var metrics = ctx.measureText("");
                var ascent = metrics.fontBoundingBoxAscent;
                var descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  ctx.restore();
                  var ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                var pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (var i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (var _i = 0, ii = pixels.length; _i < ii; _i += 4) {
                  if (pixels[_i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(_i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.restore();
                if (ascent) {
                  var _ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, _ratio);
                  return _ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles, ctx) {
                var textDiv = document.createElement("span");
                var textDivProperties = {
                  angle: 0,
                  canvasWidth: 0,
                  isWhitespace: false,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1
                };
                task._textDivs.push(textDiv);
                if (isAllWhitespace(geom.str)) {
                  textDivProperties.isWhitespace = true;
                  task._textDivProperties.set(textDiv, textDivProperties);
                  return;
                }
                var tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                var angle = Math.atan2(tx[1], tx[0]);
                var style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                var fontHeight = Math.hypot(tx[2], tx[3]);
                var fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                var left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                textDiv.style.left = "".concat(left, "px");
                textDiv.style.top = "".concat(top, "px");
                textDiv.style.fontSize = "".concat(fontHeight, "px");
                textDiv.style.fontFamily = style.fontFamily;
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                var shouldScaleText = false;
                if (geom.str.length > 1) {
                  shouldScaleText = true;
                } else if (geom.transform[0] !== geom.transform[3]) {
                  var absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection) {
                  var angleCos = 1, angleSin = 0;
                  if (angle !== 0) {
                    angleCos = Math.cos(angle);
                    angleSin = Math.sin(angle);
                  }
                  var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  var divHeight = fontHeight;
                  var m, b;
                  if (angle !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                var textDivs = task._textDivs;
                var capability = task._capability;
                var textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (var i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function findPositiveMin(ts, offset, count) {
                var result = 0;
                for (var i = 0; i < count; i++) {
                  var t = ts[offset++];
                  if (t > 0) {
                    result = result ? Math.min(t, result) : t;
                  }
                }
                return result;
              }
              function expand(task) {
                var bounds = task._bounds;
                var viewport = task._viewport;
                var expanded = expandBounds(viewport.width, viewport.height, bounds);
                var _loop = function _loop2(i2) {
                  var div = bounds[i2].div;
                  var divProperties = task._textDivProperties.get(div);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i2].left - expanded[i2].left;
                    divProperties.paddingTop = bounds[i2].top - expanded[i2].top;
                    divProperties.paddingRight = expanded[i2].right - bounds[i2].right;
                    divProperties.paddingBottom = expanded[i2].bottom - bounds[i2].bottom;
                    task._textDivProperties.set(div, divProperties);
                    return "continue";
                  }
                  var e = expanded[i2], b = bounds[i2];
                  var m = b.m, c = m[0], s = m[1];
                  var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  var ts = new Float64Array(64);
                  points.forEach(function(p, j) {
                    var t = _util2.Util.applyTransform(p, m);
                    ts[j + 0] = c && (e.left - t[0]) / c;
                    ts[j + 4] = s && (e.top - t[1]) / s;
                    ts[j + 8] = c && (e.right - t[0]) / c;
                    ts[j + 12] = s && (e.bottom - t[1]) / s;
                    ts[j + 16] = s && (e.left - t[0]) / -s;
                    ts[j + 20] = c && (e.top - t[1]) / c;
                    ts[j + 24] = s && (e.right - t[0]) / -s;
                    ts[j + 28] = c && (e.bottom - t[1]) / c;
                    ts[j + 32] = c && (e.left - t[0]) / -c;
                    ts[j + 36] = s && (e.top - t[1]) / -s;
                    ts[j + 40] = c && (e.right - t[0]) / -c;
                    ts[j + 44] = s && (e.bottom - t[1]) / -s;
                    ts[j + 48] = s && (e.left - t[0]) / s;
                    ts[j + 52] = c && (e.top - t[1]) / -c;
                    ts[j + 56] = s && (e.right - t[0]) / s;
                    ts[j + 60] = c && (e.bottom - t[1]) / -c;
                  });
                  var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div, divProperties);
                };
                for (var i = 0; i < expanded.length; i++) {
                  var _ret = _loop(i);
                  if (_ret === "continue")
                    continue;
                }
              }
              function expandBounds(width, height, boxes) {
                var bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                var expanded = new Array(boxes.length);
                bounds.forEach(function(b) {
                  var i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                });
                boxes.map(function(box, i) {
                  var e = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width - e.right;
                  b.x2 = box.bottom;
                  b.y2 = width - e.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                bounds.forEach(function(b) {
                  var i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                });
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                var fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                var horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                bounds.forEach(function(boundary) {
                  var i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  var j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  var horizonPart, affectedBoundary;
                  var q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    var xNew = void 0;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  var changedHorizon = [];
                  var lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    var used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
                });
                horizon.forEach(function(horizonPart) {
                  var affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                });
              }
              function TextLayerRenderTask(_ref) {
                var _globalThis$FontInspe, _this = this;
                var textContent = _ref.textContent, textContentStream = _ref.textContentStream, container = _ref.container, viewport = _ref.viewport, textDivs = _ref.textDivs, textContentItemsStr = _ref.textContentItemsStr, enhanceTextSelection = _ref.enhanceTextSelection;
                this._textContent = textContent;
                this._textContentStream = textContentStream;
                this._container = container;
                this._document = container.ownerDocument;
                this._viewport = viewport;
                this._textDivs = textDivs || [];
                this._textContentItemsStr = textContentItemsStr || [];
                this._enhanceTextSelection = !!enhanceTextSelection;
                this._fontInspectorEnabled = !!((_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled);
                this._reader = null;
                this._layoutTextLastFontSize = null;
                this._layoutTextLastFontFamily = null;
                this._layoutTextCtx = null;
                this._textDivProperties = /* @__PURE__ */ new WeakMap();
                this._renderingDone = false;
                this._canceled = false;
                this._capability = (0, _util2.createPromiseCapability)();
                this._renderTimer = null;
                this._bounds = [];
                this._capability.promise["finally"](function() {
                  if (_this._layoutTextCtx) {
                    _this._layoutTextCtx.canvas.width = 0;
                    _this._layoutTextCtx.canvas.height = 0;
                    _this._layoutTextCtx = null;
                  }
                })["catch"](function() {
                });
              }
              TextLayerRenderTask.prototype = {
                get promise() {
                  return this._capability.promise;
                },
                cancel: function TextLayer_cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled."));
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                },
                _processItems: function _processItems(items, styleCache) {
                  for (var i = 0, len = items.length; i < len; i++) {
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache, this._layoutTextCtx);
                  }
                },
                _layoutText: function _layoutText(textDiv) {
                  var textDivProperties = this._textDivProperties.get(textDiv);
                  if (textDivProperties.isWhitespace) {
                    return;
                  }
                  var transform = "";
                  if (textDivProperties.canvasWidth !== 0) {
                    var _textDiv$style = textDiv.style, fontSize = _textDiv$style.fontSize, fontFamily = _textDiv$style.fontFamily;
                    if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily);
                      this._layoutTextLastFontSize = fontSize;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent), width = _this$_layoutTextCtx$.width;
                    if (width > 0) {
                      textDivProperties.scale = textDivProperties.canvasWidth / width;
                      transform = "scaleX(".concat(textDivProperties.scale, ")");
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
                  }
                  if (transform.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform;
                    }
                    textDiv.style.transform = transform;
                  }
                  this._textDivProperties.set(textDiv, textDivProperties);
                  this._container.appendChild(textDiv);
                },
                _render: function TextLayer_render(timeout) {
                  var _this2 = this;
                  var capability = (0, _util2.createPromiseCapability)();
                  var styleCache = /* @__PURE__ */ Object.create(null);
                  var canvas = this._document.createElement("canvas");
                  canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                  canvas.mozOpaque = true;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    var textItems = this._textContent.items;
                    var textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    var pump = function pump2() {
                      _this2._reader.read().then(function(_ref2) {
                        var value = _ref2.value, done = _ref2.done;
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        _this2._processItems(value.items, styleCache);
                        pump2();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(function() {
                    styleCache = null;
                    if (!timeout) {
                      render(_this2);
                    } else {
                      _this2._renderTimer = setTimeout(function() {
                        render(_this2);
                        _this2._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                },
                expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  var transformBuf = [], paddingBuf = [];
                  for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
                    var div = this._textDivs[i];
                    var divProps = this._textDivProperties.get(div);
                    if (divProps.isWhitespace) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push("".concat(divProps.paddingTop, "px"));
                        transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)"));
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px"));
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push("".concat(divProps.paddingBottom, "px"));
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px"));
                        transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)"));
                      } else {
                        paddingBuf.push(0);
                      }
                      div.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div.style.padding = null;
                      div.style.transform = divProps.originalTransform;
                    }
                  }
                }
              };
              function renderTextLayer2(renderParameters) {
                var task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
              return renderTextLayer2;
            }();
            exports2.renderTextLayer = renderTextLayer;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SVGGraphics = void 0;
            var _util2 = __w_pdfjs_require__2(4);
            var _display_utils2 = __w_pdfjs_require__2(1);
            var _is_node2 = __w_pdfjs_require__2(6);
            function _toConsumableArray2(arr) {
              return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
            }
            function _nonIterableSpread2() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _iterableToArray2(iter) {
              if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                return Array.from(iter);
            }
            function _arrayWithoutHoles2(arr) {
              if (Array.isArray(arr))
                return _arrayLikeToArray2(arr);
            }
            function _slicedToArray2(arr, i) {
              return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
            }
            function _nonIterableRest2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _iterableToArrayLimit2(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles2(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _createForOfIteratorHelper2(o, allowArrayLike) {
              var it;
              if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e2) {
                    throw _e2;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = o[Symbol.iterator]();
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e3) {
                didErr = true;
                err = _e3;
              }, f: function f() {
                try {
                  if (!normalCompletion && it["return"] != null)
                    it["return"]();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var SVGGraphics = function SVGGraphics2() {
              throw new Error("Not implemented: SVGGraphics");
            };
            exports2.SVGGraphics = SVGGraphics;
            {
              var opListToTree = function opListToTree2(opList) {
                var opTree = [];
                var tmp = [];
                var _iterator = _createForOfIteratorHelper2(opList), _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var opListElement = _step.value;
                    if (opListElement.fn === "save") {
                      opTree.push({
                        fnId: 92,
                        fn: "group",
                        items: []
                      });
                      tmp.push(opTree);
                      opTree = opTree[opTree.length - 1].items;
                      continue;
                    }
                    if (opListElement.fn === "restore") {
                      opTree = tmp.pop();
                    } else {
                      opTree.push(opListElement);
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                return opTree;
              };
              var pf = function pf2(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                var s = value.toFixed(10);
                var i = s.length - 1;
                if (s[i] !== "0") {
                  return s;
                }
                do {
                  i--;
                } while (s[i] === "0");
                return s.substring(0, s[i] === "." ? i : i + 1);
              };
              var pm = function pm2(m) {
                if (m[4] === 0 && m[5] === 0) {
                  if (m[1] === 0 && m[2] === 0) {
                    if (m[0] === 1 && m[3] === 1) {
                      return "";
                    }
                    return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
                  }
                  if (m[0] === m[3] && m[1] === -m[2]) {
                    var a = Math.acos(m[0]) * 180 / Math.PI;
                    return "rotate(".concat(pf(a), ")");
                  }
                } else {
                  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                    return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
                  }
                }
                return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
              };
              var SVG_DEFAULTS = {
                fontStyle: "normal",
                fontWeight: "normal",
                fillColor: "#000000"
              };
              var XML_NS = "http://www.w3.org/XML/1998/namespace";
              var XLINK_NS = "http://www.w3.org/1999/xlink";
              var LINE_CAP_STYLES = ["butt", "round", "square"];
              var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              var convertImgDataToPng = function() {
                var PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                var CHUNK_WRAPPER_SIZE = 12;
                var crcTable = new Int32Array(256);
                for (var i = 0; i < 256; i++) {
                  var c = i;
                  for (var h = 0; h < 8; h++) {
                    if (c & 1) {
                      c = 3988292384 ^ c >> 1 & 2147483647;
                    } else {
                      c = c >> 1 & 2147483647;
                    }
                  }
                  crcTable[i] = c;
                }
                function crc32(data, start, end) {
                  var crc = -1;
                  for (var _i = start; _i < end; _i++) {
                    var a = (crc ^ data[_i]) & 255;
                    var b = crcTable[a];
                    crc = crc >>> 8 ^ b;
                  }
                  return crc ^ -1;
                }
                function writePngChunk(type, body, data, offset) {
                  var p = offset;
                  var len = body.length;
                  data[p] = len >> 24 & 255;
                  data[p + 1] = len >> 16 & 255;
                  data[p + 2] = len >> 8 & 255;
                  data[p + 3] = len & 255;
                  p += 4;
                  data[p] = type.charCodeAt(0) & 255;
                  data[p + 1] = type.charCodeAt(1) & 255;
                  data[p + 2] = type.charCodeAt(2) & 255;
                  data[p + 3] = type.charCodeAt(3) & 255;
                  p += 4;
                  data.set(body, p);
                  p += body.length;
                  var crc = crc32(data, offset + 4, p);
                  data[p] = crc >> 24 & 255;
                  data[p + 1] = crc >> 16 & 255;
                  data[p + 2] = crc >> 8 & 255;
                  data[p + 3] = crc & 255;
                }
                function adler32(data, start, end) {
                  var a = 1;
                  var b = 0;
                  for (var _i2 = start; _i2 < end; ++_i2) {
                    a = (a + (data[_i2] & 255)) % 65521;
                    b = (b + a) % 65521;
                  }
                  return b << 16 | a;
                }
                function deflateSync(literals) {
                  if (!_is_node2.isNodeJS) {
                    return deflateSyncUncompressed(literals);
                  }
                  try {
                    var input;
                    if (parseInt(process.versions.node) >= 8) {
                      input = literals;
                    } else {
                      input = Buffer.from(literals);
                    }
                    var output = require_zlib().deflateSync(input, {
                      level: 9
                    });
                    return output instanceof Uint8Array ? output : new Uint8Array(output);
                  } catch (e) {
                    (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                  }
                  return deflateSyncUncompressed(literals);
                }
                function deflateSyncUncompressed(literals) {
                  var len = literals.length;
                  var maxBlockLength = 65535;
                  var deflateBlocks = Math.ceil(len / maxBlockLength);
                  var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                  var pi = 0;
                  idat[pi++] = 120;
                  idat[pi++] = 156;
                  var pos = 0;
                  while (len > maxBlockLength) {
                    idat[pi++] = 0;
                    idat[pi++] = 255;
                    idat[pi++] = 255;
                    idat[pi++] = 0;
                    idat[pi++] = 0;
                    idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                    pi += maxBlockLength;
                    pos += maxBlockLength;
                    len -= maxBlockLength;
                  }
                  idat[pi++] = 1;
                  idat[pi++] = len & 255;
                  idat[pi++] = len >> 8 & 255;
                  idat[pi++] = ~len & 65535 & 255;
                  idat[pi++] = (~len & 65535) >> 8 & 255;
                  idat.set(literals.subarray(pos), pi);
                  pi += literals.length - pos;
                  var adler = adler32(literals, 0, literals.length);
                  idat[pi++] = adler >> 24 & 255;
                  idat[pi++] = adler >> 16 & 255;
                  idat[pi++] = adler >> 8 & 255;
                  idat[pi++] = adler & 255;
                  return idat;
                }
                function encode(imgData, kind, forceDataSchema, isMask) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var bitDepth, colorType, lineSize;
                  var bytes = imgData.data;
                  switch (kind) {
                    case _util2.ImageKind.GRAYSCALE_1BPP:
                      colorType = 0;
                      bitDepth = 1;
                      lineSize = width + 7 >> 3;
                      break;
                    case _util2.ImageKind.RGB_24BPP:
                      colorType = 2;
                      bitDepth = 8;
                      lineSize = width * 3;
                      break;
                    case _util2.ImageKind.RGBA_32BPP:
                      colorType = 6;
                      bitDepth = 8;
                      lineSize = width * 4;
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  var literals = new Uint8Array((1 + lineSize) * height);
                  var offsetLiterals = 0, offsetBytes = 0;
                  for (var y = 0; y < height; ++y) {
                    literals[offsetLiterals++] = 0;
                    literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                    offsetBytes += lineSize;
                    offsetLiterals += lineSize;
                  }
                  if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                    offsetLiterals = 0;
                    for (var _y = 0; _y < height; _y++) {
                      offsetLiterals++;
                      for (var _i3 = 0; _i3 < lineSize; _i3++) {
                        literals[offsetLiterals++] ^= 255;
                      }
                    }
                  }
                  var ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                  var idat = deflateSync(literals);
                  var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                  var data = new Uint8Array(pngLength);
                  var offset = 0;
                  data.set(PNG_HEADER, offset);
                  offset += PNG_HEADER.length;
                  writePngChunk("IHDR", ihdr, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                  writePngChunk("IDATA", idat, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + idat.length;
                  writePngChunk("IEND", new Uint8Array(0), data, offset);
                  return (0, _util2.createObjectURL)(data, "image/png", forceDataSchema);
                }
                return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                  var kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                  return encode(imgData, kind, forceDataSchema, isMask);
                };
              }();
              var SVGExtraState = /* @__PURE__ */ function() {
                function SVGExtraState2() {
                  _classCallCheck2(this, SVGExtraState2);
                  this.fontSizeScale = 1;
                  this.fontWeight = SVG_DEFAULTS.fontWeight;
                  this.fontSize = 0;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textMatrixScale = 1;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                  this.fillColor = SVG_DEFAULTS.fillColor;
                  this.strokeColor = "#000000";
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.lineJoin = "";
                  this.lineCap = "";
                  this.miterLimit = 0;
                  this.dashArray = [];
                  this.dashPhase = 0;
                  this.dependencies = [];
                  this.activeClipUrl = null;
                  this.clipGroup = null;
                  this.maskId = "";
                }
                _createClass2(SVGExtraState2, [{
                  key: "clone",
                  value: function clone() {
                    return Object.create(this);
                  }
                }, {
                  key: "setCurrentPoint",
                  value: function setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                }]);
                return SVGExtraState2;
              }();
              var clipCount = 0;
              var maskCount = 0;
              var shadingCount = 0;
              exports2.SVGGraphics = SVGGraphics = /* @__PURE__ */ function() {
                function SVGGraphics2(commonObjs, objs) {
                  var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  _classCallCheck2(this, SVGGraphics2);
                  this.svgFactory = new _display_utils2.DOMSVGFactory();
                  this.current = new SVGExtraState();
                  this.transformMatrix = _util2.IDENTITY_MATRIX;
                  this.transformStack = [];
                  this.extraStack = [];
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.embedFonts = false;
                  this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                  this.cssStyle = null;
                  this.forceDataSchema = !!forceDataSchema;
                  this._operatorIdMapping = [];
                  for (var op in _util2.OPS) {
                    this._operatorIdMapping[_util2.OPS[op]] = op;
                  }
                }
                _createClass2(SVGGraphics2, [{
                  key: "save",
                  value: function save() {
                    this.transformStack.push(this.transformMatrix);
                    var old = this.current;
                    this.extraStack.push(old);
                    this.current = old.clone();
                  }
                }, {
                  key: "restore",
                  value: function restore() {
                    this.transformMatrix = this.transformStack.pop();
                    this.current = this.extraStack.pop();
                    this.pendingClip = null;
                    this.tgrp = null;
                  }
                }, {
                  key: "group",
                  value: function group(items) {
                    this.save();
                    this.executeOpTree(items);
                    this.restore();
                  }
                }, {
                  key: "loadDependencies",
                  value: function loadDependencies(operatorList) {
                    var _this = this;
                    var fnArray = operatorList.fnArray;
                    var argsArray = operatorList.argsArray;
                    for (var i = 0, ii = fnArray.length; i < ii; i++) {
                      if (fnArray[i] !== _util2.OPS.dependency) {
                        continue;
                      }
                      var _iterator2 = _createForOfIteratorHelper2(argsArray[i]), _step2;
                      try {
                        var _loop = function _loop2() {
                          var obj = _step2.value;
                          var objsPool = obj.startsWith("g_") ? _this.commonObjs : _this.objs;
                          var promise = new Promise(function(resolve) {
                            objsPool.get(obj, resolve);
                          });
                          _this.current.dependencies.push(promise);
                        };
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                          _loop();
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                    }
                    return Promise.all(this.current.dependencies);
                  }
                }, {
                  key: "transform",
                  value: function transform(a, b, c, d, e, f) {
                    var transformMatrix = [a, b, c, d, e, f];
                    this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                    this.tgrp = null;
                  }
                }, {
                  key: "getSVG",
                  value: function getSVG(operatorList, viewport) {
                    var _this2 = this;
                    this.viewport = viewport;
                    var svgElement = this._initialize(viewport);
                    return this.loadDependencies(operatorList).then(function() {
                      _this2.transformMatrix = _util2.IDENTITY_MATRIX;
                      _this2.executeOpTree(_this2.convertOpList(operatorList));
                      return svgElement;
                    });
                  }
                }, {
                  key: "convertOpList",
                  value: function convertOpList(operatorList) {
                    var operatorIdMapping = this._operatorIdMapping;
                    var argsArray = operatorList.argsArray;
                    var fnArray = operatorList.fnArray;
                    var opList = [];
                    for (var i = 0, ii = fnArray.length; i < ii; i++) {
                      var fnId = fnArray[i];
                      opList.push({
                        fnId,
                        fn: operatorIdMapping[fnId],
                        args: argsArray[i]
                      });
                    }
                    return opListToTree(opList);
                  }
                }, {
                  key: "executeOpTree",
                  value: function executeOpTree(opTree) {
                    var _iterator3 = _createForOfIteratorHelper2(opTree), _step3;
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                        var opTreeElement = _step3.value;
                        var fn = opTreeElement.fn;
                        var fnId = opTreeElement.fnId;
                        var args = opTreeElement.args;
                        switch (fnId | 0) {
                          case _util2.OPS.beginText:
                            this.beginText();
                            break;
                          case _util2.OPS.dependency:
                            break;
                          case _util2.OPS.setLeading:
                            this.setLeading(args);
                            break;
                          case _util2.OPS.setLeadingMoveText:
                            this.setLeadingMoveText(args[0], args[1]);
                            break;
                          case _util2.OPS.setFont:
                            this.setFont(args);
                            break;
                          case _util2.OPS.showText:
                            this.showText(args[0]);
                            break;
                          case _util2.OPS.showSpacedText:
                            this.showText(args[0]);
                            break;
                          case _util2.OPS.endText:
                            this.endText();
                            break;
                          case _util2.OPS.moveText:
                            this.moveText(args[0], args[1]);
                            break;
                          case _util2.OPS.setCharSpacing:
                            this.setCharSpacing(args[0]);
                            break;
                          case _util2.OPS.setWordSpacing:
                            this.setWordSpacing(args[0]);
                            break;
                          case _util2.OPS.setHScale:
                            this.setHScale(args[0]);
                            break;
                          case _util2.OPS.setTextMatrix:
                            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                            break;
                          case _util2.OPS.setTextRise:
                            this.setTextRise(args[0]);
                            break;
                          case _util2.OPS.setTextRenderingMode:
                            this.setTextRenderingMode(args[0]);
                            break;
                          case _util2.OPS.setLineWidth:
                            this.setLineWidth(args[0]);
                            break;
                          case _util2.OPS.setLineJoin:
                            this.setLineJoin(args[0]);
                            break;
                          case _util2.OPS.setLineCap:
                            this.setLineCap(args[0]);
                            break;
                          case _util2.OPS.setMiterLimit:
                            this.setMiterLimit(args[0]);
                            break;
                          case _util2.OPS.setFillRGBColor:
                            this.setFillRGBColor(args[0], args[1], args[2]);
                            break;
                          case _util2.OPS.setStrokeRGBColor:
                            this.setStrokeRGBColor(args[0], args[1], args[2]);
                            break;
                          case _util2.OPS.setStrokeColorN:
                            this.setStrokeColorN(args);
                            break;
                          case _util2.OPS.setFillColorN:
                            this.setFillColorN(args);
                            break;
                          case _util2.OPS.shadingFill:
                            this.shadingFill(args[0]);
                            break;
                          case _util2.OPS.setDash:
                            this.setDash(args[0], args[1]);
                            break;
                          case _util2.OPS.setRenderingIntent:
                            this.setRenderingIntent(args[0]);
                            break;
                          case _util2.OPS.setFlatness:
                            this.setFlatness(args[0]);
                            break;
                          case _util2.OPS.setGState:
                            this.setGState(args[0]);
                            break;
                          case _util2.OPS.fill:
                            this.fill();
                            break;
                          case _util2.OPS.eoFill:
                            this.eoFill();
                            break;
                          case _util2.OPS.stroke:
                            this.stroke();
                            break;
                          case _util2.OPS.fillStroke:
                            this.fillStroke();
                            break;
                          case _util2.OPS.eoFillStroke:
                            this.eoFillStroke();
                            break;
                          case _util2.OPS.clip:
                            this.clip("nonzero");
                            break;
                          case _util2.OPS.eoClip:
                            this.clip("evenodd");
                            break;
                          case _util2.OPS.paintSolidColorImageMask:
                            this.paintSolidColorImageMask();
                            break;
                          case _util2.OPS.paintImageXObject:
                            this.paintImageXObject(args[0]);
                            break;
                          case _util2.OPS.paintInlineImageXObject:
                            this.paintInlineImageXObject(args[0]);
                            break;
                          case _util2.OPS.paintImageMaskXObject:
                            this.paintImageMaskXObject(args[0]);
                            break;
                          case _util2.OPS.paintFormXObjectBegin:
                            this.paintFormXObjectBegin(args[0], args[1]);
                            break;
                          case _util2.OPS.paintFormXObjectEnd:
                            this.paintFormXObjectEnd();
                            break;
                          case _util2.OPS.closePath:
                            this.closePath();
                            break;
                          case _util2.OPS.closeStroke:
                            this.closeStroke();
                            break;
                          case _util2.OPS.closeFillStroke:
                            this.closeFillStroke();
                            break;
                          case _util2.OPS.closeEOFillStroke:
                            this.closeEOFillStroke();
                            break;
                          case _util2.OPS.nextLine:
                            this.nextLine();
                            break;
                          case _util2.OPS.transform:
                            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                            break;
                          case _util2.OPS.constructPath:
                            this.constructPath(args[0], args[1]);
                            break;
                          case _util2.OPS.endPath:
                            this.endPath();
                            break;
                          case 92:
                            this.group(opTreeElement.items);
                            break;
                          default:
                            (0, _util2.warn)("Unimplemented operator ".concat(fn));
                            break;
                        }
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                  }
                }, {
                  key: "setWordSpacing",
                  value: function setWordSpacing(wordSpacing) {
                    this.current.wordSpacing = wordSpacing;
                  }
                }, {
                  key: "setCharSpacing",
                  value: function setCharSpacing(charSpacing) {
                    this.current.charSpacing = charSpacing;
                  }
                }, {
                  key: "nextLine",
                  value: function nextLine() {
                    this.moveText(0, this.current.leading);
                  }
                }, {
                  key: "setTextMatrix",
                  value: function setTextMatrix(a, b, c, d, e, f) {
                    var current = this.current;
                    current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                    current.textMatrixScale = Math.hypot(a, b);
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtElement.appendChild(current.tspan);
                  }
                }, {
                  key: "beginText",
                  value: function beginText() {
                    var current = this.current;
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.textMatrix = _util2.IDENTITY_MATRIX;
                    current.lineMatrix = _util2.IDENTITY_MATRIX;
                    current.textMatrixScale = 1;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtgrp = this.svgFactory.createElement("svg:g");
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                }, {
                  key: "moveText",
                  value: function moveText(x, y) {
                    var current = this.current;
                    current.x = current.lineX += x;
                    current.y = current.lineY += y;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                }, {
                  key: "showText",
                  value: function showText(glyphs) {
                    var current = this.current;
                    var font = current.font;
                    var fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return;
                    }
                    var fontSizeScale = current.fontSizeScale;
                    var charSpacing = current.charSpacing;
                    var wordSpacing = current.wordSpacing;
                    var fontDirection = current.fontDirection;
                    var textHScale = current.textHScale * fontDirection;
                    var vertical = font.vertical;
                    var spacingDir = vertical ? 1 : -1;
                    var defaultVMetrics = font.defaultVMetrics;
                    var widthAdvanceScale = fontSize * current.fontMatrix[0];
                    var x = 0;
                    var _iterator4 = _createForOfIteratorHelper2(glyphs), _step4;
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                        var glyph = _step4.value;
                        if (glyph === null) {
                          x += fontDirection * wordSpacing;
                          continue;
                        } else if ((0, _util2.isNum)(glyph)) {
                          x += spacingDir * glyph * fontSize / 1e3;
                          continue;
                        }
                        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                        var character = glyph.fontChar;
                        var scaledX = void 0, scaledY = void 0;
                        var width = glyph.width;
                        if (vertical) {
                          var vx = void 0;
                          var vmetric = glyph.vmetric || defaultVMetrics;
                          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                          vx = -vx * widthAdvanceScale;
                          var vy = vmetric[2] * widthAdvanceScale;
                          width = vmetric ? -vmetric[0] : width;
                          scaledX = vx / fontSizeScale;
                          scaledY = (x + vy) / fontSizeScale;
                        } else {
                          scaledX = x / fontSizeScale;
                          scaledY = 0;
                        }
                        if (glyph.isInFont || font.missingFile) {
                          current.xcoords.push(current.x + scaledX);
                          if (vertical) {
                            current.ycoords.push(-current.y + scaledY);
                          }
                          current.tspan.textContent += character;
                        } else {
                        }
                        var charWidth = void 0;
                        if (vertical) {
                          charWidth = width * widthAdvanceScale - spacing * fontDirection;
                        } else {
                          charWidth = width * widthAdvanceScale + spacing * fontDirection;
                        }
                        x += charWidth;
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                    if (vertical) {
                      current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                    } else {
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                      current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                    }
                    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                      current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                    }
                    var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                        current.tspan.setAttributeNS(null, "fill", current.fillColor);
                      }
                      if (current.fillAlpha < 1) {
                        current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      }
                    } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                      current.tspan.setAttributeNS(null, "fill", "transparent");
                    } else {
                      current.tspan.setAttributeNS(null, "fill", "none");
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      var lineWidthScale = 1 / (current.textMatrixScale || 1);
                      this._setStrokeAttributes(current.tspan, lineWidthScale);
                    }
                    var textMatrix = current.textMatrix;
                    if (current.textRise !== 0) {
                      textMatrix = textMatrix.slice();
                      textMatrix[5] += current.textRise;
                    }
                    current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
                    current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                    current.txtElement.appendChild(current.tspan);
                    current.txtgrp.appendChild(current.txtElement);
                    this._ensureTransformGroup().appendChild(current.txtElement);
                  }
                }, {
                  key: "setLeadingMoveText",
                  value: function setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }
                }, {
                  key: "addFontStyle",
                  value: function addFontStyle(fontObj) {
                    if (!fontObj.data) {
                      throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                    }
                    if (!this.cssStyle) {
                      this.cssStyle = this.svgFactory.createElement("svg:style");
                      this.cssStyle.setAttributeNS(null, "type", "text/css");
                      this.defs.appendChild(this.cssStyle);
                    }
                    var url = (0, _util2.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                    this.cssStyle.textContent += '@font-face { font-family: "'.concat(fontObj.loadedName, '";') + " src: url(".concat(url, "); }\n");
                  }
                }, {
                  key: "setFont",
                  value: function setFont(details) {
                    var current = this.current;
                    var fontObj = this.commonObjs.get(details[0]);
                    var size = details[1];
                    current.font = fontObj;
                    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                      this.addFontStyle(fontObj);
                      this.embeddedFonts[fontObj.loadedName] = fontObj;
                    }
                    current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    var bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    var italic = fontObj.italic ? "italic" : "normal";
                    if (size < 0) {
                      size = -size;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    current.fontSize = size;
                    current.fontFamily = fontObj.loadedName;
                    current.fontWeight = bold;
                    current.fontStyle = italic;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                }, {
                  key: "endText",
                  value: function endText() {
                    var _current$txtElement;
                    var current = this.current;
                    if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
                      current.element = current.txtElement;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                }, {
                  key: "setLineWidth",
                  value: function setLineWidth(width) {
                    if (width > 0) {
                      this.current.lineWidth = width;
                    }
                  }
                }, {
                  key: "setLineCap",
                  value: function setLineCap(style) {
                    this.current.lineCap = LINE_CAP_STYLES[style];
                  }
                }, {
                  key: "setLineJoin",
                  value: function setLineJoin(style) {
                    this.current.lineJoin = LINE_JOIN_STYLES[style];
                  }
                }, {
                  key: "setMiterLimit",
                  value: function setMiterLimit(limit) {
                    this.current.miterLimit = limit;
                  }
                }, {
                  key: "setStrokeAlpha",
                  value: function setStrokeAlpha(strokeAlpha) {
                    this.current.strokeAlpha = strokeAlpha;
                  }
                }, {
                  key: "setStrokeRGBColor",
                  value: function setStrokeRGBColor(r, g, b) {
                    this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                  }
                }, {
                  key: "setFillAlpha",
                  value: function setFillAlpha(fillAlpha) {
                    this.current.fillAlpha = fillAlpha;
                  }
                }, {
                  key: "setFillRGBColor",
                  value: function setFillRGBColor(r, g, b) {
                    this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                    this.current.tspan = this.svgFactory.createElement("svg:tspan");
                    this.current.xcoords = [];
                    this.current.ycoords = [];
                  }
                }, {
                  key: "setStrokeColorN",
                  value: function setStrokeColorN(args) {
                    this.current.strokeColor = this._makeColorN_Pattern(args);
                  }
                }, {
                  key: "setFillColorN",
                  value: function setFillColorN(args) {
                    this.current.fillColor = this._makeColorN_Pattern(args);
                  }
                }, {
                  key: "shadingFill",
                  value: function shadingFill(args) {
                    var width = this.viewport.width;
                    var height = this.viewport.height;
                    var inv = _util2.Util.inverseTransform(this.transformMatrix);
                    var bl = _util2.Util.applyTransform([0, 0], inv);
                    var br = _util2.Util.applyTransform([0, height], inv);
                    var ul = _util2.Util.applyTransform([width, 0], inv);
                    var ur = _util2.Util.applyTransform([width, height], inv);
                    var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    var rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", x0);
                    rect.setAttributeNS(null, "y", y0);
                    rect.setAttributeNS(null, "width", x1 - x0);
                    rect.setAttributeNS(null, "height", y1 - y0);
                    rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                    if (this.current.fillAlpha < 1) {
                      rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                    }
                    this._ensureTransformGroup().appendChild(rect);
                  }
                }, {
                  key: "_makeColorN_Pattern",
                  value: function _makeColorN_Pattern(args) {
                    if (args[0] === "TilingPattern") {
                      return this._makeTilingPattern(args);
                    }
                    return this._makeShadingPattern(args);
                  }
                }, {
                  key: "_makeTilingPattern",
                  value: function _makeTilingPattern(args) {
                    var color = args[1];
                    var operatorList = args[2];
                    var matrix = args[3] || _util2.IDENTITY_MATRIX;
                    var _args$ = _slicedToArray2(args[4], 4), x0 = _args$[0], y0 = _args$[1], x1 = _args$[2], y1 = _args$[3];
                    var xstep = args[5];
                    var ystep = args[6];
                    var paintType = args[7];
                    var tilingId = "shading".concat(shadingCount++);
                    var _Util$applyTransform = _util2.Util.applyTransform([x0, y0], matrix), _Util$applyTransform2 = _slicedToArray2(_Util$applyTransform, 2), tx0 = _Util$applyTransform2[0], ty0 = _Util$applyTransform2[1];
                    var _Util$applyTransform3 = _util2.Util.applyTransform([x1, y1], matrix), _Util$applyTransform4 = _slicedToArray2(_Util$applyTransform3, 2), tx1 = _Util$applyTransform4[0], ty1 = _Util$applyTransform4[1];
                    var _Util$singularValueDe = _util2.Util.singularValueDecompose2dScale(matrix), _Util$singularValueDe2 = _slicedToArray2(_Util$singularValueDe, 2), xscale = _Util$singularValueDe2[0], yscale = _Util$singularValueDe2[1];
                    var txstep = xstep * xscale;
                    var tystep = ystep * yscale;
                    var tiling = this.svgFactory.createElement("svg:pattern");
                    tiling.setAttributeNS(null, "id", tilingId);
                    tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                    tiling.setAttributeNS(null, "width", txstep);
                    tiling.setAttributeNS(null, "height", tystep);
                    tiling.setAttributeNS(null, "x", "".concat(tx0));
                    tiling.setAttributeNS(null, "y", "".concat(ty0));
                    var svg = this.svg;
                    var transformMatrix = this.transformMatrix;
                    var fillColor = this.current.fillColor;
                    var strokeColor = this.current.strokeColor;
                    var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                    this.svg = bbox;
                    this.transformMatrix = matrix;
                    if (paintType === 2) {
                      var cssColor = _util2.Util.makeHexColor.apply(_util2.Util, _toConsumableArray2(color));
                      this.current.fillColor = cssColor;
                      this.current.strokeColor = cssColor;
                    }
                    this.executeOpTree(this.convertOpList(operatorList));
                    this.svg = svg;
                    this.transformMatrix = transformMatrix;
                    this.current.fillColor = fillColor;
                    this.current.strokeColor = strokeColor;
                    tiling.appendChild(bbox.childNodes[0]);
                    this.defs.appendChild(tiling);
                    return "url(#".concat(tilingId, ")");
                  }
                }, {
                  key: "_makeShadingPattern",
                  value: function _makeShadingPattern(args) {
                    switch (args[0]) {
                      case "RadialAxial":
                        var shadingId = "shading".concat(shadingCount++);
                        var colorStops = args[3];
                        var gradient;
                        switch (args[1]) {
                          case "axial":
                            var point0 = args[4];
                            var point1 = args[5];
                            gradient = this.svgFactory.createElement("svg:linearGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "x1", point0[0]);
                            gradient.setAttributeNS(null, "y1", point0[1]);
                            gradient.setAttributeNS(null, "x2", point1[0]);
                            gradient.setAttributeNS(null, "y2", point1[1]);
                            break;
                          case "radial":
                            var focalPoint = args[4];
                            var circlePoint = args[5];
                            var focalRadius = args[6];
                            var circleRadius = args[7];
                            gradient = this.svgFactory.createElement("svg:radialGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "cx", circlePoint[0]);
                            gradient.setAttributeNS(null, "cy", circlePoint[1]);
                            gradient.setAttributeNS(null, "r", circleRadius);
                            gradient.setAttributeNS(null, "fx", focalPoint[0]);
                            gradient.setAttributeNS(null, "fy", focalPoint[1]);
                            gradient.setAttributeNS(null, "fr", focalRadius);
                            break;
                          default:
                            throw new Error("Unknown RadialAxial type: ".concat(args[1]));
                        }
                        var _iterator5 = _createForOfIteratorHelper2(colorStops), _step5;
                        try {
                          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                            var colorStop = _step5.value;
                            var stop = this.svgFactory.createElement("svg:stop");
                            stop.setAttributeNS(null, "offset", colorStop[0]);
                            stop.setAttributeNS(null, "stop-color", colorStop[1]);
                            gradient.appendChild(stop);
                          }
                        } catch (err) {
                          _iterator5.e(err);
                        } finally {
                          _iterator5.f();
                        }
                        this.defs.appendChild(gradient);
                        return "url(#".concat(shadingId, ")");
                      case "Mesh":
                        (0, _util2.warn)("Unimplemented pattern Mesh");
                        return null;
                      case "Dummy":
                        return "hotpink";
                      default:
                        throw new Error("Unknown IR type: ".concat(args[0]));
                    }
                  }
                }, {
                  key: "setDash",
                  value: function setDash(dashArray, dashPhase) {
                    this.current.dashArray = dashArray;
                    this.current.dashPhase = dashPhase;
                  }
                }, {
                  key: "constructPath",
                  value: function constructPath(ops, args) {
                    var current = this.current;
                    var x = current.x, y = current.y;
                    var d = [];
                    var j = 0;
                    var _iterator6 = _createForOfIteratorHelper2(ops), _step6;
                    try {
                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                        var op = _step6.value;
                        switch (op | 0) {
                          case _util2.OPS.rectangle:
                            x = args[j++];
                            y = args[j++];
                            var width = args[j++];
                            var height = args[j++];
                            var xw = x + width;
                            var yh = y + height;
                            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                            break;
                          case _util2.OPS.moveTo:
                            x = args[j++];
                            y = args[j++];
                            d.push("M", pf(x), pf(y));
                            break;
                          case _util2.OPS.lineTo:
                            x = args[j++];
                            y = args[j++];
                            d.push("L", pf(x), pf(y));
                            break;
                          case _util2.OPS.curveTo:
                            x = args[j + 4];
                            y = args[j + 5];
                            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                            j += 6;
                            break;
                          case _util2.OPS.curveTo2:
                            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                            x = args[j + 2];
                            y = args[j + 3];
                            j += 4;
                            break;
                          case _util2.OPS.curveTo3:
                            x = args[j + 2];
                            y = args[j + 3];
                            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                            j += 4;
                            break;
                          case _util2.OPS.closePath:
                            d.push("Z");
                            break;
                        }
                      }
                    } catch (err) {
                      _iterator6.e(err);
                    } finally {
                      _iterator6.f();
                    }
                    d = d.join(" ");
                    if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                      d = current.path.getAttributeNS(null, "d") + d;
                    } else {
                      current.path = this.svgFactory.createElement("svg:path");
                      this._ensureTransformGroup().appendChild(current.path);
                    }
                    current.path.setAttributeNS(null, "d", d);
                    current.path.setAttributeNS(null, "fill", "none");
                    current.element = current.path;
                    current.setCurrentPoint(x, y);
                  }
                }, {
                  key: "endPath",
                  value: function endPath() {
                    var current = this.current;
                    current.path = null;
                    if (!this.pendingClip) {
                      return;
                    }
                    if (!current.element) {
                      this.pendingClip = null;
                      return;
                    }
                    var clipId = "clippath".concat(clipCount++);
                    var clipPath = this.svgFactory.createElement("svg:clipPath");
                    clipPath.setAttributeNS(null, "id", clipId);
                    clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    var clipElement = current.element.cloneNode(true);
                    if (this.pendingClip === "evenodd") {
                      clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                    } else {
                      clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                    }
                    this.pendingClip = null;
                    clipPath.appendChild(clipElement);
                    this.defs.appendChild(clipPath);
                    if (current.activeClipUrl) {
                      current.clipGroup = null;
                      this.extraStack.forEach(function(prev) {
                        prev.clipGroup = null;
                      });
                      clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                    }
                    current.activeClipUrl = "url(#".concat(clipId, ")");
                    this.tgrp = null;
                  }
                }, {
                  key: "clip",
                  value: function clip(type) {
                    this.pendingClip = type;
                  }
                }, {
                  key: "closePath",
                  value: function closePath() {
                    var current = this.current;
                    if (current.path) {
                      var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
                      current.path.setAttributeNS(null, "d", d);
                    }
                  }
                }, {
                  key: "setLeading",
                  value: function setLeading(leading) {
                    this.current.leading = -leading;
                  }
                }, {
                  key: "setTextRise",
                  value: function setTextRise(textRise) {
                    this.current.textRise = textRise;
                  }
                }, {
                  key: "setTextRenderingMode",
                  value: function setTextRenderingMode(textRenderingMode) {
                    this.current.textRenderingMode = textRenderingMode;
                  }
                }, {
                  key: "setHScale",
                  value: function setHScale(scale) {
                    this.current.textHScale = scale / 100;
                  }
                }, {
                  key: "setRenderingIntent",
                  value: function setRenderingIntent(intent) {
                  }
                }, {
                  key: "setFlatness",
                  value: function setFlatness(flatness) {
                  }
                }, {
                  key: "setGState",
                  value: function setGState(states) {
                    var _iterator7 = _createForOfIteratorHelper2(states), _step7;
                    try {
                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                        var _step7$value = _slicedToArray2(_step7.value, 2), key = _step7$value[0], value = _step7$value[1];
                        switch (key) {
                          case "LW":
                            this.setLineWidth(value);
                            break;
                          case "LC":
                            this.setLineCap(value);
                            break;
                          case "LJ":
                            this.setLineJoin(value);
                            break;
                          case "ML":
                            this.setMiterLimit(value);
                            break;
                          case "D":
                            this.setDash(value[0], value[1]);
                            break;
                          case "RI":
                            this.setRenderingIntent(value);
                            break;
                          case "FL":
                            this.setFlatness(value);
                            break;
                          case "Font":
                            this.setFont(value);
                            break;
                          case "CA":
                            this.setStrokeAlpha(value);
                            break;
                          case "ca":
                            this.setFillAlpha(value);
                            break;
                          default:
                            (0, _util2.warn)("Unimplemented graphic state operator ".concat(key));
                            break;
                        }
                      }
                    } catch (err) {
                      _iterator7.e(err);
                    } finally {
                      _iterator7.f();
                    }
                  }
                }, {
                  key: "fill",
                  value: function fill() {
                    var current = this.current;
                    if (current.element) {
                      current.element.setAttributeNS(null, "fill", current.fillColor);
                      current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      this.endPath();
                    }
                  }
                }, {
                  key: "stroke",
                  value: function stroke() {
                    var current = this.current;
                    if (current.element) {
                      this._setStrokeAttributes(current.element);
                      current.element.setAttributeNS(null, "fill", "none");
                      this.endPath();
                    }
                  }
                }, {
                  key: "_setStrokeAttributes",
                  value: function _setStrokeAttributes(element) {
                    var lineWidthScale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                    var current = this.current;
                    var dashArray = current.dashArray;
                    if (lineWidthScale !== 1 && dashArray.length > 0) {
                      dashArray = dashArray.map(function(value) {
                        return lineWidthScale * value;
                      });
                    }
                    element.setAttributeNS(null, "stroke", current.strokeColor);
                    element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                    element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                    element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                    element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                    element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                    element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                    element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                  }
                }, {
                  key: "eoFill",
                  value: function eoFill() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fill();
                  }
                }, {
                  key: "fillStroke",
                  value: function fillStroke() {
                    this.stroke();
                    this.fill();
                  }
                }, {
                  key: "eoFillStroke",
                  value: function eoFillStroke() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fillStroke();
                  }
                }, {
                  key: "closeStroke",
                  value: function closeStroke() {
                    this.closePath();
                    this.stroke();
                  }
                }, {
                  key: "closeFillStroke",
                  value: function closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }
                }, {
                  key: "closeEOFillStroke",
                  value: function closeEOFillStroke() {
                    this.closePath();
                    this.eoFillStroke();
                  }
                }, {
                  key: "paintSolidColorImageMask",
                  value: function paintSolidColorImageMask() {
                    var rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", "1px");
                    rect.setAttributeNS(null, "height", "1px");
                    rect.setAttributeNS(null, "fill", this.current.fillColor);
                    this._ensureTransformGroup().appendChild(rect);
                  }
                }, {
                  key: "paintImageXObject",
                  value: function paintImageXObject(objId) {
                    var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!imgData) {
                      (0, _util2.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }
                }, {
                  key: "paintInlineImageXObject",
                  value: function paintInlineImageXObject(imgData, mask) {
                    var width = imgData.width;
                    var height = imgData.height;
                    var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                    var cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", "0");
                    cliprect.setAttributeNS(null, "y", "0");
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    var imgEl = this.svgFactory.createElement("svg:image");
                    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                    imgEl.setAttributeNS(null, "x", "0");
                    imgEl.setAttributeNS(null, "y", pf(-height));
                    imgEl.setAttributeNS(null, "width", pf(width) + "px");
                    imgEl.setAttributeNS(null, "height", pf(height) + "px");
                    imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));
                    if (mask) {
                      mask.appendChild(imgEl);
                    } else {
                      this._ensureTransformGroup().appendChild(imgEl);
                    }
                  }
                }, {
                  key: "paintImageMaskXObject",
                  value: function paintImageMaskXObject(imgData) {
                    var current = this.current;
                    var width = imgData.width;
                    var height = imgData.height;
                    var fillColor = current.fillColor;
                    current.maskId = "mask".concat(maskCount++);
                    var mask = this.svgFactory.createElement("svg:mask");
                    mask.setAttributeNS(null, "id", current.maskId);
                    var rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", pf(width));
                    rect.setAttributeNS(null, "height", pf(height));
                    rect.setAttributeNS(null, "fill", fillColor);
                    rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
                    this.defs.appendChild(mask);
                    this._ensureTransformGroup().appendChild(rect);
                    this.paintInlineImageXObject(imgData, mask);
                  }
                }, {
                  key: "paintFormXObjectBegin",
                  value: function paintFormXObjectBegin(matrix, bbox) {
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                    }
                    if (bbox) {
                      var width = bbox[2] - bbox[0];
                      var height = bbox[3] - bbox[1];
                      var cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", bbox[0]);
                      cliprect.setAttributeNS(null, "y", bbox[1]);
                      cliprect.setAttributeNS(null, "width", pf(width));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                }, {
                  key: "paintFormXObjectEnd",
                  value: function paintFormXObjectEnd() {
                  }
                }, {
                  key: "_initialize",
                  value: function _initialize(viewport) {
                    var svg = this.svgFactory.create(viewport.width, viewport.height);
                    var definitions = this.svgFactory.createElement("svg:defs");
                    svg.appendChild(definitions);
                    this.defs = definitions;
                    var rootGroup = this.svgFactory.createElement("svg:g");
                    rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                    svg.appendChild(rootGroup);
                    this.svg = rootGroup;
                    return svg;
                  }
                }, {
                  key: "_ensureClipGroup",
                  value: function _ensureClipGroup() {
                    if (!this.current.clipGroup) {
                      var clipGroup = this.svgFactory.createElement("svg:g");
                      clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                      this.svg.appendChild(clipGroup);
                      this.current.clipGroup = clipGroup;
                    }
                    return this.current.clipGroup;
                  }
                }, {
                  key: "_ensureTransformGroup",
                  value: function _ensureTransformGroup() {
                    if (!this.tgrp) {
                      this.tgrp = this.svgFactory.createElement("svg:g");
                      this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      if (this.current.activeClipUrl) {
                        this._ensureClipGroup().appendChild(this.tgrp);
                      } else {
                        this.svg.appendChild(this.tgrp);
                      }
                    }
                    return this.tgrp;
                  }
                }]);
                return SVGGraphics2;
              }();
            }
          },
          (__unused_webpack_module2, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.XfaLayer = void 0;
            function _slicedToArray2(arr, i) {
              return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
            }
            function _nonIterableRest2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _iterableToArrayLimit2(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles2(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            var XfaLayer = /* @__PURE__ */ function() {
              function XfaLayer2() {
                _classCallCheck2(this, XfaLayer2);
              }
              _createClass2(XfaLayer2, null, [{
                key: "setAttributes",
                value: function setAttributes(html, attrs) {
                  for (var _i = 0, _Object$entries = Object.entries(attrs); _i < _Object$entries.length; _i++) {
                    var _Object$entries$_i = _slicedToArray2(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
                    if (value === null || value === void 0) {
                      continue;
                    }
                    if (key !== "style") {
                      html.setAttribute(key, value);
                    } else {
                      Object.assign(html.style, value);
                    }
                  }
                }
              }, {
                key: "render",
                value: function render(parameters) {
                  var root = parameters.xfa;
                  var rootHtml = document.createElement(root.name);
                  if (root.attributes) {
                    XfaLayer2.setAttributes(rootHtml, root.attributes);
                  }
                  var stack = [[root, -1, rootHtml]];
                  var rootDiv = parameters.div;
                  rootDiv.appendChild(rootHtml);
                  var coeffs = parameters.viewport.transform.join(",");
                  rootDiv.style.transform = "matrix(".concat(coeffs, ")");
                  rootDiv.setAttribute("class", "xfaLayer xfaFont");
                  while (stack.length > 0) {
                    var _stack = _slicedToArray2(stack[stack.length - 1], 3), parent = _stack[0], i = _stack[1], html = _stack[2];
                    if (i + 1 === parent.children.length) {
                      stack.pop();
                      continue;
                    }
                    var child = parent.children[++stack[stack.length - 1][1]];
                    if (child === null) {
                      continue;
                    }
                    var name = child.name;
                    if (name === "#text") {
                      html.appendChild(document.createTextNode(child.value));
                      continue;
                    }
                    var childHtml = document.createElement(name);
                    html.appendChild(childHtml);
                    if (child.attributes) {
                      XfaLayer2.setAttributes(childHtml, child.attributes);
                    }
                    if (child.children && child.children.length > 0) {
                      stack.push([child, -1, childHtml]);
                    } else if (child.value) {
                      childHtml.appendChild(document.createTextNode(child.value));
                    }
                  }
                }
              }, {
                key: "update",
                value: function update(parameters) {
                  var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
                  parameters.div.style.transform = transform;
                  parameters.div.hidden = false;
                }
              }]);
              return XfaLayer2;
            }();
            exports2.XfaLayer = XfaLayer;
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            function _typeof2(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof3(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof2 = function _typeof3(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof2(obj);
            }
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNodeStream = void 0;
            var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(2));
            var _util2 = __w_pdfjs_require__2(4);
            var _network_utils = __w_pdfjs_require__2(144);
            function _interopRequireDefault2(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator2(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            ;
            var fs = require_fs();
            var http = require_http();
            var https = require_https();
            var url = require_url();
            var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
            function parseUrl(sourceUrl) {
              var parsedUrl = url.parse(sourceUrl);
              if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                return parsedUrl;
              }
              if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                return url.parse("file:///".concat(sourceUrl));
              }
              if (!parsedUrl.host) {
                parsedUrl.protocol = "file:";
              }
              return parsedUrl;
            }
            var PDFNodeStream = /* @__PURE__ */ function() {
              function PDFNodeStream2(source) {
                _classCallCheck2(this, PDFNodeStream2);
                this.source = source;
                this.url = parseUrl(source.url);
                this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                this.isFsUrl = this.url.protocol === "file:";
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _createClass2(PDFNodeStream2, [{
                key: "_progressiveDataLength",
                get: function get() {
                  var _this$_fullRequestRea, _this$_fullRequestRea2;
                  return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                }
              }, {
                key: "getFullReader",
                value: function getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                  this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequestReader;
                }
              }, {
                key: "getRangeReader",
                value: function getRangeReader(start, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
              }, {
                key: "cancelAllRequests",
                value: function cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  var readers = this._rangeRequestReaders.slice(0);
                  readers.forEach(function(reader) {
                    reader.cancel(reason);
                  });
                }
              }]);
              return PDFNodeStream2;
            }();
            exports2.PDFNodeStream = PDFNodeStream;
            var BaseFullReader = /* @__PURE__ */ function() {
              function BaseFullReader2(stream) {
                _classCallCheck2(this, BaseFullReader2);
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                var source = stream.source;
                this._contentLength = source.length;
                this._loaded = 0;
                this._filename = null;
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._headersCapability = (0, _util2.createPromiseCapability)();
              }
              _createClass2(BaseFullReader2, [{
                key: "headersReady",
                get: function get() {
                  return this._headersCapability.promise;
                }
              }, {
                key: "filename",
                get: function get() {
                  return this._filename;
                }
              }, {
                key: "contentLength",
                get: function get() {
                  return this._contentLength;
                }
              }, {
                key: "isRangeSupported",
                get: function get() {
                  return this._isRangeSupported;
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }, {
                key: "read",
                value: function() {
                  var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var chunk, buffer;
                    return _regenerator2["default"].wrap(function _callee$2(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return this._readCapability.promise;
                          case 2:
                            if (!this._done) {
                              _context2.next = 4;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value: void 0,
                              done: true
                            });
                          case 4:
                            if (!this._storedError) {
                              _context2.next = 6;
                              break;
                            }
                            throw this._storedError;
                          case 6:
                            chunk = this._readableStream.read();
                            if (!(chunk === null)) {
                              _context2.next = 10;
                              break;
                            }
                            this._readCapability = (0, _util2.createPromiseCapability)();
                            return _context2.abrupt("return", this.read());
                          case 10:
                            this._loaded += chunk.length;
                            if (this.onProgress) {
                              this.onProgress({
                                loaded: this._loaded,
                                total: this._contentLength
                              });
                            }
                            buffer = new Uint8Array(chunk).buffer;
                            return _context2.abrupt("return", {
                              value: buffer,
                              done: false
                            });
                          case 14:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
              }, {
                key: "_error",
                value: function _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
              }, {
                key: "_setReadableStream",
                value: function _setReadableStream(readableStream) {
                  var _this = this;
                  this._readableStream = readableStream;
                  readableStream.on("readable", function() {
                    _this._readCapability.resolve();
                  });
                  readableStream.on("end", function() {
                    readableStream.destroy();
                    _this._done = true;
                    _this._readCapability.resolve();
                  });
                  readableStream.on("error", function(reason) {
                    _this._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util2.AbortException("streaming is disabled"));
                  }
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }]);
              return BaseFullReader2;
            }();
            var BaseRangeReader = /* @__PURE__ */ function() {
              function BaseRangeReader2(stream) {
                _classCallCheck2(this, BaseRangeReader2);
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                this._loaded = 0;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                var source = stream.source;
                this._isStreamingSupported = !source.disableStream;
              }
              _createClass2(BaseRangeReader2, [{
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }, {
                key: "read",
                value: function() {
                  var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var chunk, buffer;
                    return _regenerator2["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return this._readCapability.promise;
                          case 2:
                            if (!this._done) {
                              _context2.next = 4;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value: void 0,
                              done: true
                            });
                          case 4:
                            if (!this._storedError) {
                              _context2.next = 6;
                              break;
                            }
                            throw this._storedError;
                          case 6:
                            chunk = this._readableStream.read();
                            if (!(chunk === null)) {
                              _context2.next = 10;
                              break;
                            }
                            this._readCapability = (0, _util2.createPromiseCapability)();
                            return _context2.abrupt("return", this.read());
                          case 10:
                            this._loaded += chunk.length;
                            if (this.onProgress) {
                              this.onProgress({
                                loaded: this._loaded
                              });
                            }
                            buffer = new Uint8Array(chunk).buffer;
                            return _context2.abrupt("return", {
                              value: buffer,
                              done: false
                            });
                          case 14:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read2.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
              }, {
                key: "_error",
                value: function _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
              }, {
                key: "_setReadableStream",
                value: function _setReadableStream(readableStream) {
                  var _this2 = this;
                  this._readableStream = readableStream;
                  readableStream.on("readable", function() {
                    _this2._readCapability.resolve();
                  });
                  readableStream.on("end", function() {
                    readableStream.destroy();
                    _this2._done = true;
                    _this2._readCapability.resolve();
                  });
                  readableStream.on("error", function(reason) {
                    _this2._error(reason);
                  });
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }]);
              return BaseRangeReader2;
            }();
            function createRequestOptions(parsedUrl, headers) {
              return {
                protocol: parsedUrl.protocol,
                auth: parsedUrl.auth,
                host: parsedUrl.hostname,
                port: parsedUrl.port,
                path: parsedUrl.path,
                method: "GET",
                headers
              };
            }
            var PDFNodeStreamFullReader = /* @__PURE__ */ function(_BaseFullReader) {
              _inherits(PDFNodeStreamFullReader2, _BaseFullReader);
              var _super = _createSuper(PDFNodeStreamFullReader2);
              function PDFNodeStreamFullReader2(stream) {
                var _this3;
                _classCallCheck2(this, PDFNodeStreamFullReader2);
                _this3 = _super.call(this, stream);
                var handleResponse = function handleResponse2(response) {
                  if (response.statusCode === 404) {
                    var error = new _util2.MissingPDFException('Missing PDF "'.concat(_this3._url, '".'));
                    _this3._storedError = error;
                    _this3._headersCapability.reject(error);
                    return;
                  }
                  _this3._headersCapability.resolve();
                  _this3._setReadableStream(response);
                  var getResponseHeader = function getResponseHeader2(name) {
                    return _this3._readableStream.headers[name.toLowerCase()];
                  };
                  var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: stream.isHttp,
                    rangeChunkSize: _this3._rangeChunkSize,
                    disableRange: _this3._disableRange
                  }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                  _this3._isRangeSupported = allowRangeRequests;
                  _this3._contentLength = suggestedLength || _this3._contentLength;
                  _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                };
                _this3._request = null;
                if (_this3._url.protocol === "http:") {
                  _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
                } else {
                  _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
                }
                _this3._request.on("error", function(reason) {
                  _this3._storedError = reason;
                  _this3._headersCapability.reject(reason);
                });
                _this3._request.end();
                return _this3;
              }
              return PDFNodeStreamFullReader2;
            }(BaseFullReader);
            var PDFNodeStreamRangeReader = /* @__PURE__ */ function(_BaseRangeReader) {
              _inherits(PDFNodeStreamRangeReader2, _BaseRangeReader);
              var _super2 = _createSuper(PDFNodeStreamRangeReader2);
              function PDFNodeStreamRangeReader2(stream, start, end) {
                var _this4;
                _classCallCheck2(this, PDFNodeStreamRangeReader2);
                _this4 = _super2.call(this, stream);
                _this4._httpHeaders = {};
                for (var property in stream.httpHeaders) {
                  var value = stream.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  _this4._httpHeaders[property] = value;
                }
                _this4._httpHeaders.Range = "bytes=".concat(start, "-").concat(end - 1);
                var handleResponse = function handleResponse2(response) {
                  if (response.statusCode === 404) {
                    var error = new _util2.MissingPDFException('Missing PDF "'.concat(_this4._url, '".'));
                    _this4._storedError = error;
                    return;
                  }
                  _this4._setReadableStream(response);
                };
                _this4._request = null;
                if (_this4._url.protocol === "http:") {
                  _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
                } else {
                  _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
                }
                _this4._request.on("error", function(reason) {
                  _this4._storedError = reason;
                });
                _this4._request.end();
                return _this4;
              }
              return PDFNodeStreamRangeReader2;
            }(BaseRangeReader);
            var PDFNodeStreamFsFullReader = /* @__PURE__ */ function(_BaseFullReader2) {
              _inherits(PDFNodeStreamFsFullReader2, _BaseFullReader2);
              var _super3 = _createSuper(PDFNodeStreamFsFullReader2);
              function PDFNodeStreamFsFullReader2(stream) {
                var _this5;
                _classCallCheck2(this, PDFNodeStreamFsFullReader2);
                _this5 = _super3.call(this, stream);
                var path = decodeURIComponent(_this5._url.path);
                if (fileUriRegex.test(_this5._url.href)) {
                  path = path.replace(/^\//, "");
                }
                fs.lstat(path, function(error, stat) {
                  if (error) {
                    if (error.code === "ENOENT") {
                      error = new _util2.MissingPDFException('Missing PDF "'.concat(path, '".'));
                    }
                    _this5._storedError = error;
                    _this5._headersCapability.reject(error);
                    return;
                  }
                  _this5._contentLength = stat.size;
                  _this5._setReadableStream(fs.createReadStream(path));
                  _this5._headersCapability.resolve();
                });
                return _this5;
              }
              return PDFNodeStreamFsFullReader2;
            }(BaseFullReader);
            var PDFNodeStreamFsRangeReader = /* @__PURE__ */ function(_BaseRangeReader2) {
              _inherits(PDFNodeStreamFsRangeReader2, _BaseRangeReader2);
              var _super4 = _createSuper(PDFNodeStreamFsRangeReader2);
              function PDFNodeStreamFsRangeReader2(stream, start, end) {
                var _this6;
                _classCallCheck2(this, PDFNodeStreamFsRangeReader2);
                _this6 = _super4.call(this, stream);
                var path = decodeURIComponent(_this6._url.path);
                if (fileUriRegex.test(_this6._url.href)) {
                  path = path.replace(/^\//, "");
                }
                _this6._setReadableStream(fs.createReadStream(path, {
                  start,
                  end: end - 1
                }));
                return _this6;
              }
              return PDFNodeStreamFsRangeReader2;
            }(BaseRangeReader);
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.createResponseStatusError = createResponseStatusError;
            exports2.extractFilenameFromHeader = extractFilenameFromHeader;
            exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
            exports2.validateResponseStatus = validateResponseStatus;
            var _util2 = __w_pdfjs_require__2(4);
            var _content_disposition = __w_pdfjs_require__2(145);
            var _display_utils2 = __w_pdfjs_require__2(1);
            function validateRangeRequestCapabilities(_ref) {
              var getResponseHeader = _ref.getResponseHeader, isHttp = _ref.isHttp, rangeChunkSize = _ref.rangeChunkSize, disableRange = _ref.disableRange;
              (0, _util2.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
              var returnValues = {
                allowRangeRequests: false,
                suggestedLength: void 0
              };
              var length = parseInt(getResponseHeader("Content-Length"), 10);
              if (!Number.isInteger(length)) {
                return returnValues;
              }
              returnValues.suggestedLength = length;
              if (length <= 2 * rangeChunkSize) {
                return returnValues;
              }
              if (disableRange || !isHttp) {
                return returnValues;
              }
              if (getResponseHeader("Accept-Ranges") !== "bytes") {
                return returnValues;
              }
              var contentEncoding = getResponseHeader("Content-Encoding") || "identity";
              if (contentEncoding !== "identity") {
                return returnValues;
              }
              returnValues.allowRangeRequests = true;
              return returnValues;
            }
            function extractFilenameFromHeader(getResponseHeader) {
              var contentDisposition = getResponseHeader("Content-Disposition");
              if (contentDisposition) {
                var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                if (filename.includes("%")) {
                  try {
                    filename = decodeURIComponent(filename);
                  } catch (ex) {
                  }
                }
                if ((0, _display_utils2.isPdfFile)(filename)) {
                  return filename;
                }
              }
              return null;
            }
            function createResponseStatusError(status, url) {
              if (status === 404 || status === 0 && url.startsWith("file:")) {
                return new _util2.MissingPDFException('Missing PDF "' + url + '".');
              }
              return new _util2.UnexpectedResponseException("Unexpected server response (".concat(status, ') while retrieving PDF "').concat(url, '".'), status);
            }
            function validateResponseStatus(status) {
              return status === 200 || status === 206;
            }
          },
          (__unused_webpack_module2, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
            function _slicedToArray2(arr, i) {
              return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
            }
            function _nonIterableRest2() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray2(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray2(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray2(o, minLen);
            }
            function _arrayLikeToArray2(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _iterableToArrayLimit2(arr, i) {
              if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles2(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function getFilenameFromContentDispositionHeader(contentDisposition) {
              var needsEncodingFixup = true;
              var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                var filename = rfc2616unquote(tmp);
                filename = unescape(filename);
                filename = rfc5987decode(filename);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              tmp = rfc2231getparam(contentDisposition);
              if (tmp) {
                var _filename = rfc2047decode(tmp);
                return fixupEncoding(_filename);
              }
              tmp = toParamRegExp("filename", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                var _filename2 = rfc2616unquote(tmp);
                _filename2 = rfc2047decode(_filename2);
                return fixupEncoding(_filename2);
              }
              function toParamRegExp(attributePattern, flags) {
                return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
              }
              function textdecode(encoding, value) {
                if (encoding) {
                  if (!/^[\x00-\xFF]+$/.test(value)) {
                    return value;
                  }
                  try {
                    var decoder = new TextDecoder(encoding, {
                      fatal: true
                    });
                    var bytes = Array.from(value, function(ch) {
                      return ch.charCodeAt(0) & 255;
                    });
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                  } catch (e) {
                    if (/^utf-?8$/i.test(encoding)) {
                      try {
                        value = decodeURIComponent(escape(value));
                        needsEncodingFixup = false;
                      } catch (err) {
                      }
                    }
                  }
                }
                return value;
              }
              function fixupEncoding(value) {
                if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                  value = textdecode("utf-8", value);
                  if (needsEncodingFixup) {
                    value = textdecode("iso-8859-1", value);
                  }
                }
                return value;
              }
              function rfc2231getparam(contentDispositionStr) {
                var matches = [];
                var match;
                var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                while ((match = iter.exec(contentDispositionStr)) !== null) {
                  var _match = match, _match2 = _slicedToArray2(_match, 4), n = _match2[1], quot = _match2[2], part = _match2[3];
                  n = parseInt(n, 10);
                  if (n in matches) {
                    if (n === 0) {
                      break;
                    }
                    continue;
                  }
                  matches[n] = [quot, part];
                }
                var parts = [];
                for (var _n2 = 0; _n2 < matches.length; ++_n2) {
                  if (!(_n2 in matches)) {
                    break;
                  }
                  var _matches$_n = _slicedToArray2(matches[_n2], 2), _quot = _matches$_n[0], _part = _matches$_n[1];
                  _part = rfc2616unquote(_part);
                  if (_quot) {
                    _part = unescape(_part);
                    if (_n2 === 0) {
                      _part = rfc5987decode(_part);
                    }
                  }
                  parts.push(_part);
                }
                return parts.join("");
              }
              function rfc2616unquote(value) {
                if (value.startsWith('"')) {
                  var parts = value.slice(1).split('\\"');
                  for (var i = 0; i < parts.length; ++i) {
                    var quotindex = parts[i].indexOf('"');
                    if (quotindex !== -1) {
                      parts[i] = parts[i].slice(0, quotindex);
                      parts.length = i + 1;
                    }
                    parts[i] = parts[i].replace(/\\(.)/g, "$1");
                  }
                  value = parts.join('"');
                }
                return value;
              }
              function rfc5987decode(extvalue) {
                var encodingend = extvalue.indexOf("'");
                if (encodingend === -1) {
                  return extvalue;
                }
                var encoding = extvalue.slice(0, encodingend);
                var langvalue = extvalue.slice(encodingend + 1);
                var value = langvalue.replace(/^[^']*'/, "");
                return textdecode(encoding, value);
              }
              function rfc2047decode(value) {
                if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                  return value;
                }
                return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                  if (encoding === "q" || encoding === "Q") {
                    text = text.replace(/_/g, " ");
                    text = text.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                      return String.fromCharCode(parseInt(hex, 16));
                    });
                    return textdecode(charset, text);
                  }
                  try {
                    text = atob(text);
                  } catch (e) {
                  }
                  return textdecode(charset, text);
                });
              }
              return "";
            }
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNetworkStream = void 0;
            var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(2));
            var _util2 = __w_pdfjs_require__2(4);
            var _network_utils = __w_pdfjs_require__2(144);
            function _interopRequireDefault2(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator2(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            ;
            var OK_RESPONSE = 200;
            var PARTIAL_CONTENT_RESPONSE = 206;
            function getArrayBuffer(xhr) {
              var data = xhr.response;
              if (typeof data !== "string") {
                return data;
              }
              var array = (0, _util2.stringToBytes)(data);
              return array.buffer;
            }
            var NetworkManager = /* @__PURE__ */ function() {
              function NetworkManager2(url, args) {
                _classCallCheck2(this, NetworkManager2);
                this.url = url;
                args = args || {};
                this.isHttp = /^https?:/i.test(url);
                this.httpHeaders = this.isHttp && args.httpHeaders || {};
                this.withCredentials = args.withCredentials || false;
                this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                  return new XMLHttpRequest();
                };
                this.currXhrId = 0;
                this.pendingRequests = /* @__PURE__ */ Object.create(null);
              }
              _createClass2(NetworkManager2, [{
                key: "requestRange",
                value: function requestRange(begin, end, listeners) {
                  var args = {
                    begin,
                    end
                  };
                  for (var prop in listeners) {
                    args[prop] = listeners[prop];
                  }
                  return this.request(args);
                }
              }, {
                key: "requestFull",
                value: function requestFull(listeners) {
                  return this.request(listeners);
                }
              }, {
                key: "request",
                value: function request(args) {
                  var xhr = this.getXhr();
                  var xhrId = this.currXhrId++;
                  var pendingRequest = this.pendingRequests[xhrId] = {
                    xhr
                  };
                  xhr.open("GET", this.url);
                  xhr.withCredentials = this.withCredentials;
                  for (var property in this.httpHeaders) {
                    var value = this.httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    xhr.setRequestHeader(property, value);
                  }
                  if (this.isHttp && "begin" in args && "end" in args) {
                    xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                  } else {
                    pendingRequest.expectedStatus = OK_RESPONSE;
                  }
                  xhr.responseType = "arraybuffer";
                  if (args.onError) {
                    xhr.onerror = function(evt) {
                      args.onError(xhr.status);
                    };
                  }
                  xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                  xhr.onprogress = this.onProgress.bind(this, xhrId);
                  pendingRequest.onHeadersReceived = args.onHeadersReceived;
                  pendingRequest.onDone = args.onDone;
                  pendingRequest.onError = args.onError;
                  pendingRequest.onProgress = args.onProgress;
                  xhr.send(null);
                  return xhrId;
                }
              }, {
                key: "onProgress",
                value: function onProgress(xhrId, evt) {
                  var pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  if (pendingRequest.onProgress) {
                    pendingRequest.onProgress(evt);
                  }
                }
              }, {
                key: "onStateChange",
                value: function onStateChange(xhrId, evt) {
                  var pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  var xhr = pendingRequest.xhr;
                  if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                    pendingRequest.onHeadersReceived();
                    delete pendingRequest.onHeadersReceived;
                  }
                  if (xhr.readyState !== 4) {
                    return;
                  }
                  if (!(xhrId in this.pendingRequests)) {
                    return;
                  }
                  delete this.pendingRequests[xhrId];
                  if (xhr.status === 0 && this.isHttp) {
                    if (pendingRequest.onError) {
                      pendingRequest.onError(xhr.status);
                    }
                    return;
                  }
                  var xhrStatus = xhr.status || OK_RESPONSE;
                  var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                  if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                    if (pendingRequest.onError) {
                      pendingRequest.onError(xhr.status);
                    }
                    return;
                  }
                  var chunk = getArrayBuffer(xhr);
                  if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                    var rangeHeader = xhr.getResponseHeader("Content-Range");
                    var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                    pendingRequest.onDone({
                      begin: parseInt(matches[1], 10),
                      chunk
                    });
                  } else if (chunk) {
                    pendingRequest.onDone({
                      begin: 0,
                      chunk
                    });
                  } else if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                }
              }, {
                key: "getRequestXhr",
                value: function getRequestXhr(xhrId) {
                  return this.pendingRequests[xhrId].xhr;
                }
              }, {
                key: "isPendingRequest",
                value: function isPendingRequest(xhrId) {
                  return xhrId in this.pendingRequests;
                }
              }, {
                key: "abortRequest",
                value: function abortRequest(xhrId) {
                  var xhr = this.pendingRequests[xhrId].xhr;
                  delete this.pendingRequests[xhrId];
                  xhr.abort();
                }
              }]);
              return NetworkManager2;
            }();
            var PDFNetworkStream = /* @__PURE__ */ function() {
              function PDFNetworkStream2(source) {
                _classCallCheck2(this, PDFNetworkStream2);
                this._source = source;
                this._manager = new NetworkManager(source.url, {
                  httpHeaders: source.httpHeaders,
                  withCredentials: source.withCredentials
                });
                this._rangeChunkSize = source.rangeChunkSize;
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _createClass2(PDFNetworkStream2, [{
                key: "_onRangeRequestReaderClosed",
                value: function _onRangeRequestReaderClosed(reader) {
                  var i = this._rangeRequestReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeRequestReaders.splice(i, 1);
                  }
                }
              }, {
                key: "getFullReader",
                value: function getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                  return this._fullRequestReader;
                }
              }, {
                key: "getRangeReader",
                value: function getRangeReader(begin, end) {
                  var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                  reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
              }, {
                key: "cancelAllRequests",
                value: function cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  var readers = this._rangeRequestReaders.slice(0);
                  readers.forEach(function(reader) {
                    reader.cancel(reason);
                  });
                }
              }]);
              return PDFNetworkStream2;
            }();
            exports2.PDFNetworkStream = PDFNetworkStream;
            var PDFNetworkStreamFullRequestReader = /* @__PURE__ */ function() {
              function PDFNetworkStreamFullRequestReader2(manager, source) {
                _classCallCheck2(this, PDFNetworkStreamFullRequestReader2);
                this._manager = manager;
                var args = {
                  onHeadersReceived: this._onHeadersReceived.bind(this),
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = source.url;
                this._fullRequestId = manager.requestFull(args);
                this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._contentLength = source.length;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = false;
                this._isRangeSupported = false;
                this._cachedChunks = [];
                this._requests = [];
                this._done = false;
                this._storedError = void 0;
                this._filename = null;
                this.onProgress = null;
              }
              _createClass2(PDFNetworkStreamFullRequestReader2, [{
                key: "_onHeadersReceived",
                value: function _onHeadersReceived() {
                  var fullRequestXhrId = this._fullRequestId;
                  var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                  var getResponseHeader = function getResponseHeader2(name) {
                    return fullRequestXhr.getResponseHeader(name);
                  };
                  var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._manager.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                  if (allowRangeRequests) {
                    this._isRangeSupported = true;
                  }
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (this._isRangeSupported) {
                    this._manager.abortRequest(fullRequestXhrId);
                  }
                  this._headersReceivedCapability.resolve();
                }
              }, {
                key: "_onDone",
                value: function _onDone(args) {
                  if (args) {
                    if (this._requests.length > 0) {
                      var requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: args.chunk,
                        done: false
                      });
                    } else {
                      this._cachedChunks.push(args.chunk);
                    }
                  }
                  this._done = true;
                  if (this._cachedChunks.length > 0) {
                    return;
                  }
                  this._requests.forEach(function(requestCapability2) {
                    requestCapability2.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                }
              }, {
                key: "_onError",
                value: function _onError(status) {
                  var url = this._url;
                  var exception = (0, _network_utils.createResponseStatusError)(status, url);
                  this._storedError = exception;
                  this._headersReceivedCapability.reject(exception);
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.reject(exception);
                  });
                  this._requests = [];
                  this._cachedChunks = [];
                }
              }, {
                key: "_onProgress",
                value: function _onProgress(data) {
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: data.loaded,
                      total: data.lengthComputable ? data.total : this._contentLength
                    });
                  }
                }
              }, {
                key: "filename",
                get: function get() {
                  return this._filename;
                }
              }, {
                key: "isRangeSupported",
                get: function get() {
                  return this._isRangeSupported;
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }, {
                key: "contentLength",
                get: function get() {
                  return this._contentLength;
                }
              }, {
                key: "headersReady",
                get: function get() {
                  return this._headersReceivedCapability.promise;
                }
              }, {
                key: "read",
                value: function() {
                  var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var chunk, requestCapability;
                    return _regenerator2["default"].wrap(function _callee$2(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!this._storedError) {
                              _context2.next = 2;
                              break;
                            }
                            throw this._storedError;
                          case 2:
                            if (!(this._cachedChunks.length > 0)) {
                              _context2.next = 5;
                              break;
                            }
                            chunk = this._cachedChunks.shift();
                            return _context2.abrupt("return", {
                              value: chunk,
                              done: false
                            });
                          case 5:
                            if (!this._done) {
                              _context2.next = 7;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value: void 0,
                              done: true
                            });
                          case 7:
                            requestCapability = (0, _util2.createPromiseCapability)();
                            this._requests.push(requestCapability);
                            return _context2.abrupt("return", requestCapability.promise);
                          case 10:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  this._done = true;
                  this._headersReceivedCapability.reject(reason);
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                  if (this._manager.isPendingRequest(this._fullRequestId)) {
                    this._manager.abortRequest(this._fullRequestId);
                  }
                  this._fullRequestReader = null;
                }
              }]);
              return PDFNetworkStreamFullRequestReader2;
            }();
            var PDFNetworkStreamRangeRequestReader = /* @__PURE__ */ function() {
              function PDFNetworkStreamRangeRequestReader2(manager, begin, end) {
                _classCallCheck2(this, PDFNetworkStreamRangeRequestReader2);
                this._manager = manager;
                var args = {
                  onDone: this._onDone.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._requestId = manager.requestRange(begin, end, args);
                this._requests = [];
                this._queuedChunk = null;
                this._done = false;
                this.onProgress = null;
                this.onClosed = null;
              }
              _createClass2(PDFNetworkStreamRangeRequestReader2, [{
                key: "_close",
                value: function _close() {
                  if (this.onClosed) {
                    this.onClosed(this);
                  }
                }
              }, {
                key: "_onDone",
                value: function _onDone(data) {
                  var chunk = data.chunk;
                  if (this._requests.length > 0) {
                    var requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunk = chunk;
                  }
                  this._done = true;
                  this._requests.forEach(function(requestCapability2) {
                    requestCapability2.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                  this._close();
                }
              }, {
                key: "_onProgress",
                value: function _onProgress(evt) {
                  if (!this.isStreamingSupported && this.onProgress) {
                    this.onProgress({
                      loaded: evt.loaded
                    });
                  }
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return false;
                }
              }, {
                key: "read",
                value: function() {
                  var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var chunk, requestCapability;
                    return _regenerator2["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!(this._queuedChunk !== null)) {
                              _context2.next = 4;
                              break;
                            }
                            chunk = this._queuedChunk;
                            this._queuedChunk = null;
                            return _context2.abrupt("return", {
                              value: chunk,
                              done: false
                            });
                          case 4:
                            if (!this._done) {
                              _context2.next = 6;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value: void 0,
                              done: true
                            });
                          case 6:
                            requestCapability = (0, _util2.createPromiseCapability)();
                            this._requests.push(requestCapability);
                            return _context2.abrupt("return", requestCapability.promise);
                          case 9:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read2.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  this._done = true;
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                  if (this._manager.isPendingRequest(this._requestId)) {
                    this._manager.abortRequest(this._requestId);
                  }
                  this._close();
                }
              }]);
              return PDFNetworkStreamRangeRequestReader2;
            }();
          },
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFFetchStream = void 0;
            var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(2));
            var _util2 = __w_pdfjs_require__2(4);
            var _network_utils = __w_pdfjs_require__2(144);
            function _interopRequireDefault2(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(_next, _throw);
              }
            }
            function _asyncToGenerator2(fn) {
              return function() {
                var self2 = this, args = arguments;
                return new Promise(function(resolve, reject) {
                  var gen = fn.apply(self2, args);
                  function _next(value) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                  }
                  function _throw(err) {
                    asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                  }
                  _next(void 0);
                });
              };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties2(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass2(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties2(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties2(Constructor, staticProps);
              return Constructor;
            }
            ;
            function createFetchOptions(headers, withCredentials, abortController) {
              return {
                method: "GET",
                headers,
                signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
                mode: "cors",
                credentials: withCredentials ? "include" : "same-origin",
                redirect: "follow"
              };
            }
            function createHeaders(httpHeaders) {
              var headers = new Headers();
              for (var property in httpHeaders) {
                var value = httpHeaders[property];
                if (typeof value === "undefined") {
                  continue;
                }
                headers.append(property, value);
              }
              return headers;
            }
            var PDFFetchStream = /* @__PURE__ */ function() {
              function PDFFetchStream2(source) {
                _classCallCheck2(this, PDFFetchStream2);
                this.source = source;
                this.isHttp = /^https?:/i.test(source.url);
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _createClass2(PDFFetchStream2, [{
                key: "_progressiveDataLength",
                get: function get() {
                  var _this$_fullRequestRea, _this$_fullRequestRea2;
                  return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
                }
              }, {
                key: "getFullReader",
                value: function getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
              }, {
                key: "getRangeReader",
                value: function getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  var reader = new PDFFetchStreamRangeReader(this, begin, end);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
              }, {
                key: "cancelAllRequests",
                value: function cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  var readers = this._rangeRequestReaders.slice(0);
                  readers.forEach(function(reader) {
                    reader.cancel(reason);
                  });
                }
              }]);
              return PDFFetchStream2;
            }();
            exports2.PDFFetchStream = PDFFetchStream;
            var PDFFetchStreamReader = /* @__PURE__ */ function() {
              function PDFFetchStreamReader2(stream) {
                var _this = this;
                _classCallCheck2(this, PDFFetchStreamReader2);
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                this._filename = null;
                var source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._contentLength = source.length;
                this._headersCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._headers = createHeaders(this._stream.httpHeaders);
                var url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  _this._reader = response.body.getReader();
                  _this._headersCapability.resolve();
                  var getResponseHeader = function getResponseHeader2(name) {
                    return response.headers.get(name);
                  };
                  var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: _this._stream.isHttp,
                    rangeChunkSize: _this._rangeChunkSize,
                    disableRange: _this._disableRange
                  }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                  _this._isRangeSupported = allowRangeRequests;
                  _this._contentLength = suggestedLength || _this._contentLength;
                  _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (!_this._isStreamingSupported && _this._isRangeSupported) {
                    _this.cancel(new _util2.AbortException("Streaming is disabled."));
                  }
                })["catch"](this._headersCapability.reject);
                this.onProgress = null;
              }
              _createClass2(PDFFetchStreamReader2, [{
                key: "headersReady",
                get: function get() {
                  return this._headersCapability.promise;
                }
              }, {
                key: "filename",
                get: function get() {
                  return this._filename;
                }
              }, {
                key: "contentLength",
                get: function get() {
                  return this._contentLength;
                }
              }, {
                key: "isRangeSupported",
                get: function get() {
                  return this._isRangeSupported;
                }
              }, {
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }, {
                key: "read",
                value: function() {
                  var _read = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var _yield$this$_reader$r, value, done, buffer;
                    return _regenerator2["default"].wrap(function _callee$2(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return this._headersCapability.promise;
                          case 2:
                            _context2.next = 4;
                            return this._reader.read();
                          case 4:
                            _yield$this$_reader$r = _context2.sent;
                            value = _yield$this$_reader$r.value;
                            done = _yield$this$_reader$r.done;
                            if (!done) {
                              _context2.next = 9;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value,
                              done
                            });
                          case 9:
                            this._loaded += value.byteLength;
                            if (this.onProgress) {
                              this.onProgress({
                                loaded: this._loaded,
                                total: this._contentLength
                              });
                            }
                            buffer = new Uint8Array(value).buffer;
                            return _context2.abrupt("return", {
                              value: buffer,
                              done: false
                            });
                          case 13:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  if (this._abortController) {
                    this._abortController.abort();
                  }
                }
              }]);
              return PDFFetchStreamReader2;
            }();
            var PDFFetchStreamRangeReader = /* @__PURE__ */ function() {
              function PDFFetchStreamRangeReader2(stream, begin, end) {
                var _this2 = this;
                _classCallCheck2(this, PDFFetchStreamRangeReader2);
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                var source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._isStreamingSupported = !source.disableStream;
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._headers = createHeaders(this._stream.httpHeaders);
                this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));
                var url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  _this2._readCapability.resolve();
                  _this2._reader = response.body.getReader();
                })["catch"](function(reason) {
                  if ((reason === null || reason === void 0 ? void 0 : reason.name) === "AbortError") {
                    return;
                  }
                  throw reason;
                });
                this.onProgress = null;
              }
              _createClass2(PDFFetchStreamRangeReader2, [{
                key: "isStreamingSupported",
                get: function get() {
                  return this._isStreamingSupported;
                }
              }, {
                key: "read",
                value: function() {
                  var _read2 = _asyncToGenerator2(/* @__PURE__ */ _regenerator2["default"].mark(function _callee2() {
                    var _yield$this$_reader$r2, value, done, buffer;
                    return _regenerator2["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return this._readCapability.promise;
                          case 2:
                            _context2.next = 4;
                            return this._reader.read();
                          case 4:
                            _yield$this$_reader$r2 = _context2.sent;
                            value = _yield$this$_reader$r2.value;
                            done = _yield$this$_reader$r2.done;
                            if (!done) {
                              _context2.next = 9;
                              break;
                            }
                            return _context2.abrupt("return", {
                              value,
                              done
                            });
                          case 9:
                            this._loaded += value.byteLength;
                            if (this.onProgress) {
                              this.onProgress({
                                loaded: this._loaded
                              });
                            }
                            buffer = new Uint8Array(value).buffer;
                            return _context2.abrupt("return", {
                              value: buffer,
                              done: false
                            });
                          case 13:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                  function read() {
                    return _read2.apply(this, arguments);
                  }
                  return read;
                }()
              }, {
                key: "cancel",
                value: function cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  if (this._abortController) {
                    this._abortController.abort();
                  }
                }
              }]);
              return PDFFetchStreamRangeReader2;
            }();
          }
        ];
        var __webpack_module_cache__ = {};
        function __w_pdfjs_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            id: moduleId,
            loaded: false,
            exports: {}
          };
          __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __w_pdfjs_require__);
          module2.loaded = true;
          return module2.exports;
        }
        (() => {
          __w_pdfjs_require__.nmd = (module2) => {
            module2.paths = [];
            if (!module2.children)
              module2.children = [];
            return module2;
          };
        })();
        var __webpack_exports__ = {};
        (() => {
          "use strict";
          var exports2 = __webpack_exports__;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          Object.defineProperty(exports2, "addLinkAttributes", {
            enumerable: true,
            get: function get() {
              return _display_utils2.addLinkAttributes;
            }
          });
          Object.defineProperty(exports2, "getFilenameFromUrl", {
            enumerable: true,
            get: function get() {
              return _display_utils2.getFilenameFromUrl;
            }
          });
          Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
            enumerable: true,
            get: function get() {
              return _display_utils2.getPdfFilenameFromUrl;
            }
          });
          Object.defineProperty(exports2, "isPdfFile", {
            enumerable: true,
            get: function get() {
              return _display_utils2.isPdfFile;
            }
          });
          Object.defineProperty(exports2, "LinkTarget", {
            enumerable: true,
            get: function get() {
              return _display_utils2.LinkTarget;
            }
          });
          Object.defineProperty(exports2, "loadScript", {
            enumerable: true,
            get: function get() {
              return _display_utils2.loadScript;
            }
          });
          Object.defineProperty(exports2, "PDFDateString", {
            enumerable: true,
            get: function get() {
              return _display_utils2.PDFDateString;
            }
          });
          Object.defineProperty(exports2, "RenderingCancelledException", {
            enumerable: true,
            get: function get() {
              return _display_utils2.RenderingCancelledException;
            }
          });
          Object.defineProperty(exports2, "build", {
            enumerable: true,
            get: function get() {
              return _api.build;
            }
          });
          Object.defineProperty(exports2, "getDocument", {
            enumerable: true,
            get: function get() {
              return _api.getDocument;
            }
          });
          Object.defineProperty(exports2, "LoopbackPort", {
            enumerable: true,
            get: function get() {
              return _api.LoopbackPort;
            }
          });
          Object.defineProperty(exports2, "PDFDataRangeTransport", {
            enumerable: true,
            get: function get() {
              return _api.PDFDataRangeTransport;
            }
          });
          Object.defineProperty(exports2, "PDFWorker", {
            enumerable: true,
            get: function get() {
              return _api.PDFWorker;
            }
          });
          Object.defineProperty(exports2, "version", {
            enumerable: true,
            get: function get() {
              return _api.version;
            }
          });
          Object.defineProperty(exports2, "CMapCompressionType", {
            enumerable: true,
            get: function get() {
              return _util2.CMapCompressionType;
            }
          });
          Object.defineProperty(exports2, "createObjectURL", {
            enumerable: true,
            get: function get() {
              return _util2.createObjectURL;
            }
          });
          Object.defineProperty(exports2, "createPromiseCapability", {
            enumerable: true,
            get: function get() {
              return _util2.createPromiseCapability;
            }
          });
          Object.defineProperty(exports2, "createValidAbsoluteUrl", {
            enumerable: true,
            get: function get() {
              return _util2.createValidAbsoluteUrl;
            }
          });
          Object.defineProperty(exports2, "InvalidPDFException", {
            enumerable: true,
            get: function get() {
              return _util2.InvalidPDFException;
            }
          });
          Object.defineProperty(exports2, "MissingPDFException", {
            enumerable: true,
            get: function get() {
              return _util2.MissingPDFException;
            }
          });
          Object.defineProperty(exports2, "OPS", {
            enumerable: true,
            get: function get() {
              return _util2.OPS;
            }
          });
          Object.defineProperty(exports2, "PasswordResponses", {
            enumerable: true,
            get: function get() {
              return _util2.PasswordResponses;
            }
          });
          Object.defineProperty(exports2, "PermissionFlag", {
            enumerable: true,
            get: function get() {
              return _util2.PermissionFlag;
            }
          });
          Object.defineProperty(exports2, "removeNullCharacters", {
            enumerable: true,
            get: function get() {
              return _util2.removeNullCharacters;
            }
          });
          Object.defineProperty(exports2, "shadow", {
            enumerable: true,
            get: function get() {
              return _util2.shadow;
            }
          });
          Object.defineProperty(exports2, "UnexpectedResponseException", {
            enumerable: true,
            get: function get() {
              return _util2.UnexpectedResponseException;
            }
          });
          Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
            enumerable: true,
            get: function get() {
              return _util2.UNSUPPORTED_FEATURES;
            }
          });
          Object.defineProperty(exports2, "Util", {
            enumerable: true,
            get: function get() {
              return _util2.Util;
            }
          });
          Object.defineProperty(exports2, "VerbosityLevel", {
            enumerable: true,
            get: function get() {
              return _util2.VerbosityLevel;
            }
          });
          Object.defineProperty(exports2, "AnnotationLayer", {
            enumerable: true,
            get: function get() {
              return _annotation_layer.AnnotationLayer;
            }
          });
          Object.defineProperty(exports2, "apiCompatibilityParams", {
            enumerable: true,
            get: function get() {
              return _api_compatibility2.apiCompatibilityParams;
            }
          });
          Object.defineProperty(exports2, "GlobalWorkerOptions", {
            enumerable: true,
            get: function get() {
              return _worker_options2.GlobalWorkerOptions;
            }
          });
          Object.defineProperty(exports2, "renderTextLayer", {
            enumerable: true,
            get: function get() {
              return _text_layer.renderTextLayer;
            }
          });
          Object.defineProperty(exports2, "SVGGraphics", {
            enumerable: true,
            get: function get() {
              return _svg.SVGGraphics;
            }
          });
          Object.defineProperty(exports2, "XfaLayer", {
            enumerable: true,
            get: function get() {
              return _xfa_layer.XfaLayer;
            }
          });
          var _display_utils2 = __w_pdfjs_require__(1);
          var _api = __w_pdfjs_require__(125);
          var _util2 = __w_pdfjs_require__(4);
          var _annotation_layer = __w_pdfjs_require__(138);
          var _api_compatibility2 = __w_pdfjs_require__(129);
          var _worker_options2 = __w_pdfjs_require__(132);
          var _text_layer = __w_pdfjs_require__(140);
          var _svg = __w_pdfjs_require__(141);
          var _xfa_layer = __w_pdfjs_require__(142);
          var pdfjsVersion = "2.8.335";
          var pdfjsBuild = "228adbf67";
          {
            var _require = __w_pdfjs_require__(6), isNodeJS = _require.isNodeJS;
            if (isNodeJS) {
              var PDFNodeStream = __w_pdfjs_require__(143).PDFNodeStream;
              (0, _api.setPDFNetworkStreamFactory)(function(params) {
                return new PDFNodeStream(params);
              });
            } else {
              var PDFNetworkStream = __w_pdfjs_require__(146).PDFNetworkStream;
              var PDFFetchStream;
              if ((0, _display_utils2.isFetchSupported)()) {
                PDFFetchStream = __w_pdfjs_require__(147).PDFFetchStream;
              }
              (0, _api.setPDFNetworkStreamFactory)(function(params) {
                if (PDFFetchStream && (0, _display_utils2.isValidFetchUrl)(params.url)) {
                  return new PDFFetchStream(params);
                }
                return new PDFNetworkStream(params);
              });
            }
          }
        })();
        return __webpack_exports__;
      })();
    });
  }
});

// packages/layers/canvas-layer.tsx
var import_react = __toESM(require_react());
var CanvasLayer = (props) => {
  const { pageDoc, pageIndex, width, height, scale } = props;
  const canvasRef = (0, import_react.useRef)(null);
  const renderTask = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (canvasRef.current) {
      if (renderTask.current) {
        renderTask.current.cancel();
      }
      var viewport = pageDoc.getViewport({ scale });
      var outputScale = window.devicePixelRatio || 1;
      var context = canvasRef.current.getContext("2d");
      canvasRef.current.height = Math.floor(viewport.height * outputScale);
      canvasRef.current.width = Math.floor(viewport.width * outputScale);
      canvasRef.current.style.width = `${Math.floor(viewport.width)}px`;
      canvasRef.current.style.height = `${Math.floor(viewport.height)}px`;
      canvasRef.current.hidden = true;
      const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : void 0;
      if (context) {
        renderTask.current = pageDoc.render({
          canvasContext: context,
          viewport,
          transform
        });
        renderTask.current.promise.then(() => {
          if (canvasRef.current) {
            canvasRef.current.hidden = false;
          }
        }, () => {
          if (canvasRef.current) {
            canvasRef.current.hidden = false;
          }
        });
      }
    }
    return () => {
      if (canvasRef.current) {
        canvasRef.current.width = 0;
        canvasRef.current.height = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ import_react.default.createElement("canvas", {
    key: pageIndex,
    ref: canvasRef
  });
};
var canvas_layer_default = CanvasLayer;

// packages/layers/svg-layer.tsx
var import_react2 = __toESM(require_react());
var SvgLayer = (props) => {
  return /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, "SvgLayer Component");
};
var svg_layer_default = SvgLayer;

// packages/layers/text-layer.tsx
var import_react3 = __toESM(require_react());

// packages/vendors/lib.ts
var PDFLib = __toESM(require_pdf());

// packages/layers/text-layer.tsx
var TextLayer = (props) => {
  const { pageDoc, pageIndex, scale } = props;
  const textContainerRef = (0, import_react3.useRef)(null);
  const renderTask = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    if (renderTask.current) {
      renderTask.current.cancel();
    }
    if (textContainerRef.current) {
      const viewport = pageDoc.getViewport({ scale });
      pageDoc.getTextContent().then((textContent) => {
        if (textContent && textContainerRef.current) {
          renderTask.current = PDFLib.renderTextLayer({
            container: textContainerRef.current,
            viewport,
            textContent
          });
        }
      });
    }
    return () => {
    };
  }, []);
  return /* @__PURE__ */ import_react3.default.createElement("div", {
    ref: textContainerRef
  });
};
var text_layer_default = TextLayer;

// packages/viewer/index.tsx
var import_lodash = __toESM(require_lodash());
var import_react7 = __toESM(require_react());

// packages/layers/page-layer.tsx
var import_react4 = __toESM(require_react());
var PageLayer = ({
  doc,
  pageIndex,
  width,
  height,
  children
}) => {
  const [pageDoc, setPageDoc] = (0, import_react4.useState)();
  (0, import_react4.useEffect)(() => {
    doc.getPage(pageIndex).then((pageDoc2) => {
      setPageDoc(pageDoc2);
    });
  }, [pageIndex, doc]);
  return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, pageDoc ? /* @__PURE__ */ import_react4.default.createElement("div", {
    id: `__page_${pageIndex}__`,
    style: { height, width }
  }, children(pageDoc)) : null);
};
var page_layer_default = PageLayer;

// packages/resizer/index.tsx
var import_react6 = __toESM(require_react());

// packages/hooks/useRectObserver.ts
var import_react5 = __toESM(require_react());
function useRectObserver({ elRef }) {
  const [width, setWidth] = (0, import_react5.useState)(0);
  const [height, setHeight] = (0, import_react5.useState)(0);
  const observer = (0, import_react5.useRef)(null);
  function resizeObserver(entries) {
    for (const entry of entries) {
      const { width: width2, height: height2 } = entry.contentRect;
      setWidth(width2);
      setHeight(height2);
    }
  }
  (0, import_react5.useEffect)(() => {
    if (elRef.current) {
      observer.current = new ResizeObserver(resizeObserver);
      observer.current.observe(elRef.current);
    }
    return () => {
      if (elRef.current && observer.current) {
        observer.current.unobserve(elRef.current);
        observer.current.disconnect();
      }
    };
  }, []);
  return {
    height,
    width
  };
}

// packages/types/constant.ts
var VERTICAL_PADDING = 5;
var Horizontal_PADDING = 5;

// packages/resizer/index.tsx
var Resizer = ({ doc, scale, children }) => {
  const resizerRef = (0, import_react6.useRef)(null);
  const [pageSize, setPageSize] = (0, import_react6.useState)({
    width: 0,
    height: 0,
    scale: 1
  });
  const { width, height } = useRectObserver({
    elRef: resizerRef
  });
  (0, import_react6.useEffect)(() => {
    doc.getPage(1).then((page) => {
      const viewport = page.getViewport({
        scale: 1
      });
      if (typeof scale === "string") {
        const horizontalPadding = Horizontal_PADDING * 2;
        const verticalPadding = VERTICAL_PADDING * 2;
        switch (scale) {
          case "fitHeight": {
            const pageScale = (height - horizontalPadding) / viewport.height;
            setPageSize({
              height: height - horizontalPadding,
              scale: pageScale,
              width: viewport.width * pageScale
            });
            break;
          }
          case "fitWidth": {
            const pageScale = (width - verticalPadding) / viewport.width;
            setPageSize({
              height: viewport.height * pageScale,
              scale: pageScale,
              width: width - verticalPadding
            });
            break;
          }
          default: {
            const heightScale = (height - horizontalPadding) / viewport.height;
            const widthScale = (width - verticalPadding) / viewport.width;
            const pageScale = Math.min(heightScale, widthScale);
            setPageSize({
              height: viewport.height * pageScale,
              scale: pageScale,
              width: viewport.width * pageScale
            });
          }
        }
      } else {
        setPageSize({
          width: viewport.height * scale,
          height: viewport.height * scale,
          scale
        });
      }
    });
  }, [doc, width, height, scale]);
  return /* @__PURE__ */ import_react6.default.createElement("div", {
    ref: resizerRef
  }, pageSize.width == 0 ? null : children(pageSize));
};
var resizer_default = Resizer;

// packages/viewer/index.tsx
var PDFViewer = ({
  pdfURI,
  loadingComponent,
  errorComponent,
  scale
}) => {
  const [loading, setLoading] = (0, import_react7.useState)(false);
  const [loadingProgress, setLoadingProgress] = (0, import_react7.useState)(-1);
  const [pdfDoc, setPDFDoc] = (0, import_react7.useState)();
  const [errorReason, setErrorReason] = (0, import_react7.useState)();
  const loadingTask = (0, import_react7.useRef)(null);
  (0, import_react7.useEffect)(() => {
    if (pdfURI) {
      loadingTask.current = PDFLib.getDocument(pdfURI);
      loadingTask.current.onProgress = (progress) => {
        setLoadingProgress(progress);
      };
      loadingTask.current.promise.then((pdf) => {
        setPDFDoc(pdf);
      }).catch((reason) => {
        setErrorReason(reason);
      }).finally(() => {
        setLoading(false);
      });
    }
  }, [pdfURI]);
  function contentComponent() {
    if (!pdfURI) {
      return "\u8BF7\u8F93\u5165 PDF";
    }
    if (loading) {
      return typeof loadingComponent == "function" ? loadingComponent(loadingProgress) : loadingComponent;
    }
    if (errorReason || !pdfDoc) {
      return typeof errorComponent == "function" ? errorComponent(errorReason) : errorComponent;
    }
    return /* @__PURE__ */ import_react7.default.createElement(resizer_default, {
      doc: pdfDoc,
      scale
    }, (pageSize) => /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, (0, import_lodash.range)(0, pdfDoc.numPages - 1).map((index) => {
      return /* @__PURE__ */ import_react7.default.createElement(page_layer_default, __spreadValues({
        key: index,
        pageIndex: index,
        doc: pdfDoc
      }, pageSize), (doc) => [
        /* @__PURE__ */ import_react7.default.createElement(canvas_layer_default, __spreadProps(__spreadValues({}, pageSize), {
          pageDoc: doc,
          pageIndex: index
        }))
      ]);
    })));
  }
  return /* @__PURE__ */ import_react7.default.createElement("div", {
    id: "pdf_viewer_container",
    className: "pdf-viewer-container"
  }, contentComponent());
};
var viewer_default = PDFViewer;

// packages/worker/index.tsx
var PDFLib2 = __toESM(require_pdf2());
var import_react8 = __toESM(require_react());
var PDFWorker2 = ({ workerDir, children }) => {
  PDFLib2.GlobalWorkerOptions.workerSrc = workerDir;
  return /* @__PURE__ */ import_react8.default.createElement(import_react8.default.Fragment, null, children);
};
var worker_default = PDFWorker2;
export {
  canvas_layer_default as CanvasLayer,
  viewer_default as PDFViewer,
  worker_default as PDFWorker,
  svg_layer_default as SVGLayer,
  text_layer_default as TextLayer
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=index.mjs.map
